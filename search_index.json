[["index.html", "Tidy Survey Book Preface", " Tidy Survey Book Stephanie Zimmer, Rebecca J. Powell, and Isabella Velásquez 2023-08-29 Preface "],["c01-intro.html", "Chapter 1 Introduction 1.1 What to expect 1.2 Datasets used in this book", " Chapter 1 Introduction Surveys are used to gather information about a population. They are frequently used by researchers, governments, and businesses to better understand public opinion and behavior. For example, a non-profit group might be interested in public opinion on a given topic, government agencies may be interested in behaviors to inform policy, or companies may survey potential consumers about what they want from their products. Developing and fielding a survey is a method to gather information about topics that interest us. This book focuses on how to analyze the data collected from a survey. We assume that you have conducted a survey or obtained a microdata file. Microdata, also known as respondent-level or row-level data, contains individual survey responses, analysis weights, and design variables (as opposed to opposed to summarized data in tables). For the purposes of this book, you need the weights and design variables for your survey data. These are required to accurately calculate unbiased estimates1. Understanding the concepts and techniques discussed in this book will help you to extract meaningful insights from your survey data. To account for the weights and study design, researchers rely on statistical software such as SAS, Stata, SUDAAN, and R. In this book, we will use R to provide an overview to survey analysis. Our goal is to provide a comprehensive guide for individuals new to survey analysis but have some statistics and R programming background. We will use a combination of both the {survey} and {srvyr} packages and present the code following best practices from the tidyverse. In 2003, the {survey} package was released on CRAN and has been continuously developed over time2. This package, primarily developed by Thomas Lumley, is extensive and includes the following features: Estimates of point estimates and their associated variances, including means, totals, ratios, quantiles, and proportions Estimation of regression models, including generalized linear models, log-linear models, and survival curves Variances by Taylor linearization or by replicate weights (balance repeated replication, jackknife, bootstrap, multistage bootstrap, or user-supplied) Hypothesis testing for means, proportions, and more The {srvyr} package in R builds on the {survey} package. It provides wrappers for functions that align with the tidyverse philosophy, which is our motivation for using and recommending this package. We find that the {srvyr} package is user-friendly for those familiar with tidyverse packages in R. For example, while many functions in the {survey} package use variables as formulas, the {srvyr} package uses tidy selection to pass variable names3 (a common feature in the tidyverse). Users of the tidyverse are most likely familiar with the magittr pipe (%&gt;%), which seamlessly works with functions from the {srvyr} package. Moreover, several common functions from {dplyr}, such as including filter(), mutate(), and summarize(), can be applied to survey objects. Users can streamline their analysis workflow and capitalize on the benefits of both the {srvyr} and tidyverse packages. There is one limitation to the {srvyr} package: it doesn’t fully incorporate the modeling capabilities of the {survey} package into its tidy versions. This book will use the {survey} package when discussing modeling and hypothesis testing. However, we will guide you on how to apply the pipe to these functions to ensure clarity in your analyses. 1.1 What to expect This book will cover many aspects of survey design and analysis, from understanding how to create design effects to conducting descriptive analysis, statistical tests, and models. Additionally, we emphasize best practices in coding and presenting results. Throughout this book, we use real-world data and present practical examples to help you gain proficiency in survey analysis. While we provide a brief overview of survey methodology and statistical theory, this book is not intended to be the sole resource for these topics. We reference other materials throughout the book and encourage readers to seek those out for more information. Below is a summary of each chapter: Chapter 2: An overview of surveys and the process of designing surveys. This is only an overview, and we include many references for more in-depth knowledge. Chapter 3: Specifying sampling designs. Descriptions of common sampling designs, when they are used, the math behind the mean and standard error estimates, how to specify the designs in R, and examples using real data. Chapter 4: Understanding survey documentation. How to read the various components of survey documentation, working with missing data, and finding the documentation. Chapter 5: Descriptive analyses. Calculating point estimates along with their standard errors, confidence intervals, and design effects. Chapter 6: Statistical testing. Testing for differences between groups, including comparisons of means and proportions as well as goodness of fit tests, tests of independence, and tests of homogeneity. Chapter 7: Modeling. Linear regression, ANOVA, and logistic regression. Chapter 8: Communicating results. Describing results, reproducibility, making publishable tables and graphs, and helpful functions. Chapter 9: National Crime Victimization Survey Vignette. A vignette on how to analyze data from the NCVS, a survey in the U.S. that collects information on crimes and their characteristics. This illustrates an analysis that requires multiple files to calculate victimization rates. Chapter 10: AmericasBarometer Vignette. A vignette on how to analyze data from the AmericasBarometer, a survey of attitudes, evaluations, experiences, and behavior in countries in the Western Hemisphere. This includes how to make choropleth maps with survey estimates. In most chapters, you’ll find code that you can follow. Each of these chapters starts with a “set-up” section. This section will include the code needed to load the necessary packages and datasets in the chapter. We then provide the main idea of the chapter and examples on how to use the functions. Most chapters end with exercises to work through. Solutions to the exercises can be found in the Appendix. 1.2 Datasets used in this book We work with two key datasets throughout the book: the Residential Energy Consumption Survey (RECS – U.S. Energy Information Administration 2017) and the American National Election Studies (ANES – DeBell 2010). To ensure that all readers can follow the examples, we have provided analytic datasets available on OSF4. If there is any data you need from the book that isn’t part of existing packages, we have created a helper function, read_osf(), to help you load it. Here’s how to use the code to read in the RECS and ANES datasets: library(tidyverse) library(survey) library(srvyr) library(osfr) source(&quot;helper-fun/helper-functions.R&quot;) recs_in &lt;- read_osf(&quot;recs_2015.rds&quot;) anes_in &lt;- read_osf(&quot;anes_2020.rds&quot;) RECS is a study that provides energy consumption and expenditures data in American households. The Energy Information Administration funds RECS, and the data is collected through interviews with energy suppliers. These interviews happen in person, over the phone, and on the web. It has been fielded 14 times between 1950 and 2020. The survey includes questions about appliances, electronics, heating, air conditioning (A/C), temperatures, water heating, lighting, energy bills, respondent demographics, and energy assistance. Below is an overview of the recs_in data: recs_in ## # A tibble: 5,686 × 141 ## DOEID REGIONC Region Division MSAStatus Urbanicity HousingUnitType ## &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; ## 1 10001 4 West Pacific Metropol… Urban Area Single-family … ## 2 10002 3 South West So… None Rural Single-family … ## 3 10003 3 South East So… Metropol… Urban Area Single-family … ## 4 10004 2 Midwest West No… Micropol… Urban Clu… Single-family … ## 5 10005 1 Northeast Middle … Metropol… Urban Area Single-family … ## 6 10006 1 Northeast New Eng… None Urban Clu… Apartment: 5 o… ## 7 10007 3 South South A… Metropol… Urban Area Apartment: 2-4… ## 8 10008 2 Midwest East No… Metropol… Rural Single-family … ## 9 10009 1 Northeast Middle … Metropol… Urban Area Single-family … ## 10 10010 3 South West So… Metropol… Urban Area Single-family … ## # ℹ 5,676 more rows ## # ℹ 134 more variables: YearMade &lt;ord&gt;, SpaceHeatingUsed &lt;lgl&gt;, ## # HeatingBehavior &lt;fct&gt;, WinterTempDay &lt;dbl&gt;, WinterTempAway &lt;dbl&gt;, ## # WinterTempNight &lt;dbl&gt;, ACUsed &lt;lgl&gt;, ACBehavior &lt;fct&gt;, ## # SummerTempDay &lt;dbl&gt;, SummerTempAway &lt;dbl&gt;, SummerTempNight &lt;dbl&gt;, ## # TOTCSQFT &lt;dbl&gt;, TOTHSQFT &lt;dbl&gt;, TOTSQFT_EN &lt;dbl&gt;, TOTUCSQFT &lt;dbl&gt;, ## # TOTUSQFT &lt;dbl&gt;, NWEIGHT &lt;dbl&gt;, BRRWT1 &lt;dbl&gt;, BRRWT2 &lt;dbl&gt;, … From this output, we can see that there are 5,686 rows and 141 variables. We can see that there are variables containing an ID (DOEID), regional information (e.g., Region, MSAStatus), along with information about the house, including the type of house (HousingUnitType) and when the house was built (YearMade). Additionally, there is a long list of weighting variables that we will use in the analysis (e.g., NWEIGHT, BRRWT1). We will discuss using these weighting variables in Chapter 3. For a more detailed codebook, see Appendix B. The ANES is a series study that has collected data from election surveys since 1948. These surveys contain data on public opinion and voting behavior in U.S. presidential elections. The 2020 survey (the data we will be using) was fielded to individuals over the web, through live video interviewing, or over with computer-assisted telephone interviewing (CATI). The survey includes questions on party affiliation, voting choice, and level of trust with the government. Here is an overview of the anes_in data. First, we show the variables starting with “V” followed by a number; these are the original variables. Then, we show you the remaining variables that we created based on the original data: anes_in %&gt;% select(matches(&quot;^V\\\\d&quot;)) ## # A tibble: 7,453 × 22 ## V200010b V200010d V200010c V200002 V201006 V201102 V201101 V201103 ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;hvn_lbll&gt; &lt;hvn_l&gt; &lt;hvn_l&gt; &lt;hvn_l&gt; &lt;hvn_l&gt; ## 1 1.01 9 2 3 2 1 -1 2 ## 2 1.16 26 2 3 3 1 -1 5 ## 3 0.769 41 1 3 2 1 -1 1 ## 4 0.521 29 2 3 3 1 -1 1 ## 5 0.966 23 1 3 2 1 -1 2 ## 6 0.235 37 2 3 1 2 -1 -1 ## 7 0.441 7 1 3 2 1 -1 5 ## 8 0.769 37 2 3 3 2 -1 -1 ## 9 1.42 32 2 3 2 -1 1 1 ## 10 1.84 41 2 3 2 -1 1 1 ## # ℹ 7,443 more rows ## # ℹ 14 more variables: V201025x &lt;hvn_lbll&gt;, V201231x &lt;hvn_lbll&gt;, ## # V201233 &lt;hvn_lbll&gt;, V201237 &lt;hvn_lbll&gt;, V201507x &lt;hvn_lbll&gt;, ## # V201510 &lt;hvn_lbll&gt;, V201549x &lt;hvn_lbll&gt;, V201600 &lt;hvn_lbll&gt;, ## # V201617x &lt;hvn_lbll&gt;, V202066 &lt;hvn_lbll&gt;, V202109x &lt;hvn_lbll&gt;, ## # V202072 &lt;hvn_lbll&gt;, V202073 &lt;hvn_lbll&gt;, V202110x &lt;hvn_lbll&gt; anes_in %&gt;% select(-matches(&quot;^V\\\\d&quot;)) ## # A tibble: 7,453 × 20 ## InterviewMode Weight Stratum VarUnit Age AgeGroup Gender RaceEth ## &lt;fct&gt; &lt;dbl&gt; &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; ## 1 Web 1.01 9 2 46 40-49 Male Hispan… ## 2 Web 1.16 26 2 37 30-39 Female Asian,… ## 3 Web 0.769 41 1 40 40-49 Female White ## 4 Web 0.521 29 2 41 40-49 Male Asian,… ## 5 Web 0.966 23 1 72 70 or older Male AI/AN ## 6 Web 0.235 37 2 71 70 or older Female White ## 7 Web 0.441 7 1 37 30-39 Female White ## 8 Web 0.769 37 2 45 40-49 Female White ## 9 Web 1.42 32 2 70 70 or older Female White ## 10 Web 1.84 41 2 43 40-49 Male Hispan… ## # ℹ 7,443 more rows ## # ℹ 12 more variables: PartyID &lt;fct&gt;, Education &lt;fct&gt;, Income &lt;fct&gt;, ## # Income7 &lt;fct&gt;, CampaignInterest &lt;fct&gt;, TrustGovernment &lt;fct&gt;, ## # TrustPeople &lt;fct&gt;, VotedPres2016 &lt;fct&gt;, ## # VotedPres2016_selection &lt;fct&gt;, VotedPres2020 &lt;fct&gt;, ## # VotedPres2020_selection &lt;fct&gt;, EarlyVote2020 &lt;fct&gt; From this output we can see that there are 7,453 rows and 42 variables. Most of the variables start with V20, so referencing the documentation for survey will be crucial to not get lost (see Chapter 4). We have created some more descriptive variables for you to use throughout this book, such as the age (Age) and gender (Gender) of the respondent, along with variables that represent their party affiliation (PartyID). Additionally, we need the variables Weight and Stratum to analyze this data accurately. We will discuss how to use these weighting variables in Chapters 3 and 4. For a more detailed codebook, see Appendix A. References "],["c02-overview-surveys.html", "Chapter 2 Overview of Surveys 2.1 Introduction 2.2 Pre-Survey Planning 2.3 Study Design 2.4 Data Collection 2.5 Post-Survey Processing 2.6 Post-survey data analysis and reporting", " Chapter 2 Overview of Surveys 2.1 Introduction Developing surveys to gather accurate information about populations involves a more intricate and time-intensive process compared to surveys that use non-random criteria for selecting samples. Researchers can spend months, or even years, developing the study design, questions, and other methods for a single survey to ensure high-quality data is collected. While this book focuses on the analysis methods of complex surveys, understanding the entire survey life cycle can provide a better insight into what types of analyses should be conducted on the data. The survey life cycle consists of the necessary stages to execute a survey project successfully. Each stage influences the survey’s timing, costs, and feasibility, consequently impacting the data collected and how we should analyze it. The survey life cycle starts with a research topic or question of interest (e.g., what impact does childhood trauma have on health outcomes later in life). Researchers typically review existing data sources to determine if data are already available that can answer this question, as drawing from available resources can result in a reduced burden on respondents, cheaper research costs, and faster research outcomes. However, if existing data cannot answer the nuances of the research question, a survey can be used to capture the exact data that the researcher needs. To gain a deeper understanding of survey design and implementation, we recommend reviewing several pieces of existing literature in detail (e.g., Dillman, Smyth, and Christian 2014; Groves et al. 2009; Tourangeau, Rips, and Rasinski 2000; Bradburn, Sudman, and Wansink 2004; Valliant, Dever, and Kreuter 2013; Biemer and Lyberg 2003). 2.2 Pre-Survey Planning There are multiple things to consider when starting a survey. Errors are the differences between the true values of the variables being studied and the values obtained through the survey. Each step and decision made before the launch of the survey impact the types of errors that are introduced into the data, which in turn impact how to interpret the results. Generally, survey researchers consider there to be seven main sources of error that fall under either Representation and Measurement (Groves et al. 2009): Representation Coverage Error: A mismatch between the population of interest (also known as the target population or study population) and the sampling frame. Sampling Error: Error produced when selecting a sample, the subset of the population, from the sampling frame, the list from which the sample is drawn (there is no sampling error if conducting a census). This error is due to randomization, and we discuss how to quantify this error in Chapter 3. Nonresponse Error: Differences between those who responded and did not respond to the survey (unit nonresponse) or a given question (item nonresponse). Adjustment Error: Error introduced during post-survey statistical adjustments. Measurement Validity: A mismatch between the topic of interest and the question(s) used to collect that information. Measurement Error: A mismatch between what the researcher asked and how the respondent answered. Processing Error: Edits by the researcher to responses provided by the respondent (e.g., adjustments to data based on illogical responses). Almost every survey has errors. Researchers attempt to conduct a survey that reduces the total survey error, or the accumulation of all errors that may arise throughout the survey life cycle. By assessing these different types of errors together, researchers can seek strategies to maximize the overall survey quality and improve the reliability and validity of results (Biemer 2010). However, attempts to lower individual sources errors (and therefore total survey error) come at the price of time, resources, and money. For example: Coverage Error Tradeoff: Researchers can search for or create more accurate and updated sampling frames, but they can be difficult to construct or obtain. Sampling Error Tradeoff: Researchers can increase the sample size to reduce sampling error; however, larger samples can be expensive and time-consuming to field. Nonresponse Error Tradeoff: Researchers can increase or diversify efforts to improve survey participation but this may be resource-intensive while not entirely removing nonresponse bias. Adjustment Error Tradeoff: Weighting, or a statistical technique used to adjust the contribution of individual survey responses to the final survey estimates, is typically done to make the sample more representative of the target population. However, if researchers do not carefully execute the adjustments or base them on inaccurate information, they can introduce new biases, leading to less accurate estimates. Validity Error Tradeoff: Reseachers can increase validity through a variety of ways, such as extensive research, using established scales, or collaborating with a psychometrician during survey design. However, doing so lengthens the amount of time and resources needed to complete survey design. Measurement Error Tradeoff: Reseachers can use techniques such as questionnaire testing and cognitive interviewing to ensure respondents are answering questions as expected. However, these activities also require time and resources to complete. Processing Error Tradeoff: Researchers can impose rigorous data cleaning and validation processes. However, this requires supervision, training, and time. The challenge for survey researchers is to find the optimal tradeoffs among these errors. They must carefully consider ways to reduce each error source and total survey error while balancing their study’s objectives and resources. For survey analysts, understanding the decisions that researchers took to minimize these error sources can impact how results are interpreted. The remainder of this chapter dives into critical considerations for survey development. We explore how to consider each of these sources of error and how these error sources can inform the interpretations of the data. 2.3 Study Design From formulating methodologies to choosing an appropriate sampling frame, the study design phase is where the blueprint for a successful survey takes shape. Study design encompasses multiple parts of the survey life cycle, including decisions on the population of interest, survey mode (the format through which a survey is administered to respondents), timeline, and questionnaire design. Knowing who and how to survey individuals depends on the study’s goals and the feasibility of implementation. This section explores the strategic planning that lays the foundation for a survey. 2.3.1 Sampling Design The set or group we want to survey is known as the population of interest. The population of interest could be broad, such as “all adults age 18+ living in the U.S.” or a specific population based on a particular characteristic or location. For example, we may want to know about “adults aged 18-24 who live in North Carolina” or “eligible voters living in Illinois.” However, a sampling frame with contact information is needed to survey individuals in these populations of interest. If researchers are looking at eligible voters, the sampling frame could be the voting registry for a given state or area. The sampling frame is likely imperfect for more broad target populations like all adults in the United States. In these cases, researchers may choose to use a sampling frame of mailing addresses and send the survey to households, or they may choose to use random digit dialing (RDD) and call random phone numbers (that may or may not be assigned, connected, and working). These imperfect sampling frames can result in coverage error where there is a mismatch between the target population and the list of individuals researchers can select. For example, if a researcher is looking to obtain estimates for “all adults aged 18+ living in the U.S.”, a sampling frame of mailing addresses will miss specific types of individuals, such as the homeless, transient populations, and incarcerated individuals. Additionally, many households have more than one adult living there, so researchers would need to consider how to get a specific individual to fill out the survey (called within household selection) or adjust the target population to report on “U.S. households” instead of “individuals.” Once the researchers have selected the sampling frame, the next step is determining how to select individuals for the survey. In rare cases, researchers may conduct a census and survey everyone on the sampling frame. However, the ability to implement a questionnaire at that scale is something only some can do (e.g., government censuses). Instead, researchers typically choose to sample individuals and use weights to estimate numbers in the target population. They can use a variety of different sampling methods, and more information on these can be found in Chapter 3. This decision of which sampling method to use impacts sampling error and can be accounted for in weighting. Example: Number of Pets in a Household Let’s use a simple example where a researcher is interested in the average number of pets in a household. Our researcher needs to consider the target population for this study. Specifically, are they interested in all households in a given country or households in a more local area (e.g., city or state)? Let’s assume our researcher is interested in the number of pets in a U.S. household with at least one adult (18 years old or older). In this case, a sampling frame of mailing addresses would provide the least coverage error as the frame would closely match our target population. Specifically, our researcher would likely want to use the Computerized Delivery Sequence File (CDSF), which is a file of mailing addresses that the United States Postal Service (USPS) creates and covers nearly 100% of U.S. households (Harter et al. 2016). To sample these households, for simplicity, we use a stratified simple random sample design, where we randomly sample households within each state (i.e., we stratify by state). Throughout this chapter, we build on this example research question to plan a survey. 2.3.2 Data Collection Planning With the sampling design decided, researchers can then decide how to survey these individuals. Specifically, the modes used for contacting and surveying the sample, how frequently to send reminders and follow-ups, and the overall timeline of the study are four of the major data collection determinations. Traditionally, researchers have considered four main modes5: Computer Assisted Personal Interview (CAPI; also known as face-to-face or in-person interviewing) Computer Assisted Telephone Interview (CATI; also known as phone or telephone interviewing) Computer Assisted Web Interview (CAWI; also known as web or online interviewing) Paper and Pencil Interview (PAPI) Researchers can use a single mode to collect data or multiple modes (also called mixed modes). Using mixed modes can allow for broader reach and increase response rates depending on the target population (DeLeeuw 2005, 2018; Biemer et al. 2017). For example, researchers could both call households to conduct a CATI survey and send mail with a PAPI survey to the household. Using both modes, researchers could gain participation through the mail from individuals who do not pick up the phone to unknown numbers or through the phone from individuals who do not open all of their mail. However, mode effects (where responses differ based on the mode of response) can be present in the data and may need to be considered during analysis. When selecting which mode, or modes, to use, understanding the unique aspects of the chosen target population and sampling frame provides insight into how they can best be reached and engaged. For example, if we plan to survey adults aged 18-24 who live in North Carolina, asking them to complete a survey using CATI (i.e., over the phone) would likely not be as successful as other modes like the web. This age group does not talk on the phone as much as other generations and often does not answer their phones for unknown numbers. Additionally, the mode for contacting respondents relies on what information is available in the sampling frame. For example, if our sampling frame includes an email address, we could email our selected sample members to convince them to complete a survey. Alternatively, if the sampling frame is a list of mailing addresses, we could contact sample members with a letter. It is important to note that there can be a difference between the contact and survey modes. For example, if we have a sampling frame with addresses, we can send a letter to our sample members and provide information on completing a web survey. Another option is using mixed-mode surveys by sending sample members a paper and pencil survey with our letter and also asking them to complete the survey online. Combining different contact modes and different survey modes can be helpful in reducing unit nonresponse error–where the entire unit (e.g., a household) does not respond to the survey at all–as different sample members may respond better to different contact and survey modes. However, when considering which modes to use, it is important to make access to the survey as easy as possible for sample members to reduce burden and unit nonresponse. Another way to reduce unit nonresponse error is by varying the language of the contact materials (Dillman, Smyth, and Christian 2014). People are motivated by different things, so constantly repeating the same message may not be helpful. Instead, mixing up the messaging and the type of contact material the sample member receives can increase response rates and reduce the unit nonresponse error. For example, instead of only sending standard letters, researchers could consider sending mailings that invoke “urgent” or “important” thoughts by sending priority letters or using other delivery services like FedEx, UPS, or DHL. A study timeline may also determine the number and types of contacts. If the timeline is long, there is plentiful time for follow-ups and diversified messages in contact materials. If the timeline is short, then fewer follow-ups can be implemented. Many studies start with the tailored design method put forth by Dillman, Smyth, and Christian (2014) and implement five contacts: Prenotification (Prenotice) letting sample members know the survey is coming Invitation to complete the survey Reminder that also thanks the respondents that may have already completed the survey Reminder (with a replacement paper survey if needed) Final reminder This method is easily adaptable based on the study timeline and needs but provides a starting point for most studies. Example: Number of Pets in a Household Let’s return to our example of a researcher who wants to know the average number of pets in a household. We are using a sampling frame of mailing addresses, so we recommend starting our data collection with letters mailed to households, but later in data collection, we want to send interviewers to the house to conduct an in-person (or CAPI) interview to decrease unit nonresponse error. This means we have two contact modes (paper and in-person). As mentioned above, the survey mode does not have to be the same as the contact mode, so we recommend a mixed-mode study with both Web and CAPI modes. Let’s assume we have six months for data collection, so we may want to recommend the following protocol: Protocol Example for 6-month Web and CAPI Data Collection Week Contact Mode Contact Message Survey Mode Offered 1 Mail: Letter Prenotice — 2 Mail: Letter Invitation Web 3 Mail: Postcard Thank You/Reminder Web 6 Mail: Letter in large envelope Animal Welfare Discussion Web 10 Mail: Postcard Inform Upcoming In-Person Visit Web 14 In-Person Visit — CAPI 16 Mail: Letter Reminder of In-Person Visit Web, but includes a number to call to schedule CAPI 20 In-Person Visit — CAPI 25 Mail: Letter in large envelope Survey Closing Notice Web, but includes a number to call to schedule CAPI This is just one possible protocol that we can use that starts respondents with the web (typically done to reduce costs). However, researchers may want to begin in-person data collection earlier during the data collection period or ask their interviewers to attempt more than two visits with a household. 2.3.3 Questionnaire Design When developing the questionnaire, it can be helpful to first outline the topics to be asked and include the “why” each question or topic is important to the research question(s). This can help researchers better tailor the questionnaire and reduce the number of questions (and thus the burden on the respondent) if topics are deemed irrelevant to the research question. When making these decisions, researchers should also consider questions needed for weighting. While we would love to have everyone in our population of interest answer our survey, this is rarely the case. Thus, including questions about demographics in the survey can assist with weighting for nonresponse errors (both unit and item nonresponse). Knowing the details of the sampling plan and what may impact coverage error and sampling error can help researchers determine what types of demographics to include. Researchers can benefit from the work of others by using questions from other surveys. Demographic sections such as race, ethnicity, or education borrow questions from a government census or other official surveys. Question banks such as the Inter-university Consortium for Political and Social Research (ICPSR) variable search can provide additional potential questions. If a question does not exist in a question bank, researchers can craft their own. When developing survey questions, researchers should start with the research topic and attempt to write questions that match the concept. The closer the question asked is to the overall concept, the better validity there is. For example, if the researcher wants to know how people consume T.V. series and movies but only asks a question about how many T.V.s are in the house, then they would be missing other ways that people watch T.V. series and movies, such as on other devices or at places outside of the home. As mentioned above, researchers can employ techniques to increase the validity of their questionnaires. For example, questionnaire testing involves piloting the survey instrument to identify and fix potential issues before conducting the main survey. Additionally, researchers could conduct cognitive interviews – a technique where researchers walk through the survey with participants, encouraging them to speak their thoughts out loud to uncover how they interpret and understand survey questions. Additionally, when designing questions, researchers should consider the mode for the survey and adjust the language appropriately. In self-administered surveys (e.g., web or mail), respondents can see all the questions and response options, but that is not the case in interviewer-administered surveys (e.g., CATI or CAPI). With interviewer-administered surveys, the response options must be read aloud to the respondents, so the question may need to be adjusted to create a better flow to the interview. Additionally, with self-administered surveys, because the respondents are viewing the questionnaire, the formatting of the questions is even more critical to ensure accurate measurement. Incorrect formatting or wording can result in measurement error, so following best practices or using existing validated questions can reduce error. There are multiple resources to help researchers draft questions for different modes (e.g., Dillman, Smyth, and Christian 2014; Fowler and Mangione 1989; Bradburn, Sudman, and Wansink 2004; Tourangeau, Couper, and Conrad 2004). Example: Number of Pets in a Household As part of our survey on the average number of pets in a household, researchers may want to know what animal most people prefer to have as a pet. Let’s say we have the following question in our survey: FIGURE 2.1: Example Question Asking Pet Preference Type This question may have validity issues as it only provides the options of “dogs” and “cats” to respondents, and the interpretation of the data could be incorrect. For example, if we had 100 respondents who answered the question and 50 selected dogs, then the results of this question cannot be “50% of the population prefers to have a dog as a pet,” as only two response options were provided. If a respondent taking our survey prefers turtles, they could either be forced to choose a response between these two (i.e., interpret the question as “between dogs and cats, which do you prefer?” and result in measurement error), or they may not answer the question (which results in item nonresponse error). Based on this, the interpretation of this question should be, “When given a choice between dogs and cats, 50% of respondents preferred to have a dog as a pet.” To avoid this issue, researchers should consider these possibilities and adjust the question accordingly. One simple way could be to add an “other” response option to give respondents a chance to provide a different response. The “other” response option could then include a way for respondents to write their other preference. For example, we could rewrite this question as: FIGURE 2.2: Example Question Asking Pet Preference Type with Other Specify Option Researchers can then code the responses from the open-ended box and get a better understanding of the respondent’s choice of preferred pet. Interpreting this question becomes easier as researchers no longer need to qualify the results with the choices provided. This is a simple example of how the presentation of the question and options can impact the findings. For more complex topics and questions, researchers must thoroughly consider how to mitigate any impacts from the presentation, formatting, wording, and other aspects. As survey analysts, reviewing not only the data but also the wording of the questions is crucial to ensure the results are presented in a manner consistent with the question asked. Chapter 4 provides further details on how to review existing survey documentation to inform our analyses. 2.4 Data Collection Once the data collection starts, researchers try to stick to the data collection protocol designed during pre-survey planning. However, effective researchers adjust their plans and adapt as needed to the current progress of data collection (Schouten, Peytchev, and Wagner 2018). Some extreme examples could be natural disasters that could prevent mail or interviewers from getting to the sample members. Others could be smaller in that something newsworthy occurs connected to the survey, so researchers could choose to play this up in communication materials. In addition to these external factors, there could be factors unique to the survey, such as lower response rates for a specific sub-group, so the data collection protocol may need to find ways to improve response rates for that specific group. 2.5 Post-Survey Processing After data collection, various activities need to be completed before we can analyze the survey. Multiple decisions made during this post-survey phase can assist researchers in reducing different error sources, such as through weighting to account for the sample selection. Knowing the decisions researchers made in creating the final analytic data can impact how analysts use the data and interpret the results. 2.5.1 Data Cleaning and Imputation Post-survey cleaning and imputation is one of the first steps researchers do to get the survey responses into a dataset for use by analysts. Data cleaning can consist of cleaning inconsistent data (e.g., with skip pattern errors or multiple questions throughout the survey being consistent with each other), editing numeric entries or open-ended responses for grammar and consistency, or recoding open-ended questions into categories for analysis. There is no universal set of fixed rules that every project must adhere to. Instead, each project or research study should establish its own guidelines and procedures for handling various cleaning scenarios based on its specific objectives. Researchers should use their best judgment to ensure data integrity, and all decisions should be documented and available to those using the data in the analysis. Each decision a researcher makes impacts processing error, so often, researchers have multiple people review these rules or recode open-ended data and adjudicate any differences in an attempt to reduce this error. Another crucial step in post-survey processing is imputation. Often, there is item nonresponse where respondents do not answer specific questions. If the questions are crucial to analysis efforts or the research question, researchers may implement imputation to reduce item nonresponse error. Imputation is a technique for replacing missing or incomplete data values with estimated values. However, as imputation is a way of assigning a value to missing data based on an algorithm or model, it can also introduce processing error, so researchers should consider the overall implications of imputing data compared to having item nonresponse. There are multiple ways to impute data. We recommend reviewing other resources like Kim and Shao (2021) for more information. Example: Number of Pets in a Household Let’s return to the question we created to ask about animal preference. The “other specify” invites respondents to specify the type of animal they prefer to have as a pet. If respondents entered answers such as “puppy,” “turtle,” “rabit,” “rabbit,” “bunny,” “ant farm,” “snake,” “Mr. Purr,” then researchers may wish to categorize these write-in responses to help with analysis. In this example, “puppy” could be assumed to be a reference to a “Dog”, and could be recoded there. The misspelling of “rabit” could be coded along with “rabbit” and “bunny” into a single category of “Bunny or Rabbit”. These are relatively standard decisions that a researcher could make. The remaining write-in responses could be categorized in a few different ways. “Mr. Purr,” which may be someone’s reference to their own cat, could be recoded as “Cat”, or it could remain as “Other” or some category that is “Unknown”. Depending on the number of responses related to each of the others, they could all be combined into a single “Other” category, or maybe categories such as “Reptiles” or “Insects” could be created. Each of these decisions may impact the interpretation of the data, so our researchers should document the types of responses that fall into each of the new categories and any decisions made. 2.5.2 Weighting We can address some of the error sources identified in the previous sections using weighting. For example, weights can address coverage, sampling, and nonresponse errors. Many published surveys include an “analysis weight” variable that combines these adjustments. However, weighting itself can also introduce adjustment error, so researchers need to balance which types of errors should be corrected with weighting. The construction of weights is outside the scope of this book, and researchers should reference other materials if interested in constructing their own (Valliant and Dever 2018). Instead, this book assumes the survey has been completed, weights are constructed, and data is available to users. We walk users through how to read the documentation (Chapter 4) and work with the data and analysis weights provided to analyze and interpret survey results correctly. Example: Number of Pets in a Household In the simple example of our survey, we decided to use a stratified sample by state to select our sample members. Knowing this sampling design, our researcher can include selection weights for analysis that account for how the sample members were selected for the survey. Additionally, the sampling frame may have the type of building associated with each address, so we could include the building type as a potential nonresponse weighting variable, along with some interviewer observations that may be related to our research topic of the average number of pets in a household. Combining these weights, we can create an analytic weight that researchers need to use when analyzing the data. 2.5.3 Disclosure Before data is released publicly, researchers need to ensure that individual respondents can not be identified by the data when confidentiality is required. There are a variety of different methods that can be used, including data swapping, top or bottom coding, coarsening, and perturbation. In data swapping, researchers may swap specific data values across different respondents so that it does not impact insights from the data but ensures that specific individuals cannot be identified. We can use top and bottom coding to mask extreme values. For example, researchers may top-code income values such that households with income greater than $500,000 are coded into a single category of “$500,000 or more”. Other disclosure methods may include aggregating response categories or location information to avoid having only a few respondents in a given group and thus be identified. For example, researchers may use coarsening to display income in categories instead of as a continuous variable. We can also perturb the data by adding random noise. There is as much art as there is science to the methods used for disclosure. In the survey documentation, researchers should only provide high-level comments about the disclosure and not specific details. This ensures nobody can reverse the disclosure and thus identify individuals. For more information on different disclosure methods, please see Skinner (2009) and AAPOR Standards. 2.5.4 Documentation Documentation is a critical step of the survey life cycle. Researchers systematically record all the details, decisions, procedures, and methodologies to ensure transparency, reproducibility, and the overall quality of survey research. Proper documentation allows analysts to understand, reproduce, and evaluate the study’s methods and findings. Chapter 4 dives into how analysts should use survey data documentation. 2.6 Post-survey data analysis and reporting After completing the survey life cycle, the data is ready for analysts to use. The rest of this book continues from this point. For more information on the survey life cycle, please explore the references cited throughout this chapter. References "],["c03-specifying-sample-designs.html", "Chapter 3 Specifying sample designs and replicate weights in {srvyr} 3.1 Introduction 3.2 Common sampling designs 3.3 Replicate weights 3.4 Understanding survey design documentation 3.5 Exercises", " Chapter 3 Specifying sample designs and replicate weights in {srvyr} Prerequisites For this chapter, here are the libraries and helper functions we will need: library(tidyverse) library(survey) library(srvyr) library(osfr) source(&quot;helper-fun/helper-functions.R&quot;) library(tidycensus) To help explain the different types of sample designs, this chapter will use the api and scd data that comes in the {survey} package: data(api) data(scd) Additionally, we have created multiple analytic datasets for use in this book on a directory on OSF6. To load any data used in the book that is not included in existing packages, we have created a helper function read_osf(). This chapter uses data from the Residential Energy Consumption Survey (RECS), so we will use the following code to load the RECS data to use later in this chapter: recs_in &lt;- read_osf(&quot;recs_2015.rds&quot;) 3.1 Introduction The primary reason for using packages like {survey} and {srvyr} is to incorporate the sampling design or replicate weights into estimates. By incorporating the sampling design or replicate weights, precision estimates (e.g., standard errors and confidence intervals) are appropriately calculated. In this chapter, we will introduce common sampling designs and common types of replicate weights, the mathematical methods for calculating estimates and standard errors for a given sampling design, and the R syntax to specify the sampling design or replicate weights. While we will show the math behind the estimates, the functions in these packages will do the calculation. To deeply understand the math and the derivation, refer to Penn State (2019), Särndal, Swensson, and Wretman (2003), Wolter (2007), or Fuller (2011). The general process for estimation in the {srvyr} package is to: Create a tbl_svy object (a survey object) using: as_survey_design() or as_survey_rep() Subset data (if needed) using filter() (subpopulations) Specify domains of analysis using group_by() Within summarize(), specify variables to calculate, including means, totals, proportions, quantiles, and more This chapter includes details on the first step - creating the survey object. The other steps are detailed in chapters 5 through 7. 3.2 Common sampling designs A sampling design is the method used to draw a sample. Both logistical and statistical elements are considered when developing a sampling design. When specifying a sampling design in R, the levels of sampling are specified along with the weights. The weight for each record is constructed so that the particular record represents that many units in the population. For example, in a survey of 6th-grade students in the United States, the weight associated with each responding student reflects how many students that record represents. Generally, the sum of the weights corresponds to the total population size, although some studies may have the sum of the weights equal to the number of respondent records. Some common terminology across the designs are: sample size, generally denoted as \\(n\\), is the number of units selected to be sampled population size, generally denoted as \\(N\\), is the number of units in the target population sampling frame, the list of units from which the sample is drawn 3.2.1 Simple random sample without replacement The simple random sample (SRS) without replacement is a sampling design where a fixed sample size is selected from a sampling frame, and every possible subsample has an equal probability of selection. Requirements: The sampling frame must include the entire population. Advantages: SRS requires no information about the units apart from contact information. Disadvantages: The sampling frame may not be available for the entire population. This design is not generally feasible for in-person data collection. Example: Randomly select students in a university from a roster provided by the registrar’s office. The math The estimate for the population mean of variable \\(y\\) is: \\[\\bar{y}=\\frac{1}{n}\\sum_{i=1}^n y_i\\] where \\(\\bar{y}\\) represents the sample mean, \\(n\\) is the total number of respondents (or observations), and \\(y_i\\) is each individual value of \\(y\\). The estimate of the standard error of the mean is: \\[se(\\bar{y})=\\sqrt{\\frac{s^2}{n}\\left( 1-\\frac{n}{N} \\right)}\\] where \\[s^2=\\frac{1}{n-1}\\sum_{i=1}^n\\left(y_i-\\bar{y}\\right)^2.\\] and \\(N\\) is the population size. This standard error estimate might look very similar to equations in other applications except for the part on the right side of the equation: \\(1-\\frac{n}{N}\\). This is called the finite population correction (FPC) factor, and if the size of the frame, \\(N\\), is very large, the FPC is negligible, so it is often ignored. To estimate proportions, we define \\(x_i\\) as the indicator if the outcome is observed. That is, \\(x_i=1\\) if the outcome is observed, and \\(x_i=0\\) if the outcome is not observed for respondent \\(i\\). Then the estimated proportion from an SRS design is: \\[\\hat{p}=\\frac{1}{n}\\sum_{i=1}^n x_i \\] and the estimated standard error of the proportion is: \\[se(\\hat{p})=\\sqrt{\\frac{\\hat{p}(1-\\hat{p})}{n-1}\\left(1-\\frac{n}{N}\\right)} \\] The syntax If a sample was drawn through SRS and had no nonresponse or other weighting adjustments, in R, specify this design as: srs1_des &lt;- dat %&gt;% as_survey_design(fpc = fpcvar) where dat is a tibble or data.frame with the survey data, and fpcvar is a variable on the tibble indicating the sampling frame’s size. If the frame is very large, sometimes the frame size is not provided. In that case, the FPC is not needed, and specify the design as: srs2_des &lt;- dat %&gt;% as_survey_design() If some post-survey adjustments were implemented and the weights are not all equal, specify the design as: srs3_des &lt;- dat %&gt;% as_survey_design(weights = wtvar, fpc = fpcvar) where wtvar is the variable for the weight on the data. Again, the FPC can be omitted if it is unnecessary because the frame is large. Example The {survey} package in R provides some example datasets that we will use throughout this chapter. The documentation provides detailed information about the variables. One of the example datasets we will use is from the Academic Performance Index (API). The API was a program administered by the California Department of Education, and the {survey} package includes a population file (sample frame) of all schools with at least 100 students and several different samples pulled from that data using different sampling methods. For this first example, we will use the apisrs dataset, which contains an SRS of 200 schools. For printing purposes, we create a new dataset called apisrs_slim, which sorts the data by the school district and school ID and subsets the data to only a few columns. The SRS sample data is illustrated below: apisrs_slim &lt;- apisrs %&gt;% as_tibble() %&gt;% arrange(dnum, snum) %&gt;% select(cds, dnum, snum, dname, sname, fpc, pw) apisrs_slim ## # A tibble: 200 × 7 ## cds dnum snum dname sname fpc pw ## &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 19642126061220 1 1121 ABC Unified Haske… 6194 31.0 ## 2 19642126066716 1 1124 ABC Unified Stowe… 6194 31.0 ## 3 36675876035174 5 3895 Adelanto Elementary Adela… 6194 31.0 ## 4 33669776031512 19 3347 Alvord Unified Arlan… 6194 31.0 ## 5 33669776031595 19 3352 Alvord Unified Wells… 6194 31.0 ## 6 31667876031033 39 3271 Auburn Union Elementary Cain … 6194 31.0 ## 7 19642876011407 42 1169 Baldwin Park Unified Deanz… 6194 31.0 ## 8 19642876011464 42 1175 Baldwin Park Unified Heath… 6194 31.0 ## 9 19642956011589 48 1187 Bassett Unified Erwin… 6194 31.0 ## 10 41688586043392 49 4948 Bayshore Elementary Baysh… 6194 31.0 ## # ℹ 190 more rows Table 3.1 provides details on all the variables in this dataset. TABLE 3.1: Overview of Variables in api Data Variable Name Description cds Unique identifier for each school dnum School district identifier within county snum School identifier within district dname District Name sname School Name fpc Finite population correction factor (FPC) pw Weight To create the tbl_survey object for this SRS data, the design should be specified as follows: apisrs_des &lt;- apisrs_slim %&gt;% as_survey_design(weights = pw, fpc = fpc) apisrs_des ## Independent Sampling design ## Called via srvyr ## Sampling variables: ## - ids: `1` ## - fpc: fpc ## - weights: pw ## Data variables: cds (chr), dnum (int), snum (dbl), dname (chr), sname ## (chr), fpc (dbl), pw (dbl) In the printed design object above, the design is described as an “Independent Sampling design,” which is another term for SRS. The ids are specified as 1, which means there is no clustering (a topic described in Section 3.2.4), the FPC variable is indicated, and the weights are indicated. We can also look at the summary of the design object, and see the distribution of the probabilities (inverse of the weights) along with the population size and a list of the variables in the dataset. summary(apisrs_des) ## Independent Sampling design ## Called via srvyr ## Probabilities: ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 0.0323 0.0323 0.0323 0.0323 0.0323 0.0323 ## Population size (PSUs): 6194 ## Data variables: ## [1] &quot;cds&quot; &quot;dnum&quot; &quot;snum&quot; &quot;dname&quot; &quot;sname&quot; &quot;fpc&quot; &quot;pw&quot; 3.2.2 Simple random sample with replacement Similar to the SRS design, the simple random sample with replacement (SRSWR) design randomly selects the sample from the entire sampling frame. However, while SRS removes sampled units before selecting again, the SRSWR instead replaces each sampled unit before drawing again, so units can be selected more than once. Requirements: The sampling frame must include the entire population. Advantages: SRSWR requires no information about the units apart from contact information. Disadvantages: The sampling frame may not be available for the entire population. This design is not generally feasible for in-person data collection. Units can be selected more than once, resulting in a smaller realized sample size because receiving duplicate information from a single respondent does not provide additional information. For small populations, SRSWR has larger standard errors than SRS designs. Example: A professor puts all students’ names on paper slips and selects them randomly to ask students questions, but the professor replaces the paper after calling on the student so they can be selected again at any time. The math The estimate for the population mean of variable \\(y\\) is: \\[\\bar{y}=\\frac{1}{n}\\sum_{i=1}^n y_i\\] and the estimate of the standard error of mean is: \\[se(\\bar{y})=\\sqrt{\\frac{s^2}{n}}\\] where \\[s^2=\\frac{1}{n-1}\\sum_{i=1}^n\\left(y_i-\\bar{y}\\right)^2.\\] To calculate the estimated proportion, we define \\(x_i\\) as the indicator that the outcome is observed (as we did with SRS): \\[\\hat{p}=\\frac{1}{n}\\sum_{i=1}^n x_i \\] and the estimated standard error of the proportion is: \\[se(\\hat{p})=\\sqrt{\\frac{\\hat{p}(1-\\hat{p})}{n}} \\] The syntax If we had a sample that was drawn through SRSWR and had no nonresponse or other weighting adjustments, in R, we should specify this design as: srswr1_des &lt;- dat %&gt;% as_survey_design() where dat is a tibble or data.frame containing our survey data. This syntax is the same as a SRS design without an FPC. Therefore, with large enough samples that do not have an FPC, the underlying formulas for SRS and SRSWR designs are the same. If some post-survey adjustments were implemented and the weights are not all equal, specify the design as: srswr2_des &lt;- dat %&gt;% as_survey_design(weights = wtvar) where wtvar is the variable for the weight on the data. Example The {survey} package does not include an example of SRSWR, so to illustrate this design we create an example from the population data provided. We call this new dataset apisrswr. set.seed(409963) apisrswr &lt;- apipop %&gt;% as_tibble() %&gt;% slice_sample(n = 200, replace = TRUE) %&gt;% select(cds, dnum, snum, dname, sname) %&gt;% mutate( weight = nrow(apipop)/200 ) head(apisrswr) ## # A tibble: 6 × 6 ## cds dnum snum dname sname weight ## &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 43696416060065 533 5348 Palo Alto Unified Jordan (Da… 31.0 ## 2 07618046005060 650 509 San Ramon Valley Unified Alamo Elem… 31.0 ## 3 19648086085674 457 2134 Montebello Unified La Merced … 31.0 ## 4 07617056003719 346 377 Knightsen Elementary Knightsen … 31.0 ## 5 19650606023022 744 2351 Torrance Unified Carr (Evel… 31.0 ## 6 01611196090120 6 13 Alameda City Unified Paden (Wil… 31.0 Because this is a SRS design with replacement, there will be duplicates in the data. It is important to keep the duplicates in the data for proper estimation, but for reference we can view the duplicates in the example data we just created. apisrswr %&gt;% group_by(cds) %&gt;% filter(n()&gt;1) %&gt;% arrange(cds) ## # A tibble: 4 × 6 ## # Groups: cds [2] ## cds dnum snum dname sname weight ## &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 15633216008841 41 869 Bakersfield City Elem Chipman Junio… 31.0 ## 2 15633216008841 41 869 Bakersfield City Elem Chipman Junio… 31.0 ## 3 39686766042782 716 4880 Stockton City Unified Tyler Skills … 31.0 ## 4 39686766042782 716 4880 Stockton City Unified Tyler Skills … 31.0 We created a weight variable in this example data, which is the inverse of the probability of selection. To specify the sampling design for apisrswr, the following syntax should be used: apisrswr_des &lt;- apisrswr %&gt;% as_survey_design(weights = weight) apisrswr_des ## Independent Sampling design (with replacement) ## Called via srvyr ## Sampling variables: ## - ids: `1` ## - weights: weight ## Data variables: cds (chr), dnum (int), snum (dbl), dname (chr), sname ## (chr), weight (dbl) summary(apisrswr_des) ## Independent Sampling design (with replacement) ## Called via srvyr ## Probabilities: ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 0.0323 0.0323 0.0323 0.0323 0.0323 0.0323 ## Data variables: ## [1] &quot;cds&quot; &quot;dnum&quot; &quot;snum&quot; &quot;dname&quot; &quot;sname&quot; &quot;weight&quot; In the output above, the design object and the object summary are shown. Both note that the sampling is done “with replacement” because no FPC was specified. The probabilities, which are derived from the weights, are summarized in the summary. 3.2.3 Stratified sampling Stratified sampling occurs when a population is divided into mutually exclusive subpopulations (strata), and then samples are selected independently within each stratum. Requirements: The sampling frame must include the information to divide the population into groups for every unit. Advantages: This design ensures sample representation in all subpopulations. If the strata are correlated with survey outcomes, a stratified sample has smaller standard errors compared to a SRS sample of the same size. Thus is a more efficient design. Disadvantages: Auxiliary data may not exist to divide the sampling frame into groups, or the data may be outdated. Examples: Example 1: A population of North Carolina residents could be separated into urban and rural areas, and then a SRS of residents from both rural and urban areas is selected independently. This ensures there are residents from both areas in the sample. Example 2: There are three primary general-purpose law enforcement agencies in the US: local police, sheriff’s departments, and state police. In a survey of law enforcement agencies, the agency type could be used to form strata. The math Let \\(\\bar{y}_h\\) be the sample mean for stratum \\(h\\), \\(N_h\\) be the population size of stratum \\(h\\), and \\(n_h\\) be the sample size of stratum \\(h\\). Then the estimate for the population mean under stratified SRS sampling is: \\[\\bar{y}=\\frac{1}{N}\\sum_{h=1}^H N_h\\bar{y}_h\\] and the estimate of the standard error of \\(\\bar{y}\\) is: \\[se(\\bar{y})=\\sqrt{\\frac{1}{N^2} \\sum_{h=1}^H N_h^2 \\frac{s_h^2}{n_h}\\left(1-\\frac{n_h}{N_h}\\right)} \\] where \\[s_h^2=\\frac{1}{n_h-1}\\sum_{i=1}^{n_h}\\left(y_{i,h}-\\bar{y}_h\\right)^2.\\] For estimates of proportions, let \\(\\hat{p}_h\\) be the estimated proportion in stratum \\(h\\). Then the population proportion estimate is: \\[\\hat{p}= \\frac{1}{N}\\sum_{h=1}^H N_h \\hat{p}_h\\] where \\(H\\) is the total number of strata. The standard error of the proportion is: \\[se(\\hat{p}) = \\frac{1}{N} \\sqrt{ \\sum_{h=1}^H N_h^2 \\frac{\\hat{p}_h(1-\\hat{p}_h)}{n_h-1} \\left(1-\\frac{n_h}{N_h}\\right)}\\] The syntax To specify a stratified SRS design in {srvyr} when using the FPC, that is, where the population sizes of the strata are not too large and are known, specify the design as: stsrs1_des &lt;- dat %&gt;% as_survey_design(fpc = fpcvar, strata = stratvar) where fpcvar is a variable on our data that indicates \\(N_h\\) for each row, and stratavar is a variable indicating the stratum for each row. You can omit the FPC if it is not applicable. Additionally, we can indicate the weight variable if it is present where wtvar is a variable on our data with a numeric weight. stsrs2_des &lt;- dat %&gt;% as_survey_design(weights = wtvar, strata = stratvar) Example In the example API data, apistrat is a stratified random sample, stratified by school type (stype). As with the SRS example above, we sort and select specific variables for use in printing. The data are illustrated below, including a count of the number of cases per stratum: apistrat_slim &lt;- apistrat %&gt;% as_tibble() %&gt;% arrange(dnum, snum) %&gt;% select(cds, dnum, snum, dname, sname, stype, fpc, pw) apistrat_slim %&gt;% count(stype, fpc) ## # A tibble: 3 × 3 ## stype fpc n ## &lt;fct&gt; &lt;dbl&gt; &lt;int&gt; ## 1 E 4421 100 ## 2 H 755 50 ## 3 M 1018 50 The FPC is the same within each stratum, and 100 elementary schools were sampled, while 50 schools were sampled from both the middle and high school levels. This design should be specified as follows: apistrat_des &lt;- apistrat_slim %&gt;% as_survey_design(strata = stype, weights = pw, fpc = fpc) apistrat_des ## Stratified Independent Sampling design ## Called via srvyr ## Sampling variables: ## - ids: `1` ## - strata: stype ## - fpc: fpc ## - weights: pw ## Data variables: cds (chr), dnum (int), snum (dbl), dname (chr), sname ## (chr), stype (fct), fpc (dbl), pw (dbl) summary(apistrat_des) ## Stratified Independent Sampling design ## Called via srvyr ## Probabilities: ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 0.0226 0.0226 0.0359 0.0401 0.0534 0.0662 ## Stratum Sizes: ## E H M ## obs 100 50 50 ## design.PSU 100 50 50 ## actual.PSU 100 50 50 ## Population stratum sizes (PSUs): ## E H M ## 4421 755 1018 ## Data variables: ## [1] &quot;cds&quot; &quot;dnum&quot; &quot;snum&quot; &quot;dname&quot; &quot;sname&quot; &quot;stype&quot; &quot;fpc&quot; &quot;pw&quot; When printing the object, it is specified as a “Stratified Independent Sampling design,” also known as a stratified SRS, and the strata variable is included. Printing the summary we see a distribution of probabilities, as we saw with SRS, but we also see the sample and populations sizes by stratum. 3.2.4 Clustered sampling Clustered sampling occurs when a population is divided into mutually exclusive subgroups called clusters or primary sampling units (PSUs). A random selection of PSUs is sampled, and then another level of sampling is done within these clusters. There can be multiple levels of this selection. Clustered sampling is often used when a list of the entire population is not available, or data collection involves interviewers needing direct contact with respondents. Requirements: There must be a way to divide the population into clusters. Clusters are commonly structural such as institutions (e.g., schools, prisons) or geography (e.g., states, counties). Advantages: Clustered sampling is advantageous when data collection is done in person, so interviewers are sent to specific sampled areas rather than completely at random across a country. With cluster sampling, a list of the entire population is not necessary. For example, if sampling students, we do not need a list of all students but only a list of all schools. Once the schools are sampled, lists of students can be obtained within the sampled schools. Disadvantages: Compared to a simple random sample for the same sample size, clustered samples generally have larger standard errors of estimates. Examples: Example 1: Consider a study needing a sample of 6th-grade students in the United States, no list likely exists of all these students. However, it is more likely to obtain a list of schools that have 6th graders, so a study design could select a random sample of schools that have 6th graders. The selected schools can then provide a list of students to do a second stage of sampling where 6th-grade students are randomly sampled within each of the sampled schools. This is a one-stage sample design and will be the type of design we will discuss in the formulas below. Example 2: Consider a study sending interviewers to households for a survey. This is a more complicated example that requires two levels of selection to efficiently use interviewers in geographic clusters. First, in the U.S., counties could be selected as the PSU, then Census block groups within counties could be selected as the secondary sampling unit (SSU). Households could then be randomly sampled within the block groups. This type of design is popular for in-person surveys as it reduces the travel necessary for interviewers. The math Consider a survey where a sample of \\(a\\) clusters are sampled from a population of \\(A\\) clusters via SRS. Units within each sampled cluster are sampled via SRS as well. Within each sampled cluster, \\(i\\), there are \\(B_i\\) units and \\(b_i\\) units are sampled via SRS. Let \\(\\bar{y}_{i}\\) be the sample mean of cluster \\(i\\). Then, a ratio estimator of the population mean is: \\[\\bar{y}=\\frac{\\sum_{i=1}^a B_i \\bar{y}_{i}}{ \\sum_{i=1}^a B_i}\\] Note this is a consistent but biased estimator. Often the population size is not known, so this is a method to estimate a mean without knowing the population size. The estimated standard error of the mean is: \\[se(\\bar{y})= \\frac{1}{\\hat{N}}\\sqrt{\\left(1-\\frac{a}{A}\\right)\\frac{s_a^2}{a} + \\frac{A}{a} \\sum_{i=1}^a \\left(1-\\frac{b_i}{B_i}\\right) \\frac{s_i^2}{b_i} }\\] where \\(s_a^2\\) is the between-cluster variance: \\[s_a^2=\\frac{1}{a-1}\\sum_{i=1}^a \\left( \\hat{y}_i - \\frac{\\sum_{i=1}^a \\hat{y}_{i} }{a}\\right)^2\\] and \\(s_i^2\\) is the within-cluster variance: \\[s_b^2=\\frac{1}{a(b_i-1)} \\sum_{j=1}^{b_i} \\left(y_{ij}-\\bar{y}_i\\right)^2\\] and \\(\\hat{y}_i =B_i\\bar{y_i}\\) and \\(\\hat{N}\\) is the estimated population size. The syntax To specify a two-stage clustered design without replacement, use the following syntax: clus2_des &lt;- dat %&gt;% as_survey_design(weights = wtvar, ids = c(PSU, SSU), fpc = c(A, B)) where PSU and SSU are the variables indicating the PSU and SSU identifiers, and A and B are the variables indicating the population sizes for each level (i.e., A is the number of clusters, and B is the number of units within each cluster). Note that A will be the same for all records (within a strata), and B will be the same for all records within the same cluster. If clusters were sampled with replacement or from a very large population, a FPC is unnecessary. Additionally, only the first stage of selection is necessary regardless of whether the units were selected with replacement at any stage. The subsequent stages of selection are ignored in computation as their contribution to the variance is overpowered by the first stage (see Särndal, Swensson, and Wretman (2003) or Wolter (2007) for a more in-depth discussion). Therefore, the syntax below will yield the same estimates in the end: clus2wra_des &lt;- dat %&gt;% as_survey_design(weights = wtvar, ids = c(PSU, SSU)) clus2wrb_des &lt;- dat %&gt;% as_survey_design(weights = wtvar, ids = PSU) Example The survey package includes a two-stage cluster sample data, apiclus2, in which school districts were sampled, and then a random sample of five schools was selected within each district. For districts with fewer than five schools, all schools were sampled. School districts are identified by dnum, and schools are identified by snum. The variable fpc1 indicates how many districts there are in California (A), and fpc2 indicates how many schools were in a given district with at least 100 students (B). The data has a row for each school. In the data printed below, there are 757 school districts, as indicated by fpc1, and there are nine schools in District 731, one school in District 742, two schools in District 768, and so on as indicated by fpc2. For illustration purposes, the object apiclus2_slim has been created from apiclus2, which subsets the data to only the necessary columns and sorts data. apiclus2_slim &lt;- apiclus2 %&gt;% as_tibble() %&gt;% arrange(desc(dnum), snum) %&gt;% select(cds, dnum, snum, fpc1, fpc2, pw) apiclus2_slim ## # A tibble: 126 × 6 ## cds dnum snum fpc1 fpc2 pw ## &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int[1d]&gt; &lt;dbl&gt; ## 1 47704826050942 795 5552 757 1 18.9 ## 2 07618126005169 781 530 757 6 22.7 ## 3 07618126005177 781 531 757 6 22.7 ## 4 07618126005185 781 532 757 6 22.7 ## 5 07618126005193 781 533 757 6 22.7 ## 6 07618126005243 781 535 757 6 22.7 ## 7 19650786023337 768 2371 757 2 18.9 ## 8 19650786023345 768 2372 757 2 18.9 ## 9 54722076054423 742 5898 757 1 18.9 ## 10 50712906053086 731 5781 757 9 34.1 ## # ℹ 116 more rows To specify this design in R, the following syntax should be used: apiclus2_des &lt;- apiclus2_slim %&gt;% as_survey_design(ids = c(dnum, snum), fpc = c(fpc1, fpc2), weights = pw) apiclus2_des ## 2 - level Cluster Sampling design ## With (40, 126) clusters. ## Called via srvyr ## Sampling variables: ## - ids: `dnum + snum` ## - fpc: `fpc1 + fpc2` ## - weights: pw ## Data variables: cds (chr), dnum (int), snum (dbl), fpc1 (dbl), fpc2 ## (int[1d]), pw (dbl) summary(apiclus2_des) ## 2 - level Cluster Sampling design ## With (40, 126) clusters. ## Called via srvyr ## Probabilities: ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 0.00367 0.03774 0.05284 0.04239 0.05284 0.05284 ## Population size (PSUs): 757 ## Data variables: ## [1] &quot;cds&quot; &quot;dnum&quot; &quot;snum&quot; &quot;fpc1&quot; &quot;fpc2&quot; &quot;pw&quot; The design objects are described as “2 - level Cluster Sampling design” and include the ids (cluster), FPC, and weight variables. The summary notes that the sample includes 40 first-level clusters (PSUs), which are school districts, and 126 second-level clusters (SSUs), which are schools. Additionally, the summary includes a numeric summary of the probabilities and the population size (number of PSUs) as 757. 3.3 Replicate weights Replicate weights are often included on analysis files instead of, or in addition to, the design variables (strata and PSUs). Replicate weights are used as another method to estimate variability and are often used specifically so that design variables are not published as a measure to limit disclosure risk. There are several types of replicate weights, including balanced repeated replication (BRR), Fay’s BRR, jackknife, and bootstrap methods. An overview of the process for using replicate weights is as follows: Divide the sample into subsample replicates that mirror the design of the sample Calculate weights for each replicate using the same procedures for the full-sample weight (i.e., nonresponse and post-stratification) Calculate estimates for each replicate using the same method as the full-sample estimate Calculate the estimated variance, which will be proportional to the variance of the replicate estimates The different types of replicate weights largely differ in step 1 - how the sample is divided into subsamples, and step 4 - which multiplication factors (scales) are used to multiply the variance. The general format for the standard error is: \\[ \\sqrt{\\alpha \\sum_{r=1}^R \\alpha_r (\\hat{\\theta}_r - \\hat{\\theta})^2 }\\] where \\(R\\) is the number of replicates, \\(\\alpha\\) is a constant that depends on the replication method, \\(\\alpha_r\\) is a factor associated with each replicate, \\(\\hat{\\theta}\\) is the weighted estimate based on the full sample, and \\(\\hat{\\theta}_r\\) is the weighted estimate of \\(\\theta\\) based on the \\(r^{\\text{th}}\\) replicate. 3.3.1 Balanced Repeated Replication (BRR) Method The BRR method requires a stratified sample design with two PSUs in each stratum. Each replicate is constructed by deleting one PSU per stratum using a Hadamard matrix. For the PSU that is included, the weight is generally multiplied by two but may have other adjustments, such as post-stratification. A Hadamard matrix is a special square matrix with entries of +1 or -1 with mutually orthogonal rows. Hadamard matrices must have one row, two rows, or a multiple of four rows. The size of the Hadamard matrix is determined by the first multiple of 4 greater than or equal to the number of strata. For example, if a survey had 7 strata, the Hadamard matrix would be an \\(8\\times8\\) matrix. Additionally, a survey with 8 strata would also have an \\(8\\times8\\) Hadamard matrix. An example of a \\(4\\times4\\) Hadamard matrix is below: \\[ \\begin{array}{rrrr} +1 &amp;+1 &amp;+1 &amp;+1\\\\ +1&amp;-1&amp;+1&amp;-1\\\\ +1&amp;+1&amp;-1&amp;-1\\\\ +1 &amp;-1&amp;-1&amp;+1 \\end{array} \\] The columns specify the strata and the rows the replicate. In the first replicate, all the values are +1, so in each stratum, the first PSU would be used in the estimate. In the second replicate, the first PSU would be used in stratum 1 and 3, while the second PSU would be used in stratum 2 and 4. In the third replicate, the first PSU would be used in stratum 1 and 2, while the second PSU would be used in strata 3 and 4. Finally, in the fourth replicate, the first PSU would be used in strata 1 and 4, while the second PSU would be used in strata 2 and 3. The math A weighted estimate for the full sample is calculated as \\(\\hat{\\theta}\\), and then a weighted estimate for each replicate is calculated as \\(\\hat{\\theta}_r\\) for \\(R\\) replicates. Using the generic notation above, \\(\\alpha=\\frac{1}{R}\\) and \\(\\alpha_r=1\\) for each \\(r\\). The standard error of the estimate is calculated as follows: \\[se(\\hat{\\theta})=\\sqrt{\\frac{1}{R} \\sum_{r=1}^R \\left( \\hat{\\theta}_r-\\hat{\\theta}\\right)^2}\\] Specifying replicate weights in R requires specifying the type of replicate weights, the main weight variable, the replicate weight variables, and other options. One of the key options is for mse. If mse=TRUE, variances are computed around the point estimate \\((\\hat{\\theta})\\), whereas if mse=FALSE, variances are computed around the mean of the replicates \\((\\bar{\\theta})\\) instead which looks like this: \\[se(\\hat{\\theta})=\\sqrt{\\frac{1}{R} \\sum_{r=1}^R \\left( \\hat{\\theta}_r-\\bar{\\theta}\\right)^2}\\] where \\[\\bar{\\theta}=\\frac{1}{R}\\sum_{r=1}^R \\hat{\\theta}_r\\] The default option for mse is to use the global option of “survey.replicates.mse” which is set to FALSE initially unless a user changes it. To determine if mse should be set to TRUE or FALSE, read the survey documentation. If there is no indication in the survey documentation, for BRR, set mse to TRUE. The syntax Replicate weights generally come in groups and are sequentially numbered, such as PWGTP1, PWGTP2, …, PWGTP80 for the person weights in the American Community Survey (ACS) (U.S. Census Bureau 2021) or BRRWT1, BRRWT2, …, BRRWT96 in the 2015 Residential Energy Consumption Survey (RECS) (U.S. Energy Information Administration 2017). This makes it easy to use some of the tidy selection7 functions in R. For example, if a dataset had WT0 for the main weight and had 20 BRR weights indicated WT1, WT2, …, WT20, we can use the following syntax (both are equivalent): brr_des &lt;- dat %&gt;% as_survey_rep(weights = WT0, repweights = all_of(str_c(&quot;WT&quot;, 1:20)), type = &quot;BRR&quot;, mse = TRUE) brr_des &lt;- dat %&gt;% as_survey_rep(weights = WT0, repweights = num_range(&quot;WT&quot;, 1:20), type = &quot;BRR&quot;, mse = TRUE) If a dataset had WT for the main weight and had 20 BRR weights indicated REPWT1, REPWT2, …, REPWT20, the following syntax could be used (both are equivalent): brr_des &lt;- dat %&gt;% as_survey_rep(weights = WT, repweights = all_of(str_c(&quot;REPWT&quot;, 1:20)), type = &quot;BRR&quot;, mse = TRUE) brr_des &lt;- dat %&gt;% as_survey_rep(weights = WT, repweights = starts_with(&quot;REPWT&quot;), type = &quot;BRR&quot;, mse = TRUE) If the replicate weight variables are in the file consecutively, the following syntax can also be used: brr_des &lt;- dat %&gt;% as_survey_rep(weights = WT, repweights = REPWT1:REPWT20, type = &quot;BRR&quot;, mse = TRUE) Typically, the replicate weights sum to a value similar to the main weight, as they are both supposed to provide population estimates. Rarely, an alternative method will be used where the replicate weights have values of 0 or 2 in the case of BRR weights. This would be indicated in the documentation (see Section 3.4 and Chapter 4 for more information on how to understand the provided documentation). In this case, the replicate weights are not combined, and the option combined_weights = FALSE should be indicated, as the default value for this argument is TRUE. This specific syntax is shown below: brr_des &lt;- dat %&gt;% as_survey_rep(weights = WT, repweights = starts_with(&quot;REPWT&quot;), type = &quot;BRR&quot;, combined_weights = FALSE, mse = TRUE) Example The {survey} package includes a data example from Section 12.2 of Levy and Lemeshow (2013). In this fictional data, two out of five ambulance stations were sampled from each of three emergency service areas (ESAs), thus BRR weights are appropriate with 2 PSUs (stations) sampled in each stratum (ESA). In the code below, BRR weights are created as was done by Levy and Lemeshow (2013). scdbrr &lt;- scd %&gt;% as_tibble() %&gt;% mutate(wt = 5 / 2, rep1 = 2 * c(1, 0, 1, 0, 1, 0), rep2 = 2 * c(1, 0, 0, 1, 0, 1), rep3 = 2 * c(0, 1, 1, 0, 0, 1), rep4 = 2 * c(0, 1, 0, 1, 1, 0)) scdbrr ## # A tibble: 6 × 9 ## ESA ambulance arrests alive wt rep1 rep2 rep3 rep4 ## &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 1 120 25 2.5 2 2 0 0 ## 2 1 2 78 24 2.5 0 0 2 2 ## 3 2 1 185 30 2.5 2 0 2 0 ## 4 2 2 228 49 2.5 0 2 0 2 ## 5 3 1 670 80 2.5 2 0 0 2 ## 6 3 2 530 70 2.5 0 2 2 0 To specify the BRR weights, the following syntax is used: scdbrr_des &lt;- scdbrr %&gt;% as_survey_rep(type = &quot;BRR&quot;, repweights = starts_with(&quot;rep&quot;), combined_weights = FALSE, weight = wt) scdbrr_des ## Call: Called via srvyr ## Balanced Repeated Replicates with 4 replicates. ## Sampling variables: ## - repweights: `rep1 + rep2 + rep3 + rep4` ## - weights: wt ## Data variables: ESA (int), ambulance (int), arrests (dbl), alive (dbl), ## wt (dbl), rep1 (dbl), rep2 (dbl), rep3 (dbl), rep4 (dbl) summary(scdbrr_des) ## Call: Called via srvyr ## Balanced Repeated Replicates with 4 replicates. ## Sampling variables: ## - repweights: `rep1 + rep2 + rep3 + rep4` ## - weights: wt ## Data variables: ESA (int), ambulance (int), arrests (dbl), alive (dbl), ## wt (dbl), rep1 (dbl), rep2 (dbl), rep3 (dbl), rep4 (dbl) ## Variables: ## [1] &quot;ESA&quot; &quot;ambulance&quot; &quot;arrests&quot; &quot;alive&quot; &quot;wt&quot; ## [6] &quot;rep1&quot; &quot;rep2&quot; &quot;rep3&quot; &quot;rep4&quot; Note that combined_weights was specified as FALSE because these weights are simply specified as 0 and 2 and do not incorporate the overall weight. When printing the object, the type of replication is noted as Balanced Repeated Replicates, and the replicate weights and the weight variable are specified. Additionally, the summary lists the variables included. 3.3.2 Fay’s BRR Method Fay’s BRR method for replicate weights is similar to the BRR method in that it uses a Hadamard matrix to construct replicate weights. However, rather than deleting PSUs for each replicate, with Fay’s BRR half of the PSUs have a replicate weight which is the main weight multiplied by \\(\\rho\\), and the other half have the main weight multiplied by \\((2-\\rho)\\) where \\(0 \\le \\rho &lt; 1\\). Note that when \\(\\rho=0\\), this is equivalent to the standard BRR weights, and as \\(\\rho\\) becomes closer to 1, this method is more similar to jackknife discussed in the next section. To obtain the value of \\(\\rho\\), it is necessary to read the documentation (see Section 3.4 and Chapter 4). The math The standard error estimate for \\(\\hat{\\theta}\\) is slightly different than the BRR, due to the addition of the multiplier of \\(\\rho\\). Using the generic notation above, \\(\\alpha=\\frac{1}{R \\left(1-\\rho\\right)^2}\\) and \\(\\alpha_r=1 \\forall r\\). The standard error is calculated as: \\[se(\\hat{\\theta})=\\sqrt{\\frac{1}{R (1-\\rho)^2} \\sum_{r=1}^R \\left( \\hat{\\theta}_r-\\hat{\\theta}\\right)^2}\\] The syntax The syntax is very similar for BRR and Fay’s BRR. If a dataset had WT0 for the main weight and had 20 BRR weights indicated as WT1, WT2, …, WT20, and Fay’s multiplier is 0.5, use the following syntax: fay_des &lt;- dat %&gt;% as_survey_rep(weights = WT0, repweights = num_range(&quot;WT&quot;, 1:20), type = &quot;Fay&quot;, mse = TRUE, rho = 0.5) Example The 2015 RECS (U.S. Energy Information Administration 2017) uses Fay’s BRR weights with the final weight as NWEIGHT and replicate weights as BRRWT1 - BRRWT96 with \\(\\rho=0.5\\). On the file, DOEID is a unique identifier for each respondent, TOTALDOL is the total cost of energy, TOTSQFT_EN is the total square footage of the residence, and REGOINC is the Census region. We have already read in the RECS data and created a dataset called recs_in above in the prerequisites. To specify this design, use the following syntax: recs_des &lt;- recs_in %&gt;% as_survey_rep(weights = NWEIGHT, repweights = BRRWT1:BRRWT96, type = &quot;Fay&quot;, rho = 0.5, mse = TRUE, variables = c(DOEID, TOTALDOL, TOTSQFT_EN, REGIONC)) recs_des ## Call: Called via srvyr ## Fay&#39;s variance method (rho= 0.5 ) with 96 replicates and MSE variances. ## Sampling variables: ## - repweights: `BRRWT1 + BRRWT2 + BRRWT3 + BRRWT4 + BRRWT5 + BRRWT6 + BRRWT7 + BRRWT8 + BRRWT9 + BRRWT10 + BRRWT11 + BRRWT12 + BRRWT13 + BRRWT14 + BRRWT15 + BRRWT16 + BRRWT17 + BRRWT18 + BRRWT19 + BRRWT20 + BRRWT21 + BRRWT22 + BRRWT23 + BRRWT24 + BRRWT25 + BRRWT26 + BRRWT27 + BRRWT28 + BRRWT29 + BRRWT30 + BRRWT31 + BRRWT32 + BRRWT33 + BRRWT34 + BRRWT35 + BRRWT36 + BRRWT37 + BRRWT38 + BRRWT39 + BRRWT40 + BRRWT41 + BRRWT42 + BRRWT43 + BRRWT44 + BRRWT45 + BRRWT46 + BRRWT47 + BRRWT48 + BRRWT49 + BRRWT50 + BRRWT51 + \\n BRRWT52 + BRRWT53 + BRRWT54 + BRRWT55 + BRRWT56 + BRRWT57 + BRRWT58 + BRRWT59 + BRRWT60 + BRRWT61 + BRRWT62 + BRRWT63 + BRRWT64 + BRRWT65 + BRRWT66 + BRRWT67 + BRRWT68 + BRRWT69 + BRRWT70 + BRRWT71 + BRRWT72 + BRRWT73 + BRRWT74 + BRRWT75 + BRRWT76 + BRRWT77 + BRRWT78 + BRRWT79 + BRRWT80 + BRRWT81 + BRRWT82 + BRRWT83 + BRRWT84 + BRRWT85 + BRRWT86 + BRRWT87 + BRRWT88 + BRRWT89 + BRRWT90 + BRRWT91 + BRRWT92 + BRRWT93 + BRRWT94 + BRRWT95 + BRRWT96` ## - weights: NWEIGHT ## Data variables: DOEID (dbl), TOTALDOL (dbl), TOTSQFT_EN (dbl), REGIONC ## (dbl) summary(recs_des) ## Call: Called via srvyr ## Fay&#39;s variance method (rho= 0.5 ) with 96 replicates and MSE variances. ## Sampling variables: ## - repweights: `BRRWT1 + BRRWT2 + BRRWT3 + BRRWT4 + BRRWT5 + BRRWT6 + BRRWT7 + BRRWT8 + BRRWT9 + BRRWT10 + BRRWT11 + BRRWT12 + BRRWT13 + BRRWT14 + BRRWT15 + BRRWT16 + BRRWT17 + BRRWT18 + BRRWT19 + BRRWT20 + BRRWT21 + BRRWT22 + BRRWT23 + BRRWT24 + BRRWT25 + BRRWT26 + BRRWT27 + BRRWT28 + BRRWT29 + BRRWT30 + BRRWT31 + BRRWT32 + BRRWT33 + BRRWT34 + BRRWT35 + BRRWT36 + BRRWT37 + BRRWT38 + BRRWT39 + BRRWT40 + BRRWT41 + BRRWT42 + BRRWT43 + BRRWT44 + BRRWT45 + BRRWT46 + BRRWT47 + BRRWT48 + BRRWT49 + BRRWT50 + BRRWT51 + \\n BRRWT52 + BRRWT53 + BRRWT54 + BRRWT55 + BRRWT56 + BRRWT57 + BRRWT58 + BRRWT59 + BRRWT60 + BRRWT61 + BRRWT62 + BRRWT63 + BRRWT64 + BRRWT65 + BRRWT66 + BRRWT67 + BRRWT68 + BRRWT69 + BRRWT70 + BRRWT71 + BRRWT72 + BRRWT73 + BRRWT74 + BRRWT75 + BRRWT76 + BRRWT77 + BRRWT78 + BRRWT79 + BRRWT80 + BRRWT81 + BRRWT82 + BRRWT83 + BRRWT84 + BRRWT85 + BRRWT86 + BRRWT87 + BRRWT88 + BRRWT89 + BRRWT90 + BRRWT91 + BRRWT92 + BRRWT93 + BRRWT94 + BRRWT95 + BRRWT96` ## - weights: NWEIGHT ## Data variables: DOEID (dbl), TOTALDOL (dbl), TOTSQFT_EN (dbl), REGIONC ## (dbl) ## Variables: ## [1] &quot;DOEID&quot; &quot;TOTALDOL&quot; &quot;TOTSQFT_EN&quot; &quot;REGIONC&quot; In specifying the design, the variables option was also used to include which variables might be used in analyses. This is optional but can make our object smaller. When printing the design object or looking at the summary, the replicate weight type is re-iterated as Fay's variance method (rho= 0.5) with 96 replicates and MSE variances, and the variables are included. No weight or probability summary is included in this output as we have seen in some other design objects. 3.3.3 Jackknife method There are three jackknife estimators implemented in {srvyr} - Jackknife 1 (JK1), Jackknife n (JKn), and Jackknife 2 (JK2). The JK1 method can be used for unstratified designs, and replicates are created by removing one PSU at a time so the number of replicates is the same as the number of PSUs. If there is no clustering, then the PSU is the ultimate sampling unit (e.g., unit). The JKn method is used for stratified designs and requires two or more PSUs per stratum. In this case, each replicate is created by deleting one PSU from a single stratum, so the number of replicates is the number of total PSUs across all strata. The JK2 method is a special case of JKn when there are exactly 2 PSUs sampled per stratum. For variance estimation, scaling constants must also be specified. The math Using the generic notation above, \\(\\alpha=\\frac{R-1}{R}\\) and \\(\\alpha_r=1 \\forall r\\). For the JK1 method, the standard error estimate for \\(\\hat{\\theta}\\) is calculated as: \\[se(\\hat{\\theta})=\\sqrt{\\frac{R-1}{R} \\sum_{r=1}^R \\left( \\hat{\\theta}_r-\\hat{\\theta}\\right)^2}\\] The JKn method is a bit more complex, but the coefficients are generally provided with restricted and public-use files. For each replicate, one stratum has a PSU removed, and the weights are adjusted by \\(n_h/(n_h-1)\\) where \\(n_h\\) is the number of PSUs in stratum \\(h\\). The coefficients in other strata are set to 1. Denote the coefficient that results from this process for replicate \\(r\\) as \\(\\alpha_r\\), then the standard error estimate for \\(\\hat{\\theta}\\) is calculated as: \\[se(\\hat{\\theta})=\\sqrt{\\sum_{r=1}^R \\alpha_r \\left( \\hat{\\theta}_r-\\hat{\\theta}\\right)^2}\\] The syntax To specify the Jackknife method, the type would be JK1, JKn, or JK2. Additionally, the overall multiplier for JK1 is specified with the scale argument, whereas the replicate-specific multiplier (\\(\\alpha_r\\)) is specified with the scales argument. Consider a case for the JK1 method where the multiplier, \\((R-1)/R=19/20=0.95\\) and the dataset had WT0 for the main weight and had 20 JK1 weights indicated WT1, WT2, …, WT20, then the syntax would be jk1_des &lt;- dat %&gt;% as_survey_rep(weights = WT0, repweights= num_range(&quot;WT&quot;, 1:20), type=&quot;JK1&quot;, mse=TRUE, scale=0.95) Consider a case for the JKn method where \\(\\alpha_r=0.1\\) for all replicates and the dataset had WT0 for the main weight and had 20 JK1 weights indicated as WT1, WT2, …, WT20, then the syntax would be: jkn_des &lt;- dat %&gt;% as_survey_rep(weights = WT0, repweights= num_range(&quot;WT&quot;, 1:20), type=&quot;JKN&quot;, mse=TRUE, rscales=rep(0.1, 20)) Example The American Community Survey releases public use microdata with JK1 weights at the person and household level. This example includes data at the household level where the replicate weights are specified as WGTP1, …, WGTP80, and the main weight is WGTP (U.S. Census Bureau 2023). Using the {tidycensus} package8, data is downloaded from the Census API. For example, the code below has a request to obtain data for each person in each household in two Public Use Microdata Areas (PUMAs) in Durham County, NC9. The variables requested are NP (number of persons in the household), BDSP (number of bedrooms), HINCP (household income), and TYPEHUGQ (type of household). By default, several other variables will come along, including SERIALNO (a unique identifier for each household), SPORDER (a unique identifier for each person within each household), PUMA, ST (state), person weight (PWGTP), and the household weights (WGTP, WGTP1, …, WGTP80). Filtering to records where SPORDER=1 yields only one record per household and TYPEHUGQ=1 filters to only households and not group quarters. pums_in &lt;- get_pums(variables = c(&quot;NP&quot;, &quot;BDSP&quot;, &quot;HINCP&quot;), state = &quot;37&quot;, puma = c(&quot;01301&quot;, &quot;01302&quot;), rep_weights = &quot;housing&quot;, year = 2021, survey = &quot;acs5&quot;, variables_filter = list(SPORDER = 1, TYPEHUGQ = 1)) ## Getting data from the 2017-2021 5-year ACS Public Use Microdata Sample pums_in ## # A tibble: 5,017 × 90 ## SERIALNO SPORDER NP BDSP HINCP PUMA ST TYPEHUGQ WGTP PWGTP ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2020HU02… 1 2 3 217000 01301 37 1 216 216 ## 2 2020HU02… 1 1 1 60000 01301 37 1 87 88 ## 3 2020HU02… 1 1 3 26270 01301 37 1 1 1 ## 4 2020HU02… 1 3 2 13200 01302 37 1 92 92 ## 5 2020HU02… 1 5 4 556000 01301 37 1 23 23 ## 6 2020HU02… 1 3 2 55600 01301 37 1 51 50 ## 7 2020HU02… 1 1 2 20760 01301 37 1 8 8 ## 8 2020HU02… 1 2 3 18500 01302 37 1 3 3 ## 9 2020HU02… 1 2 2 76000 01301 37 1 25 25 ## 10 2020HU02… 1 1 3 27600 01302 37 1 36 36 ## # ℹ 5,007 more rows ## # ℹ 80 more variables: WGTP1 &lt;dbl&gt;, WGTP2 &lt;dbl&gt;, WGTP3 &lt;dbl&gt;, ## # WGTP4 &lt;dbl&gt;, WGTP5 &lt;dbl&gt;, WGTP6 &lt;dbl&gt;, WGTP7 &lt;dbl&gt;, WGTP8 &lt;dbl&gt;, ## # WGTP9 &lt;dbl&gt;, WGTP10 &lt;dbl&gt;, WGTP11 &lt;dbl&gt;, WGTP12 &lt;dbl&gt;, ## # WGTP13 &lt;dbl&gt;, WGTP14 &lt;dbl&gt;, WGTP15 &lt;dbl&gt;, WGTP16 &lt;dbl&gt;, ## # WGTP17 &lt;dbl&gt;, WGTP18 &lt;dbl&gt;, WGTP19 &lt;dbl&gt;, WGTP20 &lt;dbl&gt;, ## # WGTP21 &lt;dbl&gt;, WGTP22 &lt;dbl&gt;, WGTP23 &lt;dbl&gt;, WGTP24 &lt;dbl&gt;, … acs_des &lt;- pums_in %&gt;% as_survey_rep(weights = WGTP, repweights = num_range(&quot;WGTP&quot;, 1:80), type = &quot;JK1&quot;, mse = TRUE, scale = 4 / 80) acs_des ## Call: Called via srvyr ## Unstratified cluster jacknife (JK1) with 80 replicates and MSE variances. ## Sampling variables: ## - repweights: `WGTP1 + WGTP2 + WGTP3 + WGTP4 + WGTP5 + WGTP6 + WGTP7 + WGTP8 + WGTP9 + WGTP10 + WGTP11 + WGTP12 + WGTP13 + WGTP14 + WGTP15 + WGTP16 + WGTP17 + WGTP18 + WGTP19 + WGTP20 + WGTP21 + WGTP22 + WGTP23 + WGTP24 + WGTP25 + WGTP26 + WGTP27 + WGTP28 + WGTP29 + WGTP30 + WGTP31 + WGTP32 + WGTP33 + WGTP34 + WGTP35 + WGTP36 + WGTP37 + WGTP38 + WGTP39 + WGTP40 + WGTP41 + WGTP42 + WGTP43 + WGTP44 + WGTP45 + WGTP46 + WGTP47 + WGTP48 + WGTP49 + WGTP50 + WGTP51 + WGTP52 + WGTP53 + WGTP54 + WGTP55 + WGTP56 + WGTP57 + \\n WGTP58 + WGTP59 + WGTP60 + WGTP61 + WGTP62 + WGTP63 + WGTP64 + WGTP65 + WGTP66 + WGTP67 + WGTP68 + WGTP69 + WGTP70 + WGTP71 + WGTP72 + WGTP73 + WGTP74 + WGTP75 + WGTP76 + WGTP77 + WGTP78 + WGTP79 + WGTP80` ## - weights: WGTP ## Data variables: SERIALNO (chr), SPORDER (dbl), NP (dbl), BDSP (dbl), ## HINCP (dbl), PUMA (chr), ST (chr), TYPEHUGQ (chr), WGTP (dbl), PWGTP ## (dbl), WGTP1 (dbl), WGTP2 (dbl), WGTP3 (dbl), WGTP4 (dbl), WGTP5 ## (dbl), WGTP6 (dbl), WGTP7 (dbl), WGTP8 (dbl), WGTP9 (dbl), WGTP10 ## (dbl), WGTP11 (dbl), WGTP12 (dbl), WGTP13 (dbl), WGTP14 (dbl), WGTP15 ## (dbl), WGTP16 (dbl), WGTP17 (dbl), WGTP18 (dbl), WGTP19 (dbl), WGTP20 ## (dbl), WGTP21 (dbl), WGTP22 (dbl), WGTP23 (dbl), WGTP24 (dbl), WGTP25 ## (dbl), WGTP26 (dbl), WGTP27 (dbl), WGTP28 (dbl), WGTP29 (dbl), WGTP30 ## (dbl), WGTP31 (dbl), WGTP32 (dbl), WGTP33 (dbl), WGTP34 (dbl), WGTP35 ## (dbl), WGTP36 (dbl), WGTP37 (dbl), WGTP38 (dbl), WGTP39 (dbl), WGTP40 ## (dbl), WGTP41 (dbl), WGTP42 (dbl), WGTP43 (dbl), WGTP44 (dbl), WGTP45 ## (dbl), WGTP46 (dbl), WGTP47 (dbl), WGTP48 (dbl), WGTP49 (dbl), WGTP50 ## (dbl), WGTP51 (dbl), WGTP52 (dbl), WGTP53 (dbl), WGTP54 (dbl), WGTP55 ## (dbl), WGTP56 (dbl), WGTP57 (dbl), WGTP58 (dbl), WGTP59 (dbl), WGTP60 ## (dbl), WGTP61 (dbl), WGTP62 (dbl), WGTP63 (dbl), WGTP64 (dbl), WGTP65 ## (dbl), WGTP66 (dbl), WGTP67 (dbl), WGTP68 (dbl), WGTP69 (dbl), WGTP70 ## (dbl), WGTP71 (dbl), WGTP72 (dbl), WGTP73 (dbl), WGTP74 (dbl), WGTP75 ## (dbl), WGTP76 (dbl), WGTP77 (dbl), WGTP78 (dbl), WGTP79 (dbl), WGTP80 ## (dbl) summary(acs_des) ## Call: Called via srvyr ## Unstratified cluster jacknife (JK1) with 80 replicates and MSE variances. ## Sampling variables: ## - repweights: `WGTP1 + WGTP2 + WGTP3 + WGTP4 + WGTP5 + WGTP6 + WGTP7 + WGTP8 + WGTP9 + WGTP10 + WGTP11 + WGTP12 + WGTP13 + WGTP14 + WGTP15 + WGTP16 + WGTP17 + WGTP18 + WGTP19 + WGTP20 + WGTP21 + WGTP22 + WGTP23 + WGTP24 + WGTP25 + WGTP26 + WGTP27 + WGTP28 + WGTP29 + WGTP30 + WGTP31 + WGTP32 + WGTP33 + WGTP34 + WGTP35 + WGTP36 + WGTP37 + WGTP38 + WGTP39 + WGTP40 + WGTP41 + WGTP42 + WGTP43 + WGTP44 + WGTP45 + WGTP46 + WGTP47 + WGTP48 + WGTP49 + WGTP50 + WGTP51 + WGTP52 + WGTP53 + WGTP54 + WGTP55 + WGTP56 + WGTP57 + \\n WGTP58 + WGTP59 + WGTP60 + WGTP61 + WGTP62 + WGTP63 + WGTP64 + WGTP65 + WGTP66 + WGTP67 + WGTP68 + WGTP69 + WGTP70 + WGTP71 + WGTP72 + WGTP73 + WGTP74 + WGTP75 + WGTP76 + WGTP77 + WGTP78 + WGTP79 + WGTP80` ## - weights: WGTP ## Data variables: SERIALNO (chr), SPORDER (dbl), NP (dbl), BDSP (dbl), ## HINCP (dbl), PUMA (chr), ST (chr), TYPEHUGQ (chr), WGTP (dbl), PWGTP ## (dbl), WGTP1 (dbl), WGTP2 (dbl), WGTP3 (dbl), WGTP4 (dbl), WGTP5 ## (dbl), WGTP6 (dbl), WGTP7 (dbl), WGTP8 (dbl), WGTP9 (dbl), WGTP10 ## (dbl), WGTP11 (dbl), WGTP12 (dbl), WGTP13 (dbl), WGTP14 (dbl), WGTP15 ## (dbl), WGTP16 (dbl), WGTP17 (dbl), WGTP18 (dbl), WGTP19 (dbl), WGTP20 ## (dbl), WGTP21 (dbl), WGTP22 (dbl), WGTP23 (dbl), WGTP24 (dbl), WGTP25 ## (dbl), WGTP26 (dbl), WGTP27 (dbl), WGTP28 (dbl), WGTP29 (dbl), WGTP30 ## (dbl), WGTP31 (dbl), WGTP32 (dbl), WGTP33 (dbl), WGTP34 (dbl), WGTP35 ## (dbl), WGTP36 (dbl), WGTP37 (dbl), WGTP38 (dbl), WGTP39 (dbl), WGTP40 ## (dbl), WGTP41 (dbl), WGTP42 (dbl), WGTP43 (dbl), WGTP44 (dbl), WGTP45 ## (dbl), WGTP46 (dbl), WGTP47 (dbl), WGTP48 (dbl), WGTP49 (dbl), WGTP50 ## (dbl), WGTP51 (dbl), WGTP52 (dbl), WGTP53 (dbl), WGTP54 (dbl), WGTP55 ## (dbl), WGTP56 (dbl), WGTP57 (dbl), WGTP58 (dbl), WGTP59 (dbl), WGTP60 ## (dbl), WGTP61 (dbl), WGTP62 (dbl), WGTP63 (dbl), WGTP64 (dbl), WGTP65 ## (dbl), WGTP66 (dbl), WGTP67 (dbl), WGTP68 (dbl), WGTP69 (dbl), WGTP70 ## (dbl), WGTP71 (dbl), WGTP72 (dbl), WGTP73 (dbl), WGTP74 (dbl), WGTP75 ## (dbl), WGTP76 (dbl), WGTP77 (dbl), WGTP78 (dbl), WGTP79 (dbl), WGTP80 ## (dbl) ## Variables: ## [1] &quot;SERIALNO&quot; &quot;SPORDER&quot; &quot;NP&quot; &quot;BDSP&quot; &quot;HINCP&quot; &quot;PUMA&quot; ## [7] &quot;ST&quot; &quot;TYPEHUGQ&quot; &quot;WGTP&quot; &quot;PWGTP&quot; &quot;WGTP1&quot; &quot;WGTP2&quot; ## [13] &quot;WGTP3&quot; &quot;WGTP4&quot; &quot;WGTP5&quot; &quot;WGTP6&quot; &quot;WGTP7&quot; &quot;WGTP8&quot; ## [19] &quot;WGTP9&quot; &quot;WGTP10&quot; &quot;WGTP11&quot; &quot;WGTP12&quot; &quot;WGTP13&quot; &quot;WGTP14&quot; ## [25] &quot;WGTP15&quot; &quot;WGTP16&quot; &quot;WGTP17&quot; &quot;WGTP18&quot; &quot;WGTP19&quot; &quot;WGTP20&quot; ## [31] &quot;WGTP21&quot; &quot;WGTP22&quot; &quot;WGTP23&quot; &quot;WGTP24&quot; &quot;WGTP25&quot; &quot;WGTP26&quot; ## [37] &quot;WGTP27&quot; &quot;WGTP28&quot; &quot;WGTP29&quot; &quot;WGTP30&quot; &quot;WGTP31&quot; &quot;WGTP32&quot; ## [43] &quot;WGTP33&quot; &quot;WGTP34&quot; &quot;WGTP35&quot; &quot;WGTP36&quot; &quot;WGTP37&quot; &quot;WGTP38&quot; ## [49] &quot;WGTP39&quot; &quot;WGTP40&quot; &quot;WGTP41&quot; &quot;WGTP42&quot; &quot;WGTP43&quot; &quot;WGTP44&quot; ## [55] &quot;WGTP45&quot; &quot;WGTP46&quot; &quot;WGTP47&quot; &quot;WGTP48&quot; &quot;WGTP49&quot; &quot;WGTP50&quot; ## [61] &quot;WGTP51&quot; &quot;WGTP52&quot; &quot;WGTP53&quot; &quot;WGTP54&quot; &quot;WGTP55&quot; &quot;WGTP56&quot; ## [67] &quot;WGTP57&quot; &quot;WGTP58&quot; &quot;WGTP59&quot; &quot;WGTP60&quot; &quot;WGTP61&quot; &quot;WGTP62&quot; ## [73] &quot;WGTP63&quot; &quot;WGTP64&quot; &quot;WGTP65&quot; &quot;WGTP66&quot; &quot;WGTP67&quot; &quot;WGTP68&quot; ## [79] &quot;WGTP69&quot; &quot;WGTP70&quot; &quot;WGTP71&quot; &quot;WGTP72&quot; &quot;WGTP73&quot; &quot;WGTP74&quot; ## [85] &quot;WGTP75&quot; &quot;WGTP76&quot; &quot;WGTP77&quot; &quot;WGTP78&quot; &quot;WGTP79&quot; &quot;WGTP80&quot; When printing the design object or looking at the summary, the replicate weight type is re-iterated as Unstratified cluster jacknife (JK1) with 80 replicates and MSE variances, and the variables are included. No weight or probability summary is included. 3.3.4 Bootstrap Method In bootstrap resampling, replicates are created by selecting random samples of the PSUs with replacement (SRSWR). If there are \\(M\\) PSUs in the sample, then each replicate will be created by selecting a random sample of \\(M\\) PSUs with replacement. Each replicate is created independently, and the weights for each replicate are adjusted to reflect the population, generally using the same method as how the analysis weight was adjusted. The math A weighted estimate for the full sample is calculated as \\(\\hat{\\theta}\\), and then a weighted estimate for each replicate is calculated as \\(\\hat{\\theta}_r\\) for \\(R\\) replicates. Then the standard error of the estimate is calculated as follows: \\[se(\\hat{\\theta})=\\sqrt{\\alpha \\sum_{r=1}^R \\left( \\hat{\\theta}_r-\\hat{\\theta}\\right)^2}\\] where \\(\\alpha\\) is the scaling constant. Note that the scaling constant (\\(\\alpha\\)) is provided in the documentation as there are many types of bootstrap methods which generate custom scaling constants. The syntax If a dataset had WT0 for the main weight, 20 bootstrap weights indicated WT1, WT2, …, WT20, and \\(\\alpha=.02\\), use the following syntax: bs_des &lt;- dat %&gt;% as_survey_rep(weights = WT0, repweights= num_range(&quot;WT&quot;, 1:20), type=&quot;bootstrap&quot;, mse=TRUE, scale=.02) Since \\(\\alpha\\) is a constant, it is not generally a variable on the dataset and is entered into the code as a constant. Example Returning to the api example, we are going to create a dataset with bootstrap weights to use as an example. In this example, we construct a one-cluster design with fifty replicate weights. apiclus1_slim &lt;- apiclus1 %&gt;% as_tibble() %&gt;% arrange(dnum) %&gt;% select(cds, dnum, fpc, pw) set.seed(662152) apibw &lt;- bootweights(psu = apiclus1_slim$dnum, strata = rep(1, nrow(apiclus1_slim)), fpc = apiclus1_slim$fpc, replicates = 50) bwmata &lt;- apibw$repweights$weights[apibw$repweights$index,] * apiclus1_slim$pw apiclus1_slim &lt;- bwmata %&gt;% as.data.frame() %&gt;% set_names(str_c(&quot;pw&quot;, 1:50)) %&gt;% cbind(apiclus1_slim) %&gt;% as_tibble() %&gt;% select(cds, dnum, fpc, pw, everything()) apiclus1_slim ## # A tibble: 183 × 54 ## cds dnum fpc pw pw1 pw2 pw3 pw4 pw5 pw6 pw7 ## &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 43693776… 61 757 33.8 33.8 0 0 33.8 0 33.8 0 ## 2 43693776… 61 757 33.8 33.8 0 0 33.8 0 33.8 0 ## 3 43693776… 61 757 33.8 33.8 0 0 33.8 0 33.8 0 ## 4 43693776… 61 757 33.8 33.8 0 0 33.8 0 33.8 0 ## 5 43693776… 61 757 33.8 33.8 0 0 33.8 0 33.8 0 ## 6 43693776… 61 757 33.8 33.8 0 0 33.8 0 33.8 0 ## 7 43693776… 61 757 33.8 33.8 0 0 33.8 0 33.8 0 ## 8 43693776… 61 757 33.8 33.8 0 0 33.8 0 33.8 0 ## 9 43693776… 61 757 33.8 33.8 0 0 33.8 0 33.8 0 ## 10 43693776… 61 757 33.8 33.8 0 0 33.8 0 33.8 0 ## # ℹ 173 more rows ## # ℹ 43 more variables: pw8 &lt;dbl&gt;, pw9 &lt;dbl&gt;, pw10 &lt;dbl&gt;, pw11 &lt;dbl&gt;, ## # pw12 &lt;dbl&gt;, pw13 &lt;dbl&gt;, pw14 &lt;dbl&gt;, pw15 &lt;dbl&gt;, pw16 &lt;dbl&gt;, ## # pw17 &lt;dbl&gt;, pw18 &lt;dbl&gt;, pw19 &lt;dbl&gt;, pw20 &lt;dbl&gt;, pw21 &lt;dbl&gt;, ## # pw22 &lt;dbl&gt;, pw23 &lt;dbl&gt;, pw24 &lt;dbl&gt;, pw25 &lt;dbl&gt;, pw26 &lt;dbl&gt;, ## # pw27 &lt;dbl&gt;, pw28 &lt;dbl&gt;, pw29 &lt;dbl&gt;, pw30 &lt;dbl&gt;, pw31 &lt;dbl&gt;, ## # pw32 &lt;dbl&gt;, pw33 &lt;dbl&gt;, pw34 &lt;dbl&gt;, pw35 &lt;dbl&gt;, pw36 &lt;dbl&gt;, … The output of apiclus1_slim includes the same variables we have seen in other api examples (see Table 3.1), but now additionally includes bootstrap weights pw1, …, pw50. When creating the survey design object, we use the bootstrap weights as the replicate weights. Additionally, with replicate weights we need to include the scale (\\(\\alpha\\)). For this example we created, \\[\\alpha=\\frac{M}{(M-1)(R-1)}=\\frac{15}{(15-1)*(50-1)}=0.02186589\\] where \\(M\\) is the average number of PSUs per strata and \\(R\\) is the number of replicates. There is only 1 stratum and the number of clusters/PSUs is 15 so \\(M=15\\). api1_bs_des &lt;- apiclus1_slim %&gt;% as_survey_rep(weights = pw, repweights = pw1:pw50, type = &quot;bootstrap&quot;, scale = 0.02186589, mse = TRUE) api1_bs_des ## Call: Called via srvyr ## Survey bootstrap with 50 replicates and MSE variances. ## Sampling variables: ## - repweights: `pw1 + pw2 + pw3 + pw4 + pw5 + pw6 + pw7 + pw8 + pw9 + pw10 + pw11 + pw12 + pw13 + pw14 + pw15 + pw16 + pw17 + pw18 + pw19 + pw20 + pw21 + pw22 + pw23 + pw24 + pw25 + pw26 + pw27 + pw28 + pw29 + pw30 + pw31 + pw32 + pw33 + pw34 + pw35 + pw36 + pw37 + pw38 + pw39 + pw40 + pw41 + pw42 + pw43 + pw44 + pw45 + pw46 + pw47 + pw48 + pw49 + pw50` ## - weights: pw ## Data variables: cds (chr), dnum (int), fpc (dbl), pw (dbl), pw1 (dbl), ## pw2 (dbl), pw3 (dbl), pw4 (dbl), pw5 (dbl), pw6 (dbl), pw7 (dbl), pw8 ## (dbl), pw9 (dbl), pw10 (dbl), pw11 (dbl), pw12 (dbl), pw13 (dbl), ## pw14 (dbl), pw15 (dbl), pw16 (dbl), pw17 (dbl), pw18 (dbl), pw19 ## (dbl), pw20 (dbl), pw21 (dbl), pw22 (dbl), pw23 (dbl), pw24 (dbl), ## pw25 (dbl), pw26 (dbl), pw27 (dbl), pw28 (dbl), pw29 (dbl), pw30 ## (dbl), pw31 (dbl), pw32 (dbl), pw33 (dbl), pw34 (dbl), pw35 (dbl), ## pw36 (dbl), pw37 (dbl), pw38 (dbl), pw39 (dbl), pw40 (dbl), pw41 ## (dbl), pw42 (dbl), pw43 (dbl), pw44 (dbl), pw45 (dbl), pw46 (dbl), ## pw47 (dbl), pw48 (dbl), pw49 (dbl), pw50 (dbl) summary(api1_bs_des) ## Call: Called via srvyr ## Survey bootstrap with 50 replicates and MSE variances. ## Sampling variables: ## - repweights: `pw1 + pw2 + pw3 + pw4 + pw5 + pw6 + pw7 + pw8 + pw9 + pw10 + pw11 + pw12 + pw13 + pw14 + pw15 + pw16 + pw17 + pw18 + pw19 + pw20 + pw21 + pw22 + pw23 + pw24 + pw25 + pw26 + pw27 + pw28 + pw29 + pw30 + pw31 + pw32 + pw33 + pw34 + pw35 + pw36 + pw37 + pw38 + pw39 + pw40 + pw41 + pw42 + pw43 + pw44 + pw45 + pw46 + pw47 + pw48 + pw49 + pw50` ## - weights: pw ## Data variables: cds (chr), dnum (int), fpc (dbl), pw (dbl), pw1 (dbl), ## pw2 (dbl), pw3 (dbl), pw4 (dbl), pw5 (dbl), pw6 (dbl), pw7 (dbl), pw8 ## (dbl), pw9 (dbl), pw10 (dbl), pw11 (dbl), pw12 (dbl), pw13 (dbl), ## pw14 (dbl), pw15 (dbl), pw16 (dbl), pw17 (dbl), pw18 (dbl), pw19 ## (dbl), pw20 (dbl), pw21 (dbl), pw22 (dbl), pw23 (dbl), pw24 (dbl), ## pw25 (dbl), pw26 (dbl), pw27 (dbl), pw28 (dbl), pw29 (dbl), pw30 ## (dbl), pw31 (dbl), pw32 (dbl), pw33 (dbl), pw34 (dbl), pw35 (dbl), ## pw36 (dbl), pw37 (dbl), pw38 (dbl), pw39 (dbl), pw40 (dbl), pw41 ## (dbl), pw42 (dbl), pw43 (dbl), pw44 (dbl), pw45 (dbl), pw46 (dbl), ## pw47 (dbl), pw48 (dbl), pw49 (dbl), pw50 (dbl) ## Variables: ## [1] &quot;cds&quot; &quot;dnum&quot; &quot;fpc&quot; &quot;pw&quot; &quot;pw1&quot; &quot;pw2&quot; &quot;pw3&quot; &quot;pw4&quot; &quot;pw5&quot; ## [10] &quot;pw6&quot; &quot;pw7&quot; &quot;pw8&quot; &quot;pw9&quot; &quot;pw10&quot; &quot;pw11&quot; &quot;pw12&quot; &quot;pw13&quot; &quot;pw14&quot; ## [19] &quot;pw15&quot; &quot;pw16&quot; &quot;pw17&quot; &quot;pw18&quot; &quot;pw19&quot; &quot;pw20&quot; &quot;pw21&quot; &quot;pw22&quot; &quot;pw23&quot; ## [28] &quot;pw24&quot; &quot;pw25&quot; &quot;pw26&quot; &quot;pw27&quot; &quot;pw28&quot; &quot;pw29&quot; &quot;pw30&quot; &quot;pw31&quot; &quot;pw32&quot; ## [37] &quot;pw33&quot; &quot;pw34&quot; &quot;pw35&quot; &quot;pw36&quot; &quot;pw37&quot; &quot;pw38&quot; &quot;pw39&quot; &quot;pw40&quot; &quot;pw41&quot; ## [46] &quot;pw42&quot; &quot;pw43&quot; &quot;pw44&quot; &quot;pw45&quot; &quot;pw46&quot; &quot;pw47&quot; &quot;pw48&quot; &quot;pw49&quot; &quot;pw50&quot; As with other replicate design objects, when printing the object or looking at the summary, the replicate weights are provided along with the data variables. 3.4 Understanding survey design documentation SRS, stratified, and clustered designs are the backbone of sampling designs, and the features are often combined in one design. Additionally, rather than using SRS for selection, other sampling mechanisms are commonly used, such as probability proportional to size (PPS), systematic sampling, or selection with unequal probabilities, which are briefly described here. In PPS sampling, a size measure is constructed for each unit (e.g., the population of the PSU or the number of occupied housing units) and then units with larger size measures are more likely to be sampled. Systematic sampling is commonly used to ensure representation across a population. Units are sorted by a feature and then every \\(k\\) units are selected from a random start point so the sample is spread across the population. In addition to PPS, other unequal probabilities of selection may be used. For example, in a study of establishments (e.g., businesses or public institutions) that conducts a survey every year, an establishment that recently participated (e.g., participated last year) may have a reduced chance of selection in a subsequent round to reduce the burden on the establishment. To learn more about sampling designs, refer to Valliant, Dever, and Kreuter (2013), Cox et al. (2011), Cochran (1977), and Deming (1991). A common method of sampling is to stratify PSUs, select PSUs within the stratum using PPS selection, and then select units within the PSUs either with SRS or PPS. Reading survey documentation is an important first step in survey analysis to understand the design of the survey we are using and variables necessary to specify the design. Good documentation will highlight the variables necessary to specify the design. This is often found in User’s Guides, methodology, analysis guides, or technical documentation (see Chapter 4 for more details). Example For example, the 2017-2019 National Survey of Family Growth (NSFG)10 had a stratified multi-stage area probability sample. In the first stage, PSUs are counties or collections of counties and are stratified by Census region/division, size (population), and MSA status. Within each stratum, PSUs were selected via PPS. In the second stage, neighborhoods were selected within the sampled PSUs using PPS selection. In the third stage, housing units were selected within the sampled neighborhoods. In the fourth stage, a person was randomly chosen within the selected housing units among eligible persons using unequal probabilities based on the person’s age and sex. The public use file does not include all these levels of selection and instead has pseudo-strata and pseudo-clusters, which are the variables used in R to specify the design. As specified on page 4 of the documentation, the stratum variable is SEST, the cluster variable is SECU, and the weight variable is WGT2017_2019. Thus, to specify this design in R, use the following syntax: nsfg_des &lt;- nsfgdata %&gt;% as_survey_design(ids = SECU, strata = SEST, weights = WGT2017_2019) 3.5 Exercises The American National Election Studies (ANES) collect data before and after elections approximately every four years around the presidential election cycle. Each year with the data release, a user’s guide is also released11. What is the syntax for specifying the analysis of the full sample post-election data? anes_des &lt;- anes_data %&gt;% as_survey_design(weight) The General Social Survey is a survey that has been administered since 1972 on social, behavioral, and attitudinal topics. The 2016-2020 GSS Panel codebook12 provides examples of setting up syntax in SAS and Stata but not R. How would you specify the design in R? gss_des &lt;- gss_data %&gt;% as_survey_design(ids = VPSU_2, strata = VSTRAT_2, weights = WTSSNR_2) References "],["c04-understanding-survey-data-documentation.html", "Chapter 4 Understanding Survey Data Documentation 4.1 Introduction 4.2 Types of Survey Documentation 4.3 Working with Missing Data 4.4 Example: American National Election Studies (ANES) 2020 Survey Documentation 4.5 Searching for Public-Use Survey Data", " Chapter 4 Understanding Survey Data Documentation Prerequisites For this chapter, here are the packages and helper functions we will need: library(tidyverse) library(survey) library(srvyr) library(osfr) source(&quot;helper-fun/helper-functions.R&quot;) library(censusapi) We will be using data from ANES. Here is the code to read in the data. anes_in &lt;- read_osf(&quot;anes_2020.rds&quot;) 4.1 Introduction Before diving into survey analysis, it’s crucial to review the survey documentation thoroughly. The documentation includes technical guides, questionnaires, codebooks, errata, and other useful resources. By taking the time to review these materials, we can gain a comprehensive understanding of the survey data (including research and design decisions discussed in Chapters 2 and 3) and effectively conduct our analysis. Survey documentation can vary in organization, type, and ease of use. The information may be stored in any format - PDFs, Excel spreadsheets, Word documents, etc. Some surveys save different documentation together, such as providing a single document containing both the codebook and the questionnaire. Others keep them in separate files. Despite these differences, it is important to know what kind of information is available in each documentation type and what to focus on in each one. 4.2 Types of Survey Documentation 4.2.1 Technical Documentation The technical documentation, also known as user guides or methodology/analysis guides, highlights the variables necessary to specify the survey design. We recommend focusing on these key sections: Introduction: The introduction orients us to the survey. This section provides the project’s background, the study’s purpose, and the main research questions. Study design: The study design section describes how researchers prepared and administered the survey. Sample: The sample section describes how researchers selected cases, any sampling error that occurred, and the limitations of the sample. This section can contain recommendations on how to use sampling weights. Look for weight information, whether the survey design contains strata, clusters/PSUs, or replicate weights. Also look for population sizes, finite population correction, or replicate weight scaling information. The sample documentation is critical in successfully running our analysis, and more detail on sample designs is available in Chapter 3. The technical documentation may include other helpful information. Some technical documentation includes syntax for SAS, SUDAAN, Stata, and/or R, meaning we do not have to create this code from scratch. 4.2.2 Questionnaires A questionnaire is a series of questions used to collect information from people in a survey. It can ask about opinions, behaviors, demographics, or even just numbers like the count of lightbulbs, square footage, or farm size. Questionnaires can employ different types of questions, such as closed-ended (e.g., select one or check all that apply), open-ended (e.g., numeric or text), Likert scales, or ranking questions. It may randomize the display order of responses or include instructions to help respondents understand the questions. A survey may have one questionnaire or multiple, depending on its scale and scope. The questionnaire is another essential resource for understanding and interpreting the survey data (see Section 2.3.3), and we should use it alongside any analysis. It provides details about each of the questions asked in the survey, such as question name, question wording, response options, skip logic, randomizations, display specification, mode differences, and the universe (if only a subset of respondents were asked the question). Below, in Figure 4.1, we show a question from the ANES 2020 questionnaire (American National Election Studies 2021). This figure shows a particular question’s question name (POSTVOTE_RVOTE), description (Did R Vote?), full wording of the question and responses, response order, universe, question logic (if vote_pre = 0), and other specifications. The section also includes the variable name, which we can link to the codebook. FIGURE 4.1: ANES 2020 Questionnaire Example The content and structure of questionnaires vary depending on the specific survey. For instance, question names may be informative (like the ANES example), sequential, or denoted by a code. In some cases, surveys may not use separate names for questions and variables. Figure 4.2 shows a question from the Behavioral Risk Factor Surveillance System (BRFSS) questionnaire that shows a sequential question number and a coded variable name (as opposed to a question name) (Centers for Disease Control and Prevention (CDC) 2021). FIGURE 4.2: BRFSS 2021 Questionnaire Example Given the variety in how the survey information is presented in documentation, we need to consider the details of a survey when running our analyses. For example, surveys that use different modes (e.g., web and mail) may have different question wording or skip logic, as a web survey can include fills or automate skip logic. This may result in separate scripts for each mode. Reviewing the questionnaire documentation for the specific survey is crucial in understanding how to interpret the data and findings. 4.2.3 Codebooks While a questionnaire provides information about the questions asked to respondents, the codebook explains how the survey data was coded and recorded. The codebook lists details such as variable names, variable labels, variable meanings, codes for missing data, value labels, and value types (whether categorical or continuous, etc.). In particular, the codebook (as opposed to the questionnaire) often includes information on missing data. The codebook enables us to understand and use the variables appropriately in our analysis. Note that some studies use the terminology data dictionary rather than codebook. Figure 4.3 is a question from the ANES 2020 codebook (American National Election Studies 2022). This part indicates a particular variable’s name (V202066), question wording, value labels, universe, and associated survey question (POSTVOTE_RVOTE). FIGURE 4.3: ANES 2020 Codebook Example Reviewing both questionnaires and codebooks in parallel is important (Figures 4.1 and 4.3), as questions and variables do not always correspond directly to each other in a one-to-one mapping. A single question may have multiple associated variables, or a single variable may summarize multiple questions. Reviewing the codebook clarifies how to interpret the variables. 4.2.4 Errata An erratum (singular) or errata (plural) is a document that lists errors found in a publication or dataset, such as a survey questionnaire. The purpose of an erratum is to correct or update mistakes or inaccuracies in the original document. For example, if a survey questionnaire contains an error, such as a typo or confusing wording, the researchers would release an erratum that provides a corrected version. Another type of erratum is amending incorrectly programmed skips in an electronic survey where questions are skipped by the respondent when they should not have been. Review these errata before conducting any analysis to ensure the accuracy and reliability of the survey data and analysis. 4.2.5 Additional Resources Surveys may have additional resources, such as interviewer instructions or “show cards” provided to respondents during interviewer-administered surveys to help respondents answer questions. Explore the survey website to find out what resources were used and in what contexts. 4.3 Working with Missing Data Missing data in surveys refers to situations where participants do not provide complete responses to survey questions. Respondents may not have seen a question by design. Or, they may not respond to a question for various other reasons, such as not wanting to answer a particular question, not understanding the question, or simply forgetting to answer. Missing data can be a significant problem in survey analysis, as it can introduce bias and reduce the representativeness of the data. Missing data typically falls into two main categories: missing by design or unintentional mechanisms. Missing by design/questionnaire skip logic: This type of missingness occurs when certain respondents are intentionally directed to skip specific questions based on their previous responses or characteristics. For example, in a survey about employment, if a respondent indicates that they are not employed, they may be directed to skip questions related to their job responsibilities. Additionally, some surveys randomize questions or modules so that not all participants respond to all questions. In these instances, respondents would have missing data for the modules not randomly assigned to them. Unintentional missing data: This type of missingness occurs when researchers do not intend for there to be missing data on a particular question, for example, if respondents did not finish the survey or refused to answer individual questions. There are three main types of unintentional missing data that each should be considered and handled differently (Mack, Su, and Westreich 2018; Schafer and Graham 2002): Missing completely at random (MCAR): The missing data is unrelated to both observed and unobserved data, and the probability of being missing is the same across all cases. For example, if a respondent missed a question because they had to leave the survey early due to an emergency. Missing at random (MAR): The missing data is related to observed data but not unobserved data, and the probability of being missing is the same within groups. For example, if older respondents choose not to answer specific questions but younger respondents do answer them and we know the respondent’s age. Missing not at random (MNAR): The missing data is related to unobserved data, and the probability of being missing varies for reasons we are not measuring. For example, if respondents with depression do not answer a question about depression severity. The survey documentation, often the codebook, represents the missing data with a code. For example, a survey may have “Yes” responses coded to 1, “No” responses coded to 2, and missing responses coded to -9. Or, the codebook may list different codes depending on why certain data is missing. In the example of variable V202066 from the ANES (Figure 4.3), -9 represents “Refused,” -7 means that the response was deleted due to an incomplete interview, -6 means that there is no response because there was no follow-up interview, and -1 means “Inapplicable” (due to the designed skip pattern). When running analysis in R, we must handle missing responses as missing data (i.e., NA) and not numeric data. If missing responses are treated as zeros or arbitrary values, they can artificially alter summary statistics or introduce spurious patterns in the analysis. Recoding these values to NA will allow us to handle missing data in different ways in R, such as using functions like na.omit(), complete.cases(), or specialized packages like {tidyimpute} or {mice}. These tools allow us to treat missing responses as missing data to conduct our analysis accurately and obtain valid results. Visualizing the missing data can also inform the types of missing data that are present. The {naniar} package provides many valuable missing data visualizations, such as using gg_miss_var() to see the count or percent of missing data points by variable or gg_miss_fct() to see relationships in missing data across levels of a factor variable. Investigating the relationships and nature of the missing data before running models can ensure that the missing data is accurately accounted for. 4.3.1 Accounting for Questionnaire Skip Patterns Questionnaires may include skip patterns, in which specific questions are skipped based on the respondent’s answers to earlier questions. For example, if a respondent answers “no” to a question on whether they voted in the last election, they may be instructed to skip a series of questions related to that election. Skip patterns are used in surveys to streamline the data collection process and avoid asking irrelevant questions to certain respondents. However, they also result in missing data, as respondents cannot respond to questions they were instructed to skip. Analyzing the data missing by design requires understanding the underlying reasons for the skip patterns. Our survey analysis must properly account for skip patterns to ensure unbiased and accurate population parameters. Dealing with missing data due to skip patterns requires careful consideration. We can treat skipped questions as missing data. Or, we can run an analysis that accounts for the conditional dependence between the skipped and answered questions. The appropriate method depends on the nature and extent of the skip patterns, the research questions, and the methodology. For example, if we wanted to know what proportion of eligible voters voted for a particular candidate, the denominator would be all eligible voters, while if we wanted to know what proportion voted for a specific candidate among those who voted, the denominator would be those who voted. We include or exclude missing values depending on our research question. 4.3.2 Accounting for Unintentional Missing Data When dealing with missing data that is MCAR, MAR, or MNAR, we must consider the implications of how we handle these missing data and avoid introducing more sources of bias. For instance, we can analyze only the respondents who answered all questions by performing listwise deletion, which drops all rows from a data frame with a missing value in any column. For example, let’s say we have a dataset dat with one complete case and two cases with some missing data. We can use the function tidyr::drop_na() for listwise deletion. dat &lt;- tibble::tribble(~ col1, ~ col2, ~ col3, &quot;a&quot;, &quot;d&quot;, &quot;e&quot;, &quot;b&quot;, NA, NA, &quot;c&quot;, NA, &quot;f&quot;) dat ## # A tibble: 3 × 3 ## col1 col2 col3 ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 a d e ## 2 b &lt;NA&gt; &lt;NA&gt; ## 3 c &lt;NA&gt; f If we use the tidyr::drop_na() function, only the first case will remain, as the other two cases have at least one missing value. dat %&gt;% tidyr::drop_na() ## # A tibble: 1 × 3 ## col1 col2 col3 ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 a d e However, if we want to only remove rows that have missing values in col3, we can specify this as an argument in drop_na() as follows: dat %&gt;% tidyr::drop_na(col3) ## # A tibble: 2 × 3 ## col1 col2 col3 ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 a d e ## 2 c &lt;NA&gt; f The drop_na() function works on tbl_svy objects as well and should only be applied after creating the design object. If the data is not missing completely at random (MCAR), then listwise deletion may produce biased estimates if there is a pattern of respondents who do not respond to specific questions. In these circumstances, we should explore other options, such as multiple imputation or weighted estimation. However, imputation is not always appropriate and can introduce its own sources of bias. See Allison (2002) for more details. In summary, we need to deeply understand the types and reasons for missing data in our survey before running any analysis. The survey documentation is an important resource for understanding how to deal with missing data. Carefully review the documentation for guidance from the researchers. 4.4 Example: American National Election Studies (ANES) 2020 Survey Documentation Let’s look at the survey documentation for the American National Election Studies (ANES) 2020. The survey website is located at https://electionstudies.org/data-center/2020-time-series-study/. Navigating to “User Guide and Codebook” (American National Election Studies 2022), we can download the PDF that contains the survey documentation, titled “ANES 2020 Time Series Study Full Release: User Guide and Codebook”. Do not be daunted by the 796-page PDF. We can focus on the most critical information. Introduction The first section in the User Guide explains that the ANES 2020 Times Series Study continues a series of election surveys conducted since 1948. These surveys contain data on public opinion and voting behavior in the U.S. presidential elections. The introduction also includes information about the modes used for data collection (web, live video interviewing, or CATI). Additionally, there is a summary of the number of pre-election interviews (8,280) and post-election re-interviews (7,449). Sample Design and Respondent Recruitment The section “Sample Design and Respondent Recruitment” provides more detail about how the survey was conducted in that it was a sequential mixed-mode design. This means that all three modes were conducted one after another and not at the same time. Additionally, it indicates that for the 2020 survey, they resampled all respondents who participated in 2016 ANES, along with a freshly-drawn cross-section: The target population for the fresh cross-section was the 231 million non-institutional U.S. citizens aged 18 or older living in the 50 U.S. states or the District of Columbia. The document continues with more details on the sample groups. Data Analysis, Weights, and Variance Estimation The section “Data Analysis, Weights, and Variance Estimation” includes information on weights and strata/cluster variables. Reading through, we can find the full sample weight variables: For analysis of the complete set of cases using pre-election data only, including all cases and representative of the 2020 electorate, use the full sample pre-election weight, V200010a. For analysis including post-election data for the complete set of participants (i.e., analysis of post-election data only or a combination of pre- and post-election data), use the full sample post-election weight, V200010b. Additional weights are provided for analysis of subsets of the data… The document provides more information about the variables, summarized below: For weight Use variance unit/PSU/cluster and use variance stratum V200010a V200010c V200010d V200010b V200010c V200010d The user guide references a supplemental document called “How to Analyze ANES Survey Data” (DeBell 2010) as a ‘how-to guide’ to help us with our analysis. In the how-to guide, we learn more about the weights, including that the weights sum to the sample size and not the population. If we want to create estimates at the population level instead of the sample level, we will need to adjust the weights to the population. Let’s recall the “Sample Design and Respondent Recruitment” section: The target population for the fresh cross-section was the 231 million non-institutional U.S. citizens aged 18 or older living in the 50 U.S. states or the District of Columbia. To create accurate weights for the population, we need to determine the total population size when the survey was conducted. We will use Current Population Survey (CPS) to find a number of the non-institutional U.S. citizens aged 18 or older living in the 50 U.S. states or D.C. in March of 2020, as this is what the ANES methodology mentions using. The {censusapi} package allows us to run a reproducible analysis of the CPS data. Note that this package requires a census API key; more information can be found in the package documentation. Best practice is to include the census API key in our R environment and not directly in the code. We can use the {usethis} package’s edit_r_environ() function to access the R environment (located in a file called .Renviron). Run edit_r_environ(), save the census API key as CENSUS_KEY, and restart RStudio. Once the census API key is saved in the R environment, we access it in our code with Sys.getenv(\"CENSUS_KEY\"). We extract several variables including month of interview (HRMONTH), year of interview (HRYEAR4), age (PRTAGE), citizenship status (PRCITSHP), and final person-level weight (PWSSWGT). Detailed information for these variables can be found in the data dictionary13. cps_state_in &lt;- getCensus(name = &quot;cps/basic/mar&quot;, vintage = 2020, region = &quot;state&quot;, vars = c(&quot;HRMONTH&quot;, &quot;HRYEAR4&quot;, &quot;PRTAGE&quot;, &quot;PRCITSHP&quot;, &quot;PWSSWGT&quot;), key = Sys.getenv(&quot;CENSUS_KEY&quot;)) cps_state &lt;- cps_state_in %&gt;% as_tibble() %&gt;% mutate(across(.cols = everything(), .fns = as.numeric)) We confirm that all the data is from March (HRMONTH == 3) of 2020 (HRYEAR4 == 2020). cps_state %&gt;% distinct(HRMONTH, HRYEAR4) ## # A tibble: 1 × 2 ## HRMONTH HRYEAR4 ## &lt;dbl&gt; &lt;dbl&gt; ## 1 3 2020 We then filter to only those who are 18 years or older (PRTAGE &gt;= 18) and have U.S. citizenship (PRCITSHIP %in% (1:4)) and calculate the sum of the weights to obtain the size of the target population. targetpop &lt;- cps_state %&gt;% as_tibble() %&gt;% filter(PRTAGE &gt;= 18, PRCITSHP %in% (1:4)) %&gt;% pull(PWSSWGT) %&gt;% sum() targetpop ## [1] 2.31e+08 The target population in 2020 is 231,034,125. This information gives us what we need to create the post-election survey object with {srvyr}. Using the raw ANES data we pulled in at the beginning of this chapter, we will adjust the weighting variable (V200010b) using the target population we just calculated (targetpop). anes_adjwgt &lt;- anes_in %&gt;% mutate(Weight = V200010b / sum(V200010b) * targetpop) Once we adjusted the weights to the population, we can then create the survey design using our new weight variable in the weights argument and use the strata and cluster variables identified in the user manual. anes_des &lt;- anes_adjwgt %&gt;% as_survey_design(weights = Weight, strata = V200010d, ids = V200010c, nest = TRUE) summary(anes_des) ## Stratified 1 - level Cluster Sampling design (with replacement) ## With (101) clusters. ## Called via srvyr ## Probabilities: ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 0.000005 0.000027 0.000047 0.000077 0.000084 0.003905 ## Stratum Sizes: ## 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 ## obs 167 148 158 151 147 172 163 159 160 159 137 179 148 160 159 ## design.PSU 3 2 2 2 2 2 2 2 2 2 2 2 2 2 2 ## actual.PSU 3 2 2 2 2 2 2 2 2 2 2 2 2 2 2 ## 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 ## obs 148 158 156 154 144 170 146 165 147 169 165 172 133 157 167 ## design.PSU 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 ## actual.PSU 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 ## 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 ## obs 154 143 143 124 138 130 136 145 140 125 158 146 130 126 126 ## design.PSU 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 ## actual.PSU 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 ## 46 47 48 49 50 ## obs 135 133 140 133 130 ## design.PSU 2 2 2 2 2 ## actual.PSU 2 2 2 2 2 ## Data variables: ## [1] &quot;V200010b&quot; &quot;V200010d&quot; ## [3] &quot;V200010c&quot; &quot;V200002&quot; ## [5] &quot;V201006&quot; &quot;V201102&quot; ## [7] &quot;V201101&quot; &quot;V201103&quot; ## [9] &quot;V201025x&quot; &quot;V201231x&quot; ## [11] &quot;V201233&quot; &quot;V201237&quot; ## [13] &quot;V201507x&quot; &quot;V201510&quot; ## [15] &quot;V201549x&quot; &quot;V201600&quot; ## [17] &quot;V201617x&quot; &quot;V202066&quot; ## [19] &quot;V202109x&quot; &quot;V202072&quot; ## [21] &quot;V202073&quot; &quot;V202110x&quot; ## [23] &quot;InterviewMode&quot; &quot;Weight&quot; ## [25] &quot;Stratum&quot; &quot;VarUnit&quot; ## [27] &quot;Age&quot; &quot;AgeGroup&quot; ## [29] &quot;Gender&quot; &quot;RaceEth&quot; ## [31] &quot;PartyID&quot; &quot;Education&quot; ## [33] &quot;Income&quot; &quot;Income7&quot; ## [35] &quot;CampaignInterest&quot; &quot;TrustGovernment&quot; ## [37] &quot;TrustPeople&quot; &quot;VotedPres2016&quot; ## [39] &quot;VotedPres2016_selection&quot; &quot;VotedPres2020&quot; ## [41] &quot;VotedPres2020_selection&quot; &quot;EarlyVote2020&quot; Now that we have the survey design object, we can continue to reference the ANES documentation, including the questionnaire and the codebook, as we select variables for analysis and gain insights into the findings. 4.5 Searching for Public-Use Survey Data Throughout this book, we use public-use datasets from different surveys. Above, we provided an example from the American National Election Survey (ANES), and we will continue to use this dataset throughout the book. Additionally, we use the Residential Energy Consumption Survey (RECS), the National Crime Victimization Survey (NCVS), and the AmericasBarometer surveys. As mentioned in Chapter 2, instead of creating a new survey, researchers should look for existing data that can provide insights into their research questions. One of the greatest sources of data is the government. For example, in the U.S., we can get data directly from the various statistical agencies like we have done with RECS and NCVS. Other countries often have data available through official statistics offices, such as the Office for National Statistics in the U.K. In addition to government data, many researchers will make their data publicly available through repositories such as the Inter-university Consortium for Political and Social Research (ICPSR) variable search or the Odum Institute Data Archive. Searching these repositories or other compiled lists (e.g., Analyze Survey Data for Free - asdfree.com) can be an efficient way to identify surveys with questions related to the researcher’s topic of interest. References "],["c05-descriptive-analysis.html", "Chapter 5 Descriptive Analyses in {srvyr} 5.1 Introduction 5.2 Similarities Between {dplyr} and {srvyr} Functions 5.3 Counts and Cross-Tabulations 5.4 Totals and Sums 5.5 Means and Proportions 5.6 Quantiles and Medians 5.7 Ratios 5.8 Correlations 5.9 Standard Deviation and Variance 5.10 Additional Topics 5.11 Exercises", " Chapter 5 Descriptive Analyses in {srvyr} Prerequisites For this chapter, here are the packages and helper functions we will need: library(tidyverse) library(survey) library(srvyr) library(osfr) source(&quot;helper-fun/helper-functions.R&quot;) library(broom) To help explain the similarities between {dplyr} functions and {srvyr} functions, this chapter will use the mtcars and iris datasets that are built-in to R and apistrat data that comes in the {survey} package: data(api) dstrata &lt;- apistrat %&gt;% as_survey_design(strata = stype, weights = pw) We will be using data from ANES and RECS. Here is the code to create the design objects for each to use throughout this chapter. For ANES, we need to adjust the weight so it sums to the population instead of the sample (see the ANES documentation and Chapter 4 for more information). anes_in &lt;- read_osf(&quot;anes_2020.rds&quot;) targetpop &lt;- 231592693 anes_adjwgt &lt;- anes_in %&gt;% mutate(Weight = Weight/sum(Weight) * targetpop) anes_des &lt;- anes_adjwgt %&gt;% as_survey_design(weights = Weight, strata = Stratum, ids = VarUnit, nest = TRUE) For RECS, details are included in the RECS documentation and Chapter 3. recs_in &lt;- read_osf(&quot;recs_2015.rds&quot;) recs_des &lt;- recs_in %&gt;% as_survey_rep(weights = NWEIGHT, repweights = starts_with(&quot;BRRWT&quot;), type = &quot;Fay&quot;, rho = 0.5, mse = TRUE) 5.1 Introduction Descriptive analyses, such as basic counts, cross-tabulations, or means, are one of the first steps a researcher takes before conducting statistical tests or developing models. Reviewing findings from descriptive analyses can help researchers glean insight into the data, the underlying population, and any unique aspects of the data or population. For example, if the data shows a proportion of males of only 10% in the data, this could indicate either a unique population or a potential error in the data. Additionally, researchers can use descriptive analyses to provide means, proportions, or other measures to summarize the data and make estimates about the population. We will discuss many different types of descriptive analyses in this chapter, but it is important to know what type of data we have and what statistics to use for that type of data. In survey data, we typically consider data to be one of these four main data types: Categorical/nominal data: variables with levels or descriptions that cannot be ordered, such as the region of the country (North, South, East, and West) Ordinal data: variables that can be ordered, such as those from a Likert scale (strongly disagree, disagree, agree, and strongly agree) Discrete data: variables that are counted or measured, such as number of children Continuous data, variables that are measured and whose values can lie anywhere on an interval, such as weight When we pull the data from surveys into R, the data will be listed as character, factor, numeric, or logical/Boolean. They will not clearly indicate the type of survey data (e.g., ordinal). When working with survey data, researchers need to properly use the questionnaire and codebook along with the data (see Chapter 4) to understand what the values for each variable represent. For example, our survey data may represent categorical variables (e.g., the North, South, East, and West regions of the United States) using numeric codes (e.g., 1, 2, 3, and 4). Though this is a categorical variable from the survey, this variable might be automatically read as numeric values when we import our data into R. This can lead to the common mistake of applying a mean function to categorical values instead of a proportion function. Choosing appropriate measures is crucial to reach valid conclusions. Different variable types have distinct properties and levels of measurement, and we cannot apply all measures to all variables. This chapter will discuss how to analyze measures of distribution (e.g., cross-tabulations), central tendency (e.g., means), relationship (e.g., ratios), and dispersion (e.g., standard). Measures of distribution describe how often an event or response occurs. These measures include counts and totals. Measures of central tendency find the central (or average) responses. These measures include means and medians. Measures of relationship describe how variables relate to each other. These measures include correlations and ratios. Measures of dispersion describe how data spreads around the central tendency for continuous variables. These measures include standard deviations and variances. Specifically, we will cover the following functions from the {srvyr} package: Count of observations (survey_count() and survey_tally()) Summation of variables (survey_total()) Means and proportions (survey_mean() and survey_prop()) Quantiles and medians (survey_quantile() and survey_median()) Correlations (survey_corr()) Ratios (survey_ratio()) Variances and standard deviations (survey_var() and survey_sd()) To incorporate each of these survey functions, recall the general process for survey estimation from Chapter 3: Create a tbl_svy object using srvyr::as_survey_design() or srvyr::as_survey_rep(). Subset the data for subpopulations using srvyr::filter(), if needed. Specify domains of analysis using srvyr::group_by(), if needed. Analyze the data with survey-specific functions. We have already discussed how to create the survey design objects in Chapter 3, and the code for creating these for the two datasets used in this chapter is provided in the Prerequisites box at the beginning of this chapter. We will apply the survey functions covered in this chapter in Step 4. To look at the data by different subgroups, we can choose to filter and/or group the data. It is very important that we filter and group the data only after creating the design object. This is necessary to ensure that the results accurately account for the survey design. Removing any data before creating the survey design object means that the data for those cases is not included in the survey design information and estimations of the variance. 5.2 Similarities Between {dplyr} and {srvyr} Functions One of the major advantages of using {srvyr} is that it applies {dplyr}-like syntax to the {survey} package. We can use pipes to specify a tbl_svy object, apply a function, and then feed that output into the next function’s first argument. Functions follow the ‘tidy’ convention of snake_case function names. The example below calculates the mean and median for the variable mpg (miles per gallon) in the mtcars dataset. mtcars %&gt;% summarize(mpg_mean = mean(mpg), mpg_median = median(mpg)) ## mpg_mean mpg_median ## 1 20.09 19.2 Similarly, in the next example, the variance and standard deviation of the variable api00 are calculated for the tbl_svy object dstrata. Note the similarity in the syntax. When we dig into the functions later, we will show that the results output are similar in that one row is output for each group (if there are groups), but there will be more columns output. Specifically, by default, the standard error of the statistic is calculated in addition to the statistic. dstrata %&gt;% summarize(api00_mean = survey_mean(api00), api00_med = survey_median(api00)) ## # A tibble: 1 × 4 ## api00_mean api00_mean_se api00_med api00_med_se ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 662. 9.54 668 13.7 The functions in {srvyr} also play nicely with other tidyverse functions. If we wanted to select columns that have something in common, we use {tidyselect} functions such as starts_with(), num_range(), etc. In the examples below, a combination of across() and starts_with() to calculate the mean of variables starting with “Sepal” in the iris data frame and then starting with api in the dstrata survey object. iris %&gt;% summarize(across(starts_with(&quot;Sepal&quot;), mean)) ## Sepal.Length Sepal.Width ## 1 5.843 3.057 dstrata %&gt;% summarize(across(starts_with(&quot;api&quot;), survey_mean)) ## # A tibble: 1 × 6 ## api00 api00_se api99 api99_se api.stu api.stu_se ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 662. 9.54 629. 10.1 498. 16.4 We can use {dplyr} verbs such as mutate(), filter(), etc., on our survey object. dstrata_mod &lt;- dstrata %&gt;% mutate(api_diff = api00 - api99) %&gt;% filter(stype == &quot;E&quot;) %&gt;% select(stype, api99, api00, api_diff, api_students = api.stu) dstrata_mod ## Stratified Independent Sampling design (with replacement) ## Called via srvyr ## Sampling variables: ## - ids: `1` ## - strata: stype ## - weights: pw ## Data variables: stype (fct), api99 (int), api00 (int), api_diff (int), ## api_students (int) dstrata ## Stratified Independent Sampling design (with replacement) ## Called via srvyr ## Sampling variables: ## - ids: `1` ## - strata: stype ## - weights: pw ## Data variables: cds (chr), stype (fct), name (chr), sname (chr), snum ## (dbl), dname (chr), dnum (int), cname (chr), cnum (int), flag (int), ## pcttest (int), api00 (int), api99 (int), target (int), growth (int), ## sch.wide (fct), comp.imp (fct), both (fct), awards (fct), meals ## (int), ell (int), yr.rnd (fct), mobility (int), acs.k3 (int), acs.46 ## (int), acs.core (int), pct.resp (int), not.hsg (int), hsg (int), ## some.col (int), col.grad (int), grad.sch (int), avg.ed (dbl), full ## (int), emer (int), enroll (int), api.stu (int), pw (dbl), fpc (dbl) Instead of data frames or tibbles, {srvyr} functions are meant for tbl_svy objects. Attempting to run data manipulation on non-tbl_svy objects will result in an error, as shown in the example below when using the mtcars data frame (which is not tbl_svy object). mtcars %&gt;% summarize(mpg_mean = survey_mean(mpg)) ## Error in `summarize()`: ## ℹ In argument: `mpg_mean = survey_mean(mpg)`. ## Caused by error in `cur_svy()`: ## ! Survey context not set A few functions in {srvyr} parallel functions in {dplyr}, such as srvyr::summarize() and srvyr::group_by(). Unlike {srvyr}-specific verbs, the package recognizes these parallel functions on a non-survey object. It will not error and instead give the equivalent output from {dplyr}: mtcars %&gt;% srvyr::summarize(mpg_mean = mean(mpg)) ## mpg_mean ## 1 20.09 Because this book focuses on survey analysis, most of our pipes will stem from a survey object. We will not include the namespace for each function (e.g., srvyr::summarize()). Several functions in {srvyr} must be called within srvyr::summarize() with the exception of srvyr::survey_count() and srvyr::survey_tally() much like dplyr::count() and dplyr::tally() are not called within dplyr::summarize(). These verbs can be used in conjunction with group_by() or by/.by, applying the functions on a group-by-group basis to create grouped summaries. mtcars %&gt;% group_by(cyl) %&gt;% dplyr::summarize(mpg_mean = mean(mpg)) ## # A tibble: 3 × 2 ## cyl mpg_mean ## &lt;dbl&gt; &lt;dbl&gt; ## 1 4 26.7 ## 2 6 19.7 ## 3 8 15.1 We use a similar setup to summarize data in {srvyr}. dstrata %&gt;% group_by(stype) %&gt;% summarize(api00_mean = survey_mean(api00), api00_median = survey_median(api00)) ## # A tibble: 3 × 5 ## stype api00_mean api00_mean_se api00_median api00_median_se ## &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 E 674. 12.5 671 20.7 ## 2 H 626. 15.5 635 21.6 ## 3 M 637. 16.6 648 24.1 5.3 Counts and Cross-Tabulations With survey_count() and survey_tally(), we can calculate the estimated population counts for a given variable or combination of variables. Sometimes, these are referred to as cross-tabulations or crosstabs, for short. These summaries should be applied to categorical data and are used to get estimated counts of the population size of groups from the survey. 5.3.1 Syntax The syntax for survey_count() is very similar to the dplyr::count() syntax; however, as noted above, it can only be called on tbl_svy objects. Let’s explore the syntax: survey_count( x, ..., wt = NULL, sort = FALSE, name = &quot;n&quot;, .drop = dplyr::group_by_drop_default(x), vartype = c(&quot;se&quot;, &quot;ci&quot;, &quot;var&quot;, &quot;cv&quot;) ) The arguments are: x: a tbl_svy object created by as_survey ...: variables to group by, passed to group_by wt: a variable to weight on in addition to the survey weights, defaults to NULL sort: how to sort the variables, defaults to FALSE name: the name of the count variable, defaults to n .drop: whether to drop empty groups vartype: type(s) of variation estimate to calculate including any of c(\"se\", \"ci\", \"var\", \"cv\"), defaults to se (standard error) (see 5.3.1 for more information) To capture a count or crosstabs by different variables, we include them in the (...) argument. This argument can take any number of variables and will break down the counts by all combinations of the provided variables. This is the same as with dplyr::count(). We can also obtain an estimate of the overall population by not including any variables in the (...) argument or by using the survey_tally() function. The survey_tally() function has a similar syntax to the survey_count() function, but it does not include the (...) or the .drop arguments: survey_tally( x, wt, sort = FALSE, name = &quot;n&quot;, vartype = c(&quot;se&quot;, &quot;ci&quot;, &quot;var&quot;, &quot;cv&quot;) ) Both functions include the vartype argument with four different values: se: standard error The estimated standard deviation of the estimate Output has a column with the variable name specified in the name argument with a suffix of “_se” ci: confidence interval The lower and upper limits of a confidence interval Output has a column with the variable name specified in the name argument with a suffix of “_low” and “_upp” By default, this is a 95% confidence interval but can be changed by using the argument level and specifying a number between 0 and 1. For example, level=0.8 would produce a 80% confidence interval. var: variance The estimated variance of the estimate Output has a column with the variable name specified in the name argument with a suffix of “_var” cv: coefficient of variation A ratio of the standard error and the estimate Output has a column with the variable name specified in the name argument with a suffix of “_cv” The confidence intervals are always calculated using a symmetric t-distribution based confidence interval as follows: \\[ \\text{estimate} \\pm t^*_{df}\\times SE\\] where \\(t^*_{df}\\) is the critical value from a t-distribution based on the confidence level and the degrees of freedom. By default, the degrees of freedom are calculated based on the design or number of replicates, but they can be specified using the argument df. For survey design objects, the degrees of freedom are calculated as the number of PSUs minus the number of strata. For replicate-based objects, the degrees of freedom are calculated as one less than the rank of the matrix of replicate weight, where the number of replicates is typically the rank. Note that specifying df = Inf is equivalent to using a normal (z-based) confidence interval. These variability types are the same for most of the survey functions, and we will provide examples using different types of variability throughout this chapter. 5.3.2 Examples Example 1: Estimated Population Count If we wanted to obtain the estimated number of households in the U.S. (the target population) using the Residential Energy Consumption Survey (RECS) data, we could use survey_count(). If we do not specify any variables in the survey_count() function, it will output the estimated population count (n) and standard error (n_se). recs_des %&gt;% survey_count() ## # A tibble: 1 × 2 ## n n_se ## &lt;dbl&gt; &lt;dbl&gt; ## 1 118208250. 0.0320 Thus, the estimated number of households in the U.S. is 118,208,250. We could also use the survey_tally() function and the example below yields the same results as using survey_count() previously. recs_des %&gt;% survey_tally() ## # A tibble: 1 × 2 ## n n_se ## &lt;dbl&gt; &lt;dbl&gt; ## 1 118208250. 0.0320 Example 2: Estimated Counts by Subgroups (Crosstabs) To calculate the estimated number of observations for subgroups, such as Region and Division, we can add the variables of interest into the survey_count() function. In the example below, the estimated number of housing units by region and division is calculated. Additionally, one of the arguments allows us to change the name of the count variable from the default (n) using name =. In this case, we are changing the name to \"N\". recs_des %&gt;% survey_count(Region, Division, name = &quot;N&quot;) ## # A tibble: 10 × 4 ## Region Division N N_se ## &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Northeast New England 5628844. 0.00642 ## 2 Northeast Middle Atlantic 15377694. 0.000130 ## 3 Midwest East North Central 18094391. 0.000274 ## 4 Midwest West North Central 8277344. 0.000113 ## 5 South South Atlantic 23474851. 0.00555 ## 6 South East South Central 7197189. 0.0240 ## 7 South West South Central 13769934. 0.000423 ## 8 West Mountain North 4246877. 0.000147 ## 9 West Mountain South 4266870. 0.0193 ## 10 West Pacific 17874256. 0.000481 When we run the crosstab, we see there are an estimated 5,628,844 housing units in the New England Division. If we wanted to use survey_tally() to output the same results, we would get an error if we try to use the same syntax as survey_count(): recs_des %&gt;% survey_tally(Region, Division, name = &quot;N&quot;) ## Error in `dplyr::summarise()`: ## ℹ In argument: `N = survey_total(Region, vartype = vartype, ## na.rm = TRUE)`. ## Caused by error: ## ! Factor not allowed in survey functions, should be used as a grouping variable. Instead, use a the group_by() function prior to using survey_tally() to obtain this crosstab: recs_des %&gt;% group_by(Region, Division) %&gt;% survey_tally(name = &quot;N&quot;) ## # A tibble: 10 × 4 ## # Groups: Region [4] ## Region Division N N_se ## &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Northeast New England 5628844. 0.00642 ## 2 Northeast Middle Atlantic 15377694. 0.000130 ## 3 Midwest East North Central 18094391. 0.000274 ## 4 Midwest West North Central 8277344. 0.000113 ## 5 South South Atlantic 23474851. 0.00555 ## 6 South East South Central 7197189. 0.0240 ## 7 South West South Central 13769934. 0.000423 ## 8 West Mountain North 4246877. 0.000147 ## 9 West Mountain South 4266870. 0.0193 ## 10 West Pacific 17874256. 0.000481 5.4 Totals and Sums The survey_total() function is analogous to sum. This can be used to find the estimated aggregate sum of an outcome and should be applied to continuous variables to obtain the estimated total quantity in a population. All the functions introduced from this point on in this chapter must be called from within summarize(). 5.4.1 Syntax Here is the syntax: survey_total( x, na.rm = FALSE, vartype = c(&quot;se&quot;, &quot;ci&quot;, &quot;var&quot;, &quot;cv&quot;), level = 0.95, deff = FALSE, df = NULL ) The arguments are: x: a variable, expression, or empty na.rm: an indicator of whether missing values should be dropped, defaults to FALSE vartype: type(s) of variation estimate to calculate including any of c(\"se\", \"ci\", \"var\", \"cv\"), defaults to se (standard error) (see 5.3.1 for more information) level: a number or a vector indicating the confidence level, defaults to 0.95 deff: a logical value stating whether the design effect should be returned, defaults to FALSE (this is described in more detail in Section 5.10.3) df: (for vartype = 'ci'), a numeric value indicating degrees of freedom for the t-distribution 5.4.2 Examples Example 1: Estimated Population Count To calculate a population count estimate with survey_total(), the argument x can be left empty as shown in the example below: recs_des %&gt;% summarize(survey_total()) ## # A tibble: 1 × 2 ## coef `_se` ## &lt;dbl&gt; &lt;dbl&gt; ## 1 118208250. 0.0320 Note that the result from recs_des %&gt;% summarize(survey_total()) is equivalent to the survey_count() and survey_tally() functions. However, the survey_total() function is called within summarize, whereas survey_count() and survey_tally() are not. Example 2: Overall Summation of Continuous Variables The difference between survey_total() and survey_count() is more evident when specifying continuous variables to sum. Let’s compute the total cost of electricity in whole dollars from variable DOLLAREL14. recs_des %&gt;% summarize(elec_bill = survey_total(DOLLAREL)) ## # A tibble: 1 × 2 ## elec_bill elec_bill_se ## &lt;dbl&gt; &lt;dbl&gt; ## 1 162495237023. 1666895091. It is estimated that American residential households spent a total of $162,495,237,023 on electricity in 2015, and the estimate has a standard error of $1,666,895,091. Example 3: Summation by Groups As we are using the {srvyr} package, we can use group_by() to calculate the cost of electricity by different groups. Let’s see how much the cost of electricity in whole dollars differed between regions and output the confidence interval instead of the default standard error. recs_des %&gt;% group_by(Region) %&gt;% summarize(elec_bill = survey_total(DOLLAREL, vartype = &quot;ci&quot;)) ## # A tibble: 4 × 4 ## Region elec_bill elec_bill_low elec_bill_upp ## &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Northeast 28271369286. 26845972323. 29696766249. ## 2 Midwest 31527659004. 30468473687. 32586844321. ## 3 South 72463508778. 70230847218. 74696170337. ## 4 West 30232699955. 28542681631. 31922718279. The survey results estimate that households in the Northeast spent $28,271,369,286 with a confidence interval of ($26,845,972,323, $29,696,766,249) on electricity in 2015 while households in the South spent an estimated $72,463,508,778 with a confidence interval of ($26,845,972,323, $74,696,170,337). 5.5 Means and Proportions Means and proportions are the backbone of most research. The estimates calculated are often the first things we look for when reviewing research on a given topic. The survey_mean() and survey_prop() functions calculate means and proportions while incorporating the survey design elements. The survey_mean() function should be used on continuous variables of survey data, while the survey_prop() function should be used on categorical variables. These topics are grouped together because a proportion is simply a mean of a logical (Boolean) variable. 5.5.1 Syntax The syntax for both means and proportions are very similar: survey_mean( x, na.rm = FALSE, vartype = c(&quot;se&quot;, &quot;ci&quot;, &quot;var&quot;, &quot;cv&quot;), level = 0.95, proportion = FALSE, prop_method = c(&quot;logit&quot;, &quot;likelihood&quot;, &quot;asin&quot;, &quot;beta&quot;, &quot;mean&quot;), deff = FALSE, df = NULL ) survey_prop( na.rm = FALSE, vartype = c(&quot;se&quot;, &quot;ci&quot;, &quot;var&quot;, &quot;cv&quot;), level = 0.95, proportion = TRUE, prop_method = c(&quot;logit&quot;, &quot;likelihood&quot;, &quot;asin&quot;, &quot;beta&quot;, &quot;mean&quot;, &quot;xlogit&quot;), deff = FALSE, df = NULL ) Both functions have the following arguments and defaults: na.rm: an indicator of whether missing values should be dropped, defaults to FALSE vartype: type(s) of variation estimate to calculate including any of c(\"se\", \"ci\", \"var\", \"cv\"), defaults to se (standard error) (see 5.3.1 for more information) level: a number or a vector indicating the confidence level, defaults to 0.95 prop_method: Method to calculate the confidence interval for confidence intervals deff: a logical value stating whether the design effect should be returned, defaults to FALSE (this is described in more detail in Section 5.10.3) df: (for vartype = 'ci'), a numeric value indicating degrees of freedom for the t-distribution There are two main differences in the syntax. The survey_mean() function includes the first argument of x, while survey_prop() does not. The x argument includes the variable or expression on which the mean should be calculated. There is no argument to include variables in the survey_prop() function. Instead, prior to summarize(), we need to use the group_by() function to specify the variables of interest. For survey_mean(), including a group_by() function will allow us to obtain the means by the different groups. The other main difference is with the proportion argument. In the survey_mean() function, this defaults to FALSE, while in the survey_prop() function, this defaults to TRUE. This is because the survey_mean() function can be used to calculate both means and proportions. If we wish to calculate a proportion using this function, we will need to set the proportion argument to TRUE. In section 5.3.1, we provide an overview of the different variability types. The interval used in confidence intervals for most measures, such as means and counts, is referred to as a Wald-type interval. While a Wald-type interval using a symmetric t-based confidence interval is an option for proportions, this generally does not have the correct coverage rate when sample sizes are small and/or the proportion is “near” 0 or 1. Thus, other methods have been developed to calculate confidence intervals and can be specified using the prop_method option in survey_prop(). The options include: logit: fits a logistic regression model and computes a Wald-type interval on the log-odds scale, which is then transformed to the probability scale. This is the default method. likelihood: uses the (Rao-Scott) scaled chi-squared distribution for the log-likelihood from a binomial distribution. asin: uses the variance-stabilizing transformation for the binomial distribution, the arcsine square root, and then back-transforms the interval to the probability scale beta: uses the incomplete beta function with an effective sample size based on the estimated variance of the proportion. mean: the Wald-type interval xlogit: uses a logit transformation of the proportion, calculates a Wald-type interval, and then back-transforms to the probability scale. This method is implemented in SUDAAN and SPSS. Each option will provide slightly different confidence interval bounds when dealing with proportions. Please note that when working with survey_mean(), this method does not need to be specified unless the proprtion argument is TRUE. 5.5.2 Examples Example 1: One Variable Proportion If we are interested in obtaining the proportion of people in each region in the RECS data, we can use group_by() and survey_prop() to obtain this. recs_des %&gt;% group_by(Region) %&gt;% summarize(p = survey_prop()) ## When `proportion` is unspecified, `survey_prop()` now defaults to `proportion = TRUE`. ## ℹ This should improve confidence interval coverage. ## This message is displayed once per session. ## # A tibble: 4 × 3 ## Region p p_se ## &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Northeast 0.178 6.84e-11 ## 2 Midwest 0.223 6.07e-11 ## 3 South 0.376 1.43e-10 ## 4 West 0.223 1.37e-10 17.8% of the households are in the Northeast, 22.3% in the Midwest, and so on. Note: survey_prop() is essentially the same as using survey_mean() with a categorical variable and without specifying a numeric variable in the x argument. The following code will give us the same results as above: recs_des %&gt;% group_by(Region) %&gt;% summarize(p = survey_mean()) ## # A tibble: 4 × 3 ## Region p p_se ## &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Northeast 0.178 6.84e-11 ## 2 Midwest 0.223 6.07e-11 ## 3 South 0.376 1.43e-10 ## 4 West 0.223 1.37e-10 Example 2: Conditional Proportions It is possible to obtain proportions by more than one variable. In the following example, we look at the proportion of housing units by Region and whether air conditioning is used (ACUsed).15 recs_des %&gt;% group_by(Region, ACUsed) %&gt;% summarize(p = survey_prop()) ## # A tibble: 8 × 4 ## # Groups: Region [4] ## Region ACUsed p p_se ## &lt;fct&gt; &lt;lgl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Northeast FALSE 0.151 0.0200 ## 2 Northeast TRUE 0.849 0.0200 ## 3 Midwest FALSE 0.0766 0.00957 ## 4 Midwest TRUE 0.923 0.00957 ## 5 South FALSE 0.0511 0.00649 ## 6 South TRUE 0.949 0.00649 ## 7 West FALSE 0.301 0.0298 ## 8 West TRUE 0.699 0.0298 When specifying multiple variables, the proportions are conditional. In the results above, notice that the proportions sum to 1 within each region. This can be interpreted as the proportion of housing units with air conditioning within each region. Example 3: Joint Proportions If we want the joint proportion instead, the interact function is necessary. In the example below, the interact function is used on Region and ACUsed: recs_des %&gt;% group_by(interact(Region, ACUsed)) %&gt;% summarize(p = survey_prop()) ## # A tibble: 8 × 4 ## Region ACUsed p p_se ## &lt;fct&gt; &lt;lgl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Northeast FALSE 0.0268 0.00355 ## 2 Northeast TRUE 0.151 0.00355 ## 3 Midwest FALSE 0.0171 0.00214 ## 4 Midwest TRUE 0.206 0.00214 ## 5 South FALSE 0.0192 0.00244 ## 6 South TRUE 0.357 0.00244 ## 7 West FALSE 0.0672 0.00665 ## 8 West TRUE 0.156 0.00665 As noted earlier, both the survey_prop() and survey_mean() functions can be used here and will provide the same results. Example 4: Overall Mean We can calculate the estimated average cost of electricity in the U.S. and include both the standard error and the confidence interval: recs_des %&gt;% summarize(elec_bill = survey_mean(DOLLAREL, vartype = c(&quot;se&quot;, &quot;ci&quot;))) ## # A tibble: 1 × 4 ## elec_bill elec_bill_se elec_bill_low elec_bill_upp ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1375. 14.1 1347. 1403. Nationally, the average household spent $$1,375 in 2015. Example 5: Means by Subgroup We can also calculate the estimated average cost of electricity in the U.S. by each region. To do this, we include a group_by() function with the variable of interest before the summarize() function: recs_des %&gt;% group_by(Region) %&gt;% summarize(elec_bill = survey_mean(DOLLAREL)) ## # A tibble: 4 × 3 ## Region elec_bill elec_bill_se ## &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Northeast 1346. 34.2 ## 2 Midwest 1196. 20.2 ## 3 South 1631. 25.3 ## 4 West 1146. 32.3 Households from the West spent $1,146 on electricity, and in the South, they spent an average of $1,631. 5.6 Quantiles and Medians To better understand the distribution of a continuous variable, quantiles can be calculated at specific points to help gain insight. For example, we might want estimates of the quartiles (25%, 50%, 75%) of income in a population to understand how the income is distributed. We use the survey_quantile() function to calculate quantiles in survey data. Medians are often used to find the midpoint of a continuous distribution when the data is considered to be skewed, as medians are less subject to outliers than means. The median in the data is the same as the 50th percentile. In other words, it is the value where 50% of the data is higher than it and 50% is lower. Medians are a special case of quantiles that are used more often; thus, a unique function has been created for it (survey_median()). We can calculate the median of the data using both the survey_median() function and the survey_quantile() function with the 50% quantile provided as an argument. 5.6.1 Syntax The syntax for survey_quantile() and survey_median() are nearly identical: survey_quantile( x, quantiles, na.rm = FALSE, vartype = c(&quot;se&quot;, &quot;ci&quot;, &quot;var&quot;, &quot;cv&quot;), level = 0.95, interval_type = c(&quot;mean&quot;, &quot;beta&quot;, &quot;xlogit&quot;, &quot;asin&quot;, &quot;score&quot;, &quot;quantile&quot;), qrule = c(&quot;math&quot;, &quot;school&quot;, &quot;shahvaish&quot;, &quot;hf1&quot;, &quot;hf2&quot;, &quot;hf3&quot;, &quot;hf4&quot;, &quot;hf5&quot;, &quot;hf6&quot;, &quot;hf7&quot;, &quot;hf8&quot;, &quot;hf9&quot;), df = NULL ) survey_median( x, na.rm = FALSE, vartype = c(&quot;se&quot;, &quot;ci&quot;, &quot;var&quot;, &quot;cv&quot;), level = 0.95, interval_type = c(&quot;mean&quot;, &quot;beta&quot;, &quot;xlogit&quot;, &quot;asin&quot;, &quot;score&quot;, &quot;quantile&quot;), qrule = c(&quot;math&quot;, &quot;school&quot;, &quot;shahvaish&quot;, &quot;hf1&quot;, &quot;hf2&quot;, &quot;hf3&quot;, &quot;hf4&quot;, &quot;hf5&quot;, &quot;hf6&quot;, &quot;hf7&quot;, &quot;hf8&quot;, &quot;hf9&quot;), df = NULL ) The arguments that are in both functions are: x: a variable, expression, or empty na.rm: an indicator of whether missing values should be dropped, defaults to FALSE vartype: type(s) of variation estimate to calculate, defaults to se (standard error) level: a number or a vector indicating the confidence level, defaults to 0.95 interval_type: method for calculating a confidence interval qrule: rule for defining quantiles. The default is the lower end of the quantile interval (“math”). The midpoint of the quantile interval is the “school” rule. “hf1” to “hf9” are weighted analogs to type=1 to 9 in quantile(). “shahvaish” corresponds to a rule proposed by Shah and Vaish (2006). See vignette(\"qrule\", package=\"survey\") for more information. df: (for vartype = 'ci'), a numeric value indicating degrees of freedom for the t-distribution The only difference between survey_quantile() and survey_median() is the inclusion of the quantiles argument in the survey_quantile() function. This argument takes a vector with values between 0 and 1 to indicate which quantiles to calculate. For example, if we wanted the quartiles of a variable, we would provide quantiles = c(0.25, 0.5, 0.75). While we can specify quantiles of 0 and 1, which represent the minimum and maximum, this is not recommended. It only returns the minimum and maximum of the respondents and cannot be extrapolated to the population as there is no valid definition of standard error. In section 5.3.1, we provide an overview of the different variability types. The interval used in confidence intervals for most measures, such as means and counts, is referred to as a Wald-type interval. However, like confidence intervals for proportions, this is not always the most accurate interval for quantiles. With quantiles, the methods for interval types are many of the same as those for proportions (asin, beta, mean, and xlogit; see section 5.5.1) with the addition of two more methods: score: the Francisco &amp; Fuller confidence interval based on inverting a score test (only available for design-based survey objects and not replicate-based objects) quantile: based on the replicates of the quantile. This is not valid for jackknife-type replicates but is available for bootstrap and BRR replicates. One thing of note with the score method is that when there are many ties in the data, this method can produce confidence intervals that do not contain the estimate. When dealing with a high propensity for ties (e.g., many respondents will have the same age), it is recommended to use another method. This is the method implemented in SUDAAN. However, SUDAAN adds noise to the values to prevent the issue with the ties, while the documentation in the {survey} package indicates this method generally has lower performance than the beta and logit intervals. 5.6.2 Examples Example 1: Overall Quartiles Quantiles are useful in learning about the distribution of a variable. Let’s look into the quartiles, specifically, the first quartile (p=0.25), the median (p=0.5), and the third quartile (p=0.75) of electric bills. recs_des %&gt;% summarize(elec_bill = survey_quantile(DOLLAREL, quantiles = c(0.25, 0.5, 0.75))) ## # A tibble: 1 × 6 ## elec_bill_q25 elec_bill_q50 elec_bill_q75 elec_bill_q25_se ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 795 1219. 1790. 12.5 ## # ℹ 2 more variables: elec_bill_q50_se &lt;dbl&gt;, elec_bill_q75_se &lt;dbl&gt; The output above shows the three quartiles and their respective standard errors. Example 2: Quartiles by Subgroup We can also estimate the quantiles of electric bills by region by incorporating the group_by() function: recs_des %&gt;% group_by(Region) %&gt;% summarize(elec_bill = survey_quantile(DOLLAREL, quantiles = c(0.25, 0.5, 0.75))) ## # A tibble: 4 × 7 ## Region elec_bill_q25 elec_bill_q50 elec_bill_q75 elec_bill_q25_se ## &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Northeast 749. 1190. 1741. 19.4 ## 2 Midwest 738. 1067. 1524. 24.2 ## 3 South 1041 1503. 2091. 21.7 ## 4 West 605. 941. 1502. 18.8 ## # ℹ 2 more variables: elec_bill_q50_se &lt;dbl&gt;, elec_bill_q75_se &lt;dbl&gt; Example 3: Minimum and Maximum As mentioned in the syntax section, we can specify quantiles of 0 (minimum) and 1 (maximum). R will calculate these two values and provide results. However, these are only the minimum and maximum values in the data. There is not sufficient information to determine what the standard errors should be: recs_des %&gt;% summarize(elec_bill = survey_quantile(DOLLAREL, quantiles = c(0, 1))) ## # A tibble: 1 × 4 ## elec_bill_q00 elec_bill_q100 elec_bill_q00_se elec_bill_q100_se ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 21.8 8122. NaN 0 Example 4: Overall Median We can calculate the estimated median cost of electricity in the U.S. using the survey_median() function: recs_des %&gt;% summarize(elec_bill = survey_median(DOLLAREL)) ## # A tibble: 1 × 2 ## elec_bill elec_bill_se ## &lt;dbl&gt; &lt;dbl&gt; ## 1 1219. 17.3 Nationally, the median household spent $1,219 in 2015. This is the same result as we obtained using the survey_quantile() function ($1,219). It is also interesting to note that the average electric bill for households that we calculated in section 5.5 is $1,375, but the estimated median electric bill is $1,219 indicating the distribution is likely right-skewed. Example 5: Medians by Subgroup We can also calculate the estimated median cost of electricity in the U.S. by each region. This is similar to finding the mean by region in that we include a group_by() function with the variable of interest before the summarize() function: recs_des %&gt;% group_by(Region) %&gt;% summarize(elec_bill = survey_median(DOLLAREL)) ## # A tibble: 4 × 3 ## Region elec_bill elec_bill_se ## &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Northeast 1190. 36.3 ## 2 Midwest 1067. 28.0 ## 3 South 1503. 28.0 ## 4 West 941. 28.8 Households from the West spent $941 on electricity, and in the South, they spent an average of $1,503. 5.7 Ratios Many are not familiar with the ratio estimate. The ratio is a measure of the ratio of the sum of two variables, specifically in the form of: \\[ \\frac{\\sum x_i}{\\sum y_i}.\\] The ratio is not the same as calculating the following: \\[ \\frac{1}{N} \\sum \\frac{x_i}{y_i} \\] which could be calculated with survey_mean() by creating a derived variable \\(z=x/y\\) and then calculating the mean of \\(z\\). Consider a survey of police agencies in the United States. We might want to estimate the ratio of female police officers to total police officers. We could run survey_ratio(Female_Officers, Total_Officers). If, instead, we used survey_means(Female_Officers/Total_Officers), we would be estimating the average percentage of female officers across agencies, which is a different quantity. 5.7.1 Syntax The syntax for survey_ratio() is as follows: survey_ratio( numerator, denominator, na.rm = FALSE, vartype = c(&quot;se&quot;, &quot;ci&quot;, &quot;var&quot;, &quot;cv&quot;), level = 0.95, deff = FALSE, df = NULL ) The arguments are: numerator: The numerator of the ratio denominator: The denominator of the ratio na.rm: A logical value to indicate whether missing values should be dropped vartype: type(s) of variation estimate to calculate including any of c(\"se\", \"ci\", \"var\", \"cv\"), defaults to se (standard error) (see 5.3.1 for more information) level: A single number or vector of numbers indicating the confidence level deff: A logical value to indicate whether the design effect should be returned (this is described in more detail in Section 5.10.3) df: (For vartype = “ci” only) A numeric value indicating the degrees of freedom for t-distribution 5.7.2 Examples Example 1: Overall Ratios Suppose we wanted to find the ratio of dollars spent on liquid propane per unit (in British thermal unit [Btu]) nationally. If we wanted to find the average cost to a household, we could use survey_mean(), but to find the national unit rate, we can use ratio. In the following example, we will show both methods and discuss the interpretation of each: recs_des %&gt;% summarize(DOLLARLP_Tot = survey_total(DOLLARLP, vartype = NULL), BTULP_Tot = survey_total(BTULP, vartype = NULL), DOL_BTU_Rat = survey_ratio(DOLLARLP, BTULP), DOL_BTU_Avg = survey_mean(DOLLARLP/BTULP, na.rm = TRUE)) ## # A tibble: 1 × 6 ## DOLLARLP_Tot BTULP_Tot DOL_BTU_Rat DOL_BTU_Rat_se DOL_BTU_Avg ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 7759788903. 360915832595. 0.0215 0.000602 0.0242 ## # ℹ 1 more variable: DOL_BTU_Avg_se &lt;dbl&gt; The ratio of the total spent on liquid propane to the total consumption was 0.0215, but the average rate was 0.0242. With a bit of calculation, we can show that the ratio is the ratio of the totals DOLLARLP_Tot/BTULP_Tot=7,759,788,903/360,915,832,595=0.0215. While the ratio could be calculated manually in this manner, the standard error requires the use of the survey_ratio() function. The average can be interpreted as the average rate paid by a household. Example 2: Ratios by Subgroup As previously done with other estimates, we can use group_by() to examine whether this rate varies by region. recs_des %&gt;% group_by(Region) %&gt;% summarize(DOL_BTU_Rat = survey_ratio(DOLLARLP, BTULP)) ## # A tibble: 4 × 3 ## Region DOL_BTU_Rat DOL_BTU_Rat_se ## &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Northeast 0.0263 0.000888 ## 2 Midwest 0.0167 0.000371 ## 3 South 0.0218 0.000986 ## 4 West 0.0232 0.000912 Though not a statistical test, it does appear the cost rates in the Midwest for liquid propane are the lowest. 5.8 Correlations The correlation is a measure of linear relationship between two continuous variables, which ranges between -1 and 1. The most common one used is Pearson’s correlation (referred to as correlation henceforth). A sample correlation for a simple random sample is calculated as follows: \\[\\frac{\\sum (x_i-\\bar{x})(y_i-\\bar{y})}{\\sqrt{\\sum (x_i-\\bar{x})^2} \\sqrt{\\sum(y_i-\\bar{y})^2}} \\] When using survey_corr() for designs other than a simple random sample, the weights are applied when estimating the correlation. 5.8.1 Syntax The syntax for survey_corr() is as follows: survey_corr( x, y, na.rm = FALSE, vartype = c(&quot;se&quot;, &quot;ci&quot;, &quot;var&quot;, &quot;cv&quot;), level = 0.95, df = NULL ) The arguments are: x: A variable or expression y: A variable or expression na.rm: A logical value to indicate whether missing values should be dropped vartype: type(s) of variation estimate to calculate including any of c(\"se\", \"ci\", \"var\", \"cv\"), defaults to se (standard error) (see 5.3.1 for more information) level: (For vartype = “ci” only) A single number or vector of numbers indicating the confidence level df: (For vartype = “ci” only) A numeric value indicating the degrees of freedom for t-distribution 5.8.2 Examples Example 1: Overall Correlation We can calculate the correlation between total square footage (TOTSQFT_EN)16 and electricity consumption (BTUEL)17. recs_des %&gt;% summarize(SQFT_Elec_Corr = survey_corr(TOTSQFT_EN, BTUEL)) ## # A tibble: 1 × 2 ## SQFT_Elec_Corr SQFT_Elec_Corr_se ## &lt;dbl&gt; &lt;dbl&gt; ## 1 0.367 0.0172 Example 2: Correlations by Subgroup Like with other statistics, we can do this by subgroups. For example, we can examine the correlation by whether air conditioning is used (ACUsed). recs_des %&gt;% group_by(ACUsed) %&gt;% summarize(SQFT_Elec_Corr = survey_corr(TOTSQFT_EN, DOLLAREL)) ## # A tibble: 2 × 3 ## ACUsed SQFT_Elec_Corr SQFT_Elec_Corr_se ## &lt;lgl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 FALSE 0.327 0.0468 ## 2 TRUE 0.384 0.0189 5.9 Standard Deviation and Variance All survey functions produce an estimate of the variability of a given estimate. No additional function is needed when dealing with variable estimates. However, if estimates of the population variance and population standard deviation are needed, we can use the survey_var() and survey_sd() functions. In our experience, most researchers will not use these functions. These are sometimes used when designing a future study, as understanding the variability in the population can help inform the precision of a future sampling design. 5.9.1 Syntax As with non-survey data, the standard deviation estimate is the square root of the variance estimate, and thus, the functions have the same arguments, except the standard deviation does not allow the usage of vartype. survey_var( x, na.rm = FALSE, vartype = c(&quot;se&quot;, &quot;ci&quot;, &quot;var&quot;), level = 0.95, df = NULL ) survey_sd( x, na.rm = FALSE ) The arguments are: x: A variable or expression, or empty na.rm: A logical value to indicate whether missing values should be dropped vartype: type(s) of variation estimate to calculate including any of c(\"se\", \"ci\", \"var\"), defaults to se (standard error) (see 5.3.1 for more information) level: (For vartype = “ci” only) A single number or vector of numbers indicating the confidence level. df: (For vartype = “ci” only) A numeric value indicating the degrees of freedom for t-distribution 5.9.2 Examples Example 1: Overall Variability Returning to electricity bills, we look at the variability in electricity expenditure. recs_des %&gt;% summarize(var_elbill = survey_var(DOLLAREL), sd_elbill = survey_sd(DOLLAREL)) ## Warning: There were 2 warnings in `dplyr::summarise()`. ## The first warning was: ## ℹ In argument: `var_elbill = survey_var(DOLLAREL)`. ## Caused by warning in `thetas - meantheta`: ## ! Recycling array of length 1 in vector-array arithmetic is deprecated. ## Use c() or as.vector() instead. ## ℹ Run `dplyr::last_dplyr_warnings()` to see the 1 remaining warning. ## # A tibble: 1 × 3 ## var_elbill var_elbill_se sd_elbill ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 647540. 27163. 805. A warning message may be displayed if using a replicate design. The results are still valid. The results above give an estimate of the population variance of electricity bills (var_elbill), the standard error of that variance (var_elbill_se), and the estimated population standard deviation of electricity bills (sd_elbill). Note that no standard error is associated with the standard deviation - this is the only estimate that does not include a standard error. Example 2: Variability by Subgroup Like other estimates, we can calculate the variance by region. This would be useful to learn if the variability is similar across regions: recs_des %&gt;% group_by(Region) %&gt;% summarize(var_elbill = survey_var(DOLLAREL), sd_elbill = survey_sd(DOLLAREL)) ## Warning: There were 8 warnings in `dplyr::summarise()`. ## The first warning was: ## ℹ In argument: `var_elbill = survey_var(DOLLAREL)`. ## ℹ In group 1: `Region = Northeast`. ## Caused by warning in `thetas - meantheta`: ## ! Recycling array of length 1 in vector-array arithmetic is deprecated. ## Use c() or as.vector() instead. ## ℹ Run `dplyr::last_dplyr_warnings()` to see the 7 remaining warnings. ## # A tibble: 4 × 4 ## Region var_elbill var_elbill_se sd_elbill ## &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Northeast 714269. 54305. 845. ## 2 Midwest 410548. 26708. 641. ## 3 South 682280. 54320. 826. ## 4 West 578803. 39280. 761. 5.10 Additional Topics 5.10.1 Unweighted Analysis Sometimes, it is helpful to calculate an unweighted estimate of a given variable. For this, we use the unweighted() function in the summarize() function. The unweighted() function calculates unweighted summaries from tbl_svy object, which reflects the summary among the respondents and does not extrapolate to a population estimate. The unweighted function can be used in conjunction with any {dplyr} functions. Here is an example looking at the average household electricity cost. recs_des %&gt;% summarize(elec_bill = survey_mean(DOLLAREL), elec_unweight = unweighted(mean(DOLLAREL))) ## # A tibble: 1 × 3 ## elec_bill elec_bill_se elec_unweight ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1375. 14.1 1404. It is estimated that American residential households spent an average of $1,375 on electricity in 2015, and the estimate has a standard error of $14. The unweighted function calculates the unweighted average and illustrates the average amount of money the respondents spent on electricity in 2015, which was $1,404. 5.10.2 Subpopulation Analysis Briefly, we mentioned using filter() to subset a survey object for analysis. This operation should be done after creating the design object. In rare circumstances, subsetting data before creating the object can lead to incorrect variability estimates. This can occur if subsetting removes an entire PSU. Suppose we wanted estimates of the average amount spent on natural gas among housing units that use natural gas. This could be obtained by first filtering records to only include records where BTUNG &gt; s0 and then finding the average amount of money spent. recs_des %&gt;% filter(BTUNG &gt; 0) %&gt;% summarize(NG_mean = survey_mean(DOLLARNG, vartype = c(&quot;se&quot;, &quot;ci&quot;))) ## # A tibble: 1 × 4 ## NG_mean NG_mean_se NG_mean_low NG_mean_upp ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 601. 9.49 582. 620. Note that this yields a higher mean than when not applying the filter. When including housing units that do not use natural gas, many $0 amounts are included in the mean calculation. recs_des %&gt;% summarize(NG_mean = survey_mean(DOLLARNG, vartype = c(&quot;se&quot;, &quot;ci&quot;))) ## # A tibble: 1 × 4 ## NG_mean NG_mean_se NG_mean_low NG_mean_upp ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 349. 9.04 331. 367. 5.10.3 Design Effects The design effect measures how the precision of an estimate is impacted by the sampling design. A design effect is calculated as the ratio of the variance of an estimate under the design at hand to the variance of the estimate under a simple random sample without replacement (SRS). A design effect less than 1 indicates that the design is more statistically efficient than a SRS design. This is rare but possible in a stratified sampling design where the outcome is correlated with the stratification variable(s). A design effect greater than 1 indicates that the design is less statistically efficient than a SRS design. From a design effect, we can calculate the effective sample size as follows: \\[n_{eff}=\\frac{n}{D_{eff}} \\] where \\(n\\) is the nominal sample size (number of survey responses) and \\(D_{eff}\\) is the estimated design effect. The effective sample size has an interesting interpretation that a survey using an SRS design would need a sample size of \\(n_{eff}\\) to obtain the same precision as the design at hand, which is where the efficiency interpretation comes in. Design effects are outcome-specific — outcomes that are less clustered in the population have smaller design effects than outcomes that are clustered. In the {srvyr} package, design effects can be calculated for totals, proportions, means, and ratio estimates by setting the deff argument to TRUE in the corresponding functions. For example, the design effect can be calculated for the average consumption of electricity (BTUEL), natural gas (BTUNG), liquid propane (BTULP), fuel oil (BTUFO), wood (BTUWOOD), and wood pellets (BTUPELLET). recs_des %&gt;% summarize(across(c(BTUEL, BTUNG, BTULP, BTUFO, BTUWOOD, BTUPELLET), ~survey_mean(.x, deff = TRUE, vartype = NULL))) %&gt;% select(ends_with(&quot;deff&quot;)) ## # A tibble: 1 × 6 ## BTUEL_deff BTUNG_deff BTULP_deff BTUFO_deff BTUWOOD_deff ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1.59 2.39 4.37 1.75 2.17 ## # ℹ 1 more variable: BTUPELLET_deff &lt;dbl&gt; 5.10.4 Creating Summary Rows When using group_by() in analysis, results are returned with a row for each group or group combination. Often, we want both the breakdowns by group and a summary row for the estimate for the entire population. For example, we may want the average electricity consumption by region AND nationally. The {srvyr} package has a function cascade(), which adds summary rows for the total of a group. It is used in place of summarize() and has similar functions along with some additional features. Syntax The syntax is as follows: cascade( .data, ..., .fill = NA, .fill_level_top = FALSE, .groupings = NULL ) where the arguments are: .data: A tbl_svy object ...: Name-value pairs of summary functions (same as the summarize() function) .fill: Value to fill in for group summaries (defaults to NA) .fill_level_top: When filling factor variables, whether to put the value ‘.fill’ in the first position (defaults to FALSE, placing it in the bottom). .groupings: (Experimental) A list of quosures to manually specify the groupings to use, rather than the default. Example First, let’s look at a simple example and then build on it to examine the features of the function. In the first example, all default values are used. recs_des %&gt;% group_by(Region) %&gt;% cascade(DOLLAREL_mn = survey_mean(DOLLAREL)) ## # A tibble: 5 × 3 ## Region DOLLAREL_mn DOLLAREL_mn_se ## &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Northeast 1346. 34.2 ## 2 Midwest 1196. 20.2 ## 3 South 1631. 25.3 ## 4 West 1146. 32.3 ## 5 &lt;NA&gt; 1375. 14.1 The last row where Region = NA is the national average electricity bill. We might wish to have a better name for it and can do that using the .fill argument. recs_des %&gt;% group_by(Region) %&gt;% cascade(DOLLAREL_mn = survey_mean(DOLLAREL), .fill = &quot;National&quot;) ## # A tibble: 5 × 3 ## Region DOLLAREL_mn DOLLAREL_mn_se ## &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Northeast 1346. 34.2 ## 2 Midwest 1196. 20.2 ## 3 South 1631. 25.3 ## 4 West 1146. 32.3 ## 5 National 1375. 14.1 We can also have more than one grouping variable as follows: recs_des %&gt;% group_by(Region, Urbanicity) %&gt;% cascade(DOLLAREL_mn = survey_mean(DOLLAREL), .fill = &quot;Total&quot;) %&gt;% ungroup() ## # A tibble: 17 × 4 ## Region Urbanicity DOLLAREL_mn DOLLAREL_mn_se ## &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Northeast Urban Area 1350. 30.8 ## 2 Northeast Urban Cluster 1123. 113. ## 3 Northeast Rural 1473. 68.6 ## 4 Northeast Total 1346. 34.2 ## 5 Midwest Urban Area 1062. 28.6 ## 6 Midwest Urban Cluster 1163. 64.3 ## 7 Midwest Rural 1623. 54.0 ## 8 Midwest Total 1196. 20.2 ## 9 South Urban Area 1581. 34.3 ## 10 South Urban Cluster 1377. 59.7 ## 11 South Rural 1879. 65.8 ## 12 South Total 1631. 25.3 ## 13 West Urban Area 1110. 34.6 ## 14 West Urban Cluster 1134. 69.7 ## 15 West Rural 1363. 83.0 ## 16 West Total 1146. 32.3 ## 17 Total Total 1375. 14.1 We can move the summary row to the first row: recs_des %&gt;% group_by(Region) %&gt;% cascade(DOLLAREL_mn = survey_mean(DOLLAREL), .fill = &quot;National&quot;, .fill_level_top = TRUE) %&gt;% ungroup() ## # A tibble: 5 × 3 ## Region DOLLAREL_mn DOLLAREL_mn_se ## &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 National 1375. 14.1 ## 2 Northeast 1346. 34.2 ## 3 Midwest 1196. 20.2 ## 4 South 1631. 25.3 ## 5 West 1146. 32.3 5.10.5 Calculating Estimates for Many Outcomes Often, we are interested in a summary statistic across many variables. Two useful tools in doing this are the across() function in {dplyr} which has been shown a few times above and the map() function in {purrr}. The across() function allows you to apply the same function to several columns within summarize(). This works well for usage with all functions shown above except survey_prop(). In a later example, we will tackle several proportions. Example 1: across() Suppose we want to calculate the total consumption for each fuel type and the average consumption for each fuel type with coefficients of variation. These include the consumption of electricity (BTUEL), natural gas (BTUNG), liquid propane (BTULP), fuel oil (BTUFO), wood (BTUWOOD), and wood pellets (BTUPELLET), as illustrated in the discussion on design effects. These are the only variables that start with “BTU”, so we can use that to our advantage. consumption_ests &lt;- recs_des %&gt;% summarize(across(starts_with(&quot;BTU&quot;), list(Total = ~survey_total(.x, vartype = &quot;cv&quot;), Mean = ~survey_mean(.x, vartype = &quot;cv&quot;)), .unpack = &quot;{outer}.{inner}&quot;)) consumption_ests ## # A tibble: 1 × 24 ## BTUEL_Total.coef BTUEL_Total._cv BTUEL_Mean.coef BTUEL_Mean._cv ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 4.32e12 0.0108 36578. 0.0108 ## # ℹ 20 more variables: BTUNG_Total.coef &lt;dbl&gt;, BTUNG_Total._cv &lt;dbl&gt;, ## # BTUNG_Mean.coef &lt;dbl&gt;, BTUNG_Mean._cv &lt;dbl&gt;, ## # BTULP_Total.coef &lt;dbl&gt;, BTULP_Total._cv &lt;dbl&gt;, ## # BTULP_Mean.coef &lt;dbl&gt;, BTULP_Mean._cv &lt;dbl&gt;, ## # BTUFO_Total.coef &lt;dbl&gt;, BTUFO_Total._cv &lt;dbl&gt;, ## # BTUFO_Mean.coef &lt;dbl&gt;, BTUFO_Mean._cv &lt;dbl&gt;, ## # BTUWOOD_Total.coef &lt;dbl&gt;, BTUWOOD_Total._cv &lt;dbl&gt;, … In the example above, this results in a very wide table. We may instead want a row for each fuel type. Using the pivot_longer() and pivot_wider() functions from {tidyr} can help us get there. We will first make the data longer and split out the components of the name with pivot_longer(): consumption_ests_long &lt;- consumption_ests %&gt;% pivot_longer(cols = everything(), names_to = c(&quot;FuelType&quot;, &quot;Stat&quot;, &quot;Type&quot;), names_pattern = &quot;BTU(.*)_(.*)\\\\.(.*)&quot;) consumption_ests_long ## # A tibble: 24 × 4 ## FuelType Stat Type value ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 EL Total coef 4.32e+12 ## 2 EL Total _cv 1.08e- 2 ## 3 EL Mean coef 3.66e+ 4 ## 4 EL Mean _cv 1.08e- 2 ## 5 NG Total coef 3.96e+12 ## 6 NG Total _cv 2.55e- 2 ## 7 NG Mean coef 3.35e+ 4 ## 8 NG Mean _cv 2.55e- 2 ## 9 LP Total coef 3.61e+11 ## 10 LP Total _cv 1.25e- 1 ## # ℹ 14 more rows Then, we make the names for each element more descriptive and informative before using pivot_wider() to create a table that is almost ready for publication. A bit more on that will be covered in Chapter 8. consumption_ests_long %&gt;% mutate(Type = case_when(Type == &quot;coef&quot; ~ &quot;&quot;, Type == &quot;_cv&quot; ~ &quot; (CV)&quot;)) %&gt;% pivot_wider(id_cols = FuelType, names_from = c(Stat, Type), names_glue = &quot;{Stat}{Type}&quot;, values_from = value) ## # A tibble: 6 × 5 ## FuelType Total `Total (CV)` Mean `Mean (CV)` ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 EL 4.32e12 0.0108 36578. 0.0108 ## 2 NG 3.96e12 0.0255 33541. 0.0255 ## 3 LP 3.61e11 0.125 3053. 0.125 ## 4 FO 4.64e11 0.0853 3927. 0.0853 ## 5 WOOD 4.92e11 0.0908 4159. 0.0908 ## 6 PELLET 2.11e10 0.242 179. 0.242 Example 2: Proportions with across() As mentioned earlier, proportions will not work as well directly with the across() method. If we want the proportion of houses with air conditioning and the proportion of houses with heating, we need two group_by() statements as follows: recs_des %&gt;% group_by(ACUsed) %&gt;% summarize(p = survey_prop()) ## # A tibble: 2 × 3 ## ACUsed p p_se ## &lt;lgl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 FALSE 0.130 0.00826 ## 2 TRUE 0.870 0.00826 recs_des %&gt;% group_by(SpaceHeatingUsed) %&gt;% summarize(p = survey_prop()) ## # A tibble: 2 × 3 ## SpaceHeatingUsed p p_se ## &lt;lgl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 FALSE 0.0435 0.00370 ## 2 TRUE 0.957 0.00370 If we are only interested in the TRUE outcomes, that is, the proportion that have air conditioning and the proportion that have heating, we can use the fact that survey_mean() applied to a logical variable is the same as using survey_prop(), as shown below: cool_heat_tab &lt;- recs_des %&gt;% summarize(across(c(ACUsed, SpaceHeatingUsed), ~survey_mean(.x), .unpack = &quot;{outer}.{inner}&quot;)) cool_heat_tab ## # A tibble: 1 × 4 ## ACUsed.coef ACUsed._se SpaceHeatingUsed.coef SpaceHeatingUsed._se ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 0.870 0.00826 0.957 0.00370 Note that the estimates are the same as when using the separate group_by() statements. Like previously done, we can use pivot_longer() to create a table in a format better suited for distribution. cool_heat_tab %&gt;% pivot_longer(everything(), names_to = c(&quot;Comfort&quot;, &quot;.value&quot;), names_pattern = &quot;(.*)\\\\.(.*)&quot;) %&gt;% rename(p = coef, se = `_se`) ## # A tibble: 2 × 3 ## Comfort p se ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 ACUsed 0.870 0.00826 ## 2 SpaceHeatingUsed 0.957 0.00370 Example 3: purrr::map() Loops are a common tool if we want to calculate the same thing for many elements. The {purrr} package has the map() functions. Like a loop, they allow you to do something in the same way many times. In our case, we may want to calculate proportions from the same design multiple times. An easy way to do this is to think about how we would do it for one outcome, build a function from there, and then iterate. Suppose we want to create a table that shows the proportion of people that trust in their government (TrustGovernment)18 as well as those that trust in people (TrustPeople)19. First, we do this for a single variable. We create a table that has the variable name as a column, the answer as a column, and then the percentage and its standard error. anes_des %&gt;% drop_na(TrustGovernment) %&gt;% group_by(TrustGovernment) %&gt;% summarize(p = survey_prop() * 100) %&gt;% mutate(Variable = &quot;TrustGovernment&quot;) %&gt;% rename(Answer = TrustGovernment) %&gt;% select(Variable, everything()) ## # A tibble: 5 × 4 ## Variable Answer p p_se ## &lt;chr&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 TrustGovernment Always 1.55 0.204 ## 2 TrustGovernment Most of the time 13.2 0.553 ## 3 TrustGovernment About half the time 30.9 0.829 ## 4 TrustGovernment Some of the time 43.4 0.855 ## 5 TrustGovernment Never 11.0 0.566 Then, we create a function to replace TrustGovernment with the functions argument. To do this, we need to use a bit of tidy evaluation, which is a more advanced skill. If you want to learn more, we recommend Wickham (2019). calcps &lt;- function(var) { anes_des %&gt;% drop_na(!!sym(var)) %&gt;% group_by(!!sym(var)) %&gt;% summarize(p = survey_prop() * 100) %&gt;% mutate(Variable = var) %&gt;% rename(Answer := !!sym(var)) %&gt;% select(Variable, everything()) } We can then run this function on the two variables of interest: calcps(&quot;TrustGovernment&quot;) ## # A tibble: 5 × 4 ## Variable Answer p p_se ## &lt;chr&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 TrustGovernment Always 1.55 0.204 ## 2 TrustGovernment Most of the time 13.2 0.553 ## 3 TrustGovernment About half the time 30.9 0.829 ## 4 TrustGovernment Some of the time 43.4 0.855 ## 5 TrustGovernment Never 11.0 0.566 calcps(&quot;TrustPeople&quot;) ## # A tibble: 5 × 4 ## Variable Answer p p_se ## &lt;chr&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 TrustPeople Always 0.809 0.164 ## 2 TrustPeople Most of the time 41.4 0.857 ## 3 TrustPeople About half the time 28.2 0.776 ## 4 TrustPeople Some of the time 24.5 0.670 ## 5 TrustPeople Never 5.05 0.422 Finally, we can use map to iterate over as many variables as we want. It will output a tibble with the variable name in the column “Variable”, the responses in “Answer”, the percentage, and then the standard error. This example extends nicely if we have many variables for which we want the percentage estimate. c(&quot;TrustGovernment&quot;, &quot;TrustPeople&quot;) %&gt;% map(calcps) %&gt;% list_rbind() ## # A tibble: 10 × 4 ## Variable Answer p p_se ## &lt;chr&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 TrustGovernment Always 1.55 0.204 ## 2 TrustGovernment Most of the time 13.2 0.553 ## 3 TrustGovernment About half the time 30.9 0.829 ## 4 TrustGovernment Some of the time 43.4 0.855 ## 5 TrustGovernment Never 11.0 0.566 ## 6 TrustPeople Always 0.809 0.164 ## 7 TrustPeople Most of the time 41.4 0.857 ## 8 TrustPeople About half the time 28.2 0.776 ## 9 TrustPeople Some of the time 24.5 0.670 ## 10 TrustPeople Never 5.05 0.422 5.11 Exercises The exercises use the design objects anes_des and recs_des as provided in the Prerequisites box in the beginning of the chapter. How many females have a graduate degree? Hint: the variables Gender and Education will be useful. # Option 1: femgd_option1 &lt;- anes_des %&gt;% filter(Gender == &quot;Female&quot;, Education == &quot;Graduate&quot;) %&gt;% survey_count(name = &quot;n&quot;) femgd_option1 ## # A tibble: 1 × 2 ## n n_se ## &lt;dbl&gt; &lt;dbl&gt; ## 1 15072196. 837872. # Option 2: femgd_option2 &lt;- anes_des %&gt;% filter(Gender == &quot;Female&quot;, Education == &quot;Graduate&quot;) %&gt;% summarize(N = survey_total(), .groups = &quot;drop&quot;) femgd_option2 ## # A tibble: 1 × 2 ## N N_se ## &lt;dbl&gt; &lt;dbl&gt; ## 1 15072196. 837872. What percentage of people identify as “Strong Democrat”? Hint: The variable PartyID indicates someone’s party affiliation. psd &lt;- anes_des %&gt;% group_by(PartyID) %&gt;% summarize(p = survey_mean()) %&gt;% filter(PartyID == &quot;Strong democrat&quot;) psd ## # A tibble: 1 × 3 ## PartyID p p_se ## &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Strong democrat 0.219 0.00646 What percentage of people who voted in the 2020 election identify as “Strong Republican”? Hint: The variable VotedPres2020 indicates whether someone voted in 2020. psr &lt;- anes_des %&gt;% filter(VotedPres2020 == &quot;Yes&quot;) %&gt;% group_by(PartyID) %&gt;% summarize(p = survey_mean()) %&gt;% filter(PartyID == &quot;Strong republican&quot;) psr ## # A tibble: 1 × 3 ## PartyID p p_se ## &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Strong republican 0.224 0.00790 What percentage of people voted in both the 2016 election and the 2020 election? Include the logit confidence interval. Hint: The variable VotedPres2016 indicates whether someone voted in 2016. pvb &lt;- anes_des %&gt;% filter(!is.na(VotedPres2016), !is.na(VotedPres2020)) %&gt;% group_by(interact(VotedPres2016, VotedPres2020)) %&gt;% summarize(p = survey_prop(var = &quot;ci&quot;, method = &quot;logit&quot;), ) %&gt;% filter(VotedPres2016 == &quot;Yes&quot;, VotedPres2020 == &quot;Yes&quot;) pvb ## # A tibble: 1 × 5 ## VotedPres2016 VotedPres2020 p p_low p_upp ## &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Yes Yes 0.626 0.607 0.644 What is the design effect for the proportion of people who voted early? Hint: The variable EarlyVote2020 indicates whether someone voted early in 2020. pdeff &lt;- anes_des %&gt;% filter(!is.na(EarlyVote2020)) %&gt;% group_by(EarlyVote2020) %&gt;% summarize(p = survey_mean(deff = TRUE)) %&gt;% filter(EarlyVote2020 == &quot;Yes&quot;) pdeff ## # A tibble: 1 × 4 ## EarlyVote2020 p p_se p_deff ## &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Yes 0.0525 0.00420 2.27 What is the median temperature people set their thermostats to at night during the winter? Hint: The variable WinterTempNight indicates the temperature that people set their temperature in the winter at night. mean_wintertempnight &lt;- recs_des %&gt;% summarize(wtn_mean = survey_mean(x = WinterTempNight, na.rm = TRUE)) mean_wintertempnight ## # A tibble: 1 × 2 ## wtn_mean wtn_mean_se ## &lt;dbl&gt; &lt;dbl&gt; ## 1 68.1 0.0912 People sometimes set their temperature differently over different seasons and during the day. What median temperatures do people set their thermostat to in the summer and winter, both during the day and at night? Include confidence intervals. Hint: Use the variables WinterTempDay, WinterTempNight, SummerTempDay, and SummerTempNight. # Option 1 med_wintertempday &lt;- recs_des %&gt;% summarize(wtd_mean = survey_median(WinterTempDay, vartype = &quot;se&quot;, na.rm = TRUE)) med_wintertempday ## # A tibble: 1 × 2 ## wtd_mean wtd_mean_se ## &lt;dbl&gt; &lt;dbl&gt; ## 1 70 0.252 med_wintertempnight &lt;- recs_des %&gt;% summarize(wtn_mean = survey_median(WinterTempNight, vartype = &quot;se&quot;, na.rm = TRUE)) med_wintertempnight ## # A tibble: 1 × 2 ## wtn_mean wtn_mean_se ## &lt;dbl&gt; &lt;dbl&gt; ## 1 68 0.252 med_summertempday &lt;- recs_des %&gt;% summarize(std_mean = survey_median(SummerTempDay, vartype = &quot;se&quot;, na.rm = TRUE)) med_summertempday ## # A tibble: 1 × 2 ## std_mean std_mean_se ## &lt;dbl&gt; &lt;dbl&gt; ## 1 72 0.252 med_summertempnight &lt;- recs_des %&gt;% summarize(stn_mean = survey_median(SummerTempNight, vartype = &quot;se&quot;, na.rm = TRUE)) med_summertempnight ## # A tibble: 1 × 2 ## stn_mean stn_mean_se ## &lt;dbl&gt; &lt;dbl&gt; ## 1 72 0.252 # Alternatively, could use `survey_quantile()` as shown below for # WinterTempNight: quant_wintertemp &lt;- recs_des %&gt;% summarize(wnt_quant = survey_quantile(WinterTempNight, quantiles = 0.5, vartype = &quot;se&quot;, na.rm = TRUE)) quant_wintertemp ## # A tibble: 1 × 2 ## wnt_quant_q50 wnt_quant_q50_se ## &lt;dbl&gt; &lt;dbl&gt; ## 1 68 0.252 What is the correlation between the temperature that people set their temperature at during the night and during the day in the summer? corr_summer_temp &lt;- recs_des %&gt;% summarize(summer_corr = survey_corr(SummerTempNight, SummerTempDay, na.rm = TRUE)) corr_summer_temp ## # A tibble: 1 × 2 ## summer_corr summer_corr_se ## &lt;dbl&gt; &lt;dbl&gt; ## 1 0.712 0.0147 What is the 1st, 2nd, and 3rd quartile of the amount of money spent on energy by Building America (BA) climate zone? Hint: TOTALDOL indicates the total amount spent on electricity, and ClimateRegion_BA indicates the BA climate zones. quant_baenergyexp &lt;- recs_des %&gt;% group_by(ClimateRegion_BA) %&gt;% summarize(dol_quant = survey_quantile(TOTALDOL, quantiles = c(0.25, 0.5, 0.75), vartype = &quot;se&quot;, na.rm = TRUE)) quant_baenergyexp ## # A tibble: 5 × 7 ## ClimateRegion_BA dol_quant_q25 dol_quant_q50 dol_quant_q75 ## &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Hot-Dry/Mixed-Dry 789. 1194. 1923. ## 2 Hot-Humid 1159. 1691. 2297. ## 3 Mixed-Humid 1354. 1902. 2629 ## 4 Cold/Very Cold 1213. 1731. 2372. ## 5 Marine 904. 1342. 1884. ## # ℹ 3 more variables: dol_quant_q25_se &lt;dbl&gt;, dol_quant_q50_se &lt;dbl&gt;, ## # dol_quant_q75_se &lt;dbl&gt; References "],["c06-statistical-testing.html", "Chapter 6 Statistical testing 6.1 Introduction 6.2 Dot Notation 6.3 Comparison of Proportions and Means 6.4 Chi-Square Tests 6.5 Exercises", " Chapter 6 Statistical testing Prerequisites For this chapter, here are the packages and helper functions we will need: library(tidyverse) library(survey) library(srvyr) library(osfr) source(&quot;helper-fun/helper-functions.R&quot;) library(broom) library(gt) We will be using data from ANES and RECS. Here is the code to create the design objects for each to use throughout this chapter. For ANES, we need to adjust the weight so it sums to the population instead of the sample (see the ANES documentation and Chapter 4 for more information). anes_in &lt;- read_osf(&quot;anes_2020.rds&quot;) targetpop &lt;- 231592693 anes_adjwgt &lt;- anes_in %&gt;% mutate(Weight = Weight/sum(Weight) * targetpop) anes_des &lt;- anes_adjwgt %&gt;% as_survey_design(weights = Weight, strata = Stratum, ids = VarUnit, nest = TRUE) For RECS, details are included in the RECS documentation and Chapter 3. recs_in &lt;- read_osf(&quot;recs_2015.rds&quot;) recs_des &lt;- recs_in %&gt;% as_survey_rep(weights = NWEIGHT, repweights = starts_with(&quot;BRRWT&quot;), type = &quot;Fay&quot;, rho = 0.5, mse = TRUE) 6.1 Introduction When analyzing results from a survey, the point estimates described in Chapter 5 help us understand the data at a high level. Still, researchers and the public often want to make comparisons between different groups. These comparisons are calculated through statistical testing. The general idea of statistical testing is the same for data obtained through surveys and data obtained through other methods, where we compare the point estimates and variance estimates of each statistic to see if statistically significant differences exist. However, statistical testing for complex surveys involves additional considerations due to the need to account for the sampling design in order to obtain accurate variance estimates. The functions in the {survey} packages allow for the correct estimation of the variances. This chapter will cover the following statistical tests with survey data and functions: Comparison of proportions svyttest() Comparison of means svyttest() Goodness of fit tests svygofchisq() Tests of independence svychisq() Tests of homogeneity svychisq() 6.2 Dot Notation Up to this point, we have shown functions that use wrappers from the {srvyr} package. This means that the functions work with tidyverse syntax. However, the functions in this chapter do not have wrappers in the {srvyr} package and are instead used directly from the {survey} package. Therefore, the design object is not the first argument, and to use these functions with the magrittr pipe %&gt;% and tidyverse syntax, we will need to use dot (.) notation. Functions that work with the magrittr pipe (%&gt;%) have the data as the first argument. When we run a function with the pipe, it automatically places anything to the left of the pipe into the first argument of the function to the right of the pipe. For example, if we wanted to take the mtcars data and filter to cars with six cylinders, we can write the code in at least four different ways: filter(mtcars, cyl == 6) mtcars %&gt;% filter(cyl == 6) mtcars %&gt;% filter(., cyl == 6) mtcars %&gt;% filter(.data = ., cyl == 6) Each of these lines of code will produce the same output since the argument that takes the data is in the first spot in filter(). The first two are probably familiar to those who have worked with the tidyverse. The third option functions the same way as the second one but is explicit that mtcars goes into the first argument, and the fourth option indicates that mtcars is going into the named argument of .data. Here, we are telling R to take what’s on the left side of the pipe (mtcars) and pipe it into the spot with the dot (.)—the first argument. In functions that are not part of the tidyverse, the data argument may not be in the first spot. For example, in svyttest(), the data argument is in the second spot, which means we need to place the dot (.) in the second spot and not the first. For example: svydata_des %&gt;% svyttest(x ~ y, .) By default, the pipe places the left-hand object in the first argument spot. Placing the dot (.) in the second argument spot indicates that the survey design object svydata_des should be used in the second argument and not the first. Alternatively, named arguments could be used to place the dot first, as in the following: svydata_des %&gt;% svyttest(design = ., x ~ y) 6.3 Comparison of Proportions and Means We use t-tests to compare two proportions or means. T-tests allow us to determine if one proportion or mean is statistically different from another. They are commonly used to determine if a single estimate differs from a known value (e.g., 0 or 50%) or to compare two group means (e.g., North versus South). Comparing a single estimate to a known value is called a one sample t-test, and we can set up the hypothesis test as follows: \\(H_0: \\mu = 0\\) where \\(\\mu\\) is the mean outcome and \\(0\\) is the value we are comparing it to \\(H_A: \\mu \\neq 0\\) For comparing two estimates, this is called a two-sample t-test and we can set up the hypothesis test as follows: \\(H_0: \\mu_1 = \\mu_2\\) where \\(\\mu_i\\) is the mean outcome for group \\(i\\) \\(H_A: \\mu_1 \\neq \\mu_2\\) Two sample t-tests can also be paired or unpaired. If the data come from two different populations (e.g., North versus South), the t-test run will be an unpaired or independent samples t-test. Paired t-tests occur when the data come from the same population. This is commonly seen with data from the same population in two different time periods (e.g., before and after an intervention). The difference between t-tests with non-survey data and survey data is based on the underlying variance estimation difference. Chapter 3 provides a detailed overview of the math behind the mean and sampling error calculations for various sample designs. The functions in the {survey} package will account for these nuances, provided the design object is correctly defined. 6.3.1 Syntax When we do not have survey data, we can use the t.test() function from the {stats} package. This function does not allow for weights or the variance structure that need to be accounted for with survey data. Therefore, we need to use the svyttest() function from {survey} when using survey data. Many of the arguments are the same between the two functions, but there are a few key differences: We need to use the survey design object instead of the original data frame We can only use a formula and not separate x and y data The confidence level cannot be specified and will always be set to 95%. However, we will show examples of how the confidence level can be changed after running using the confint() function. Here is the syntax for the svyttest() function: svyttest(formula, design, ...) The arguments are: formula: Formula, outcome~group for two-sample, outcome~0 or outcome~1 for one-sample. The group variable must be a factor or character with two levels, or be coded 0/1 or 1/2. We give more details on formula set-up below for different types of tests. design: survey design object ...: This passes options on for one-sided tests only, and thus, we can specify na.rm=TRUE Notice that the first argument here is the formula and not the design. This means we must use the dot (.) if we pipe in the survey design object (as described at the beginning of this chapter). The formula argument can take several different forms depending on what we are measuring. Here are a few common scenarios: One-sample t-test: Comparison to 0: var ~ 0, where var is the measure of interest, and we compare it to the value 0. For example, we could test if the population mean of household debt is different from 0. Comparison to a different value: var - value ~ 0, where var is the measure of interest and value is what we are comparing to. For example, we could test if the proportion of the population that has blue eyes is different from 25% by using var - 0.25 ~ 0. Note that specifying the formula as var ~ 0.25 is not equivalent. Two-sample t-test: Unpaired: 2 level grouping variable: var ~ groupVar, where var is the measure of interest and groupVar is a variable with two categories. For example, we could test if the average age of the population who voted for president in 2020 differed from the age of people who did not vote. In this case, age would be used for var, and a binary variable indicating voting activity would be the groupVar. 3+ level grouping variable: var ~ groupVar == level, where var is the measure of interest, groupVar is the categorical variable, and level is the category level to isolate. For example, we could test if the test scores in one classroom differed from all other classrooms. Paired: var_1 - var_2 ~ 0, where var_1 is the first variable of interest and var_2 is the second variable of interest. For example, we could test if test scores on a subject differed between the start and the end of a course. The na.rm argument defaults to FALSE, which means if any data is missing, the t-test will not compute. Throughout this chapter, we will always set na.rm = TRUE, but before analyzing the survey data, review the notes provided in Chapter 4 to better understand how to handle missing data. Let’s walk through a few examples using the ANES and RECS data. 6.3.2 Examples Example 1: One-sample t-test for Mean RECS asks respondents to indicate what temperature they set their house to during the summer at night.20 In our data, we have called this variable SummerTempNight. If we want to see if the average U.S. household sets its temperature at a value different from 68\\(^\\circ\\)F, we could set up the hypothesis as follows: \\(H_0: \\mu = 68\\) where \\(\\mu\\) is the average temperature U.S. households set their thermostat to in the summer at night \\(H_A: \\mu \\neq 68\\) To conduct this in R, we use svyttest() with and subtract the temperature on the right-hand side of the formula: ttest_ex1 &lt;- recs_des %&gt;% svyttest(formula = SummerTempNight - 68 ~ 0, design = ., na.rm = TRUE) ttest_ex1 ## ## Design-based one-sample t-test ## ## data: SummerTempNight - 68 ~ 0 ## t = 41, df = 94, p-value &lt;2e-16 ## alternative hypothesis: true mean is not equal to 0 ## 95 percent confidence interval: ## 3.425 3.773 ## sample estimates: ## mean ## 3.599 To pull out specific output, we can use R’s built-in $ operator. For instance, to obtain the estimate \\(\\mu - 68\\), we run ttest_ex1$estimate. If we want the average, we take our t-test estimate and add it to 68: ttest_ex1$estimate + 68 ## mean ## 71.6 Or, we can use the survey_mean() function described in Chapter 5: recs_des %&gt;% summarize(mu = survey_mean(SummerTempNight, na.rm = TRUE)) ## # A tibble: 1 × 2 ## mu mu_se ## &lt;dbl&gt; &lt;dbl&gt; ## 1 71.6 0.0878 The result is the same in both methods, so we see that the average temperature U.S. households set their thermostat to in the summer at night is 71.6\\(^\\circ\\)F. Looking at the output from svyttest(), the t-statistic is 41, and the p-value is \\(8.67\\times 10^{-62}\\), indicating that the average is statistically different from 68\\(^\\circ\\)F at an \\(\\alpha\\) level of \\(0.05\\). If we want an 80% confidence interval for the test statistic, we can use the function confint() to change the confidence level. Below, we print both the original 95% confidence interval and the 80% confidence interval: confint(ttest_ex1, level = 0.95) ## 2.5 % 97.5 % ## as.numeric(SummerTempNight - 68) 3.425 3.773 ## attr(,&quot;conf.level&quot;) ## [1] 0.95 confint(ttest_ex1, level = 0.8) ## [1] 3.486 3.712 ## attr(,&quot;conf.level&quot;) ## [1] 0.8 Example 2: One-sample t-test for Proportion ANES asked respondents if they voted in the presidential election in 2020.21 In our data, we call this variable VotedPres2020. Let’s look at the proportion of the U.S. voting-eligible population that voted for the president in 2020 using the survey_prop() function we learned in Chapter 5. voteprop &lt;- anes_des %&gt;% group_by(VotedPres2020) %&gt;% summarize(p = survey_prop()) voteprop ## # A tibble: 3 × 3 ## VotedPres2020 p p_se ## &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Yes 0.772 0.00757 ## 2 No 0.227 0.00763 ## 3 &lt;NA&gt; 0.00113 0.000464 Based on this, 77.2% of the U.S. voting-eligible population voted for president in 2020. If we wanted to know how this compares to another country, we could use svyttest(). For example, if we know that the voter turnout in Germany in the 2017 general election was 76.2%, we could set up our hypothesis as follows: \\(H_0: p = 0.762\\) where \\(p\\) is the proportion of the U.S. voting-eligible population that voted for president in 2020 \\(H_A: p \\neq 0.762\\) To conduct this in R, we use the svyttest() function as follows: ttest_ex2 &lt;- anes_des %&gt;% svyttest(formula = (VotedPres2020 == &quot;Yes&quot;) - 0.762 ~ 0, design = ., na.rm = TRUE) ttest_ex2 ## ## Design-based one-sample t-test ## ## data: (VotedPres2020 == &quot;Yes&quot;) - 0.762 ~ 0 ## t = 1.4, df = 50, p-value = 0.2 ## alternative hypothesis: true mean is not equal to 0 ## 95 percent confidence interval: ## -0.004729 0.025899 ## sample estimates: ## mean ## 0.01058 The output from the svyttest() function can be a bit hard to read. Using the {broom} package from tidymodels, a collection of packages for modeling using the tidyverse principles, we can clean up the output into a tibble to more easily understand what the test tells us. broom::tidy(ttest_ex2) ## # A tibble: 1 × 8 ## estimate statistic p.value parameter conf.low conf.high method ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 0.0106 1.39 0.171 50 -0.00473 0.0259 Design-based … ## # ℹ 1 more variable: alternative &lt;chr&gt; The estimate differs from example one in that the estimate is not displaying \\(\\mu - 0.762\\) but rather \\(\\mu\\), or the difference between the U.S. proportion and the German proportion we are comparing. We can see that there is a difference of 1.06 percentage points. Additionally, the t-statistic value in the statistic column is 1.39, and the p-value is 0.171. These results indicate that the U.S. and Germany have similar voter turnout. Example 3: Unpaired two-sample t-test Two additional variables in the RECS data are the electric bill cost (DOLLAREL) and whether the house used AC or not (ACUsed).22 If we want to know if the U.S. households that used AC had higher electrical bills compared to those that did not, we could set up the hypothesis as follows: \\(H_0: \\mu_{AC} = \\mu_{noAC}\\) where \\(\\mu_{AC}\\) is the electrical bill cost for U.S. households that used AC and \\(\\mu_{noAC}\\) is the electrical bill cost for U.S. households that did not use AC \\(H_A: \\mu_{AC} \\neq \\mu_{noAC}\\) Let’s take a quick look at the data to see the format the data are in: recs_des %&gt;% group_by(ACUsed) %&gt;% summarize(mean = survey_mean(DOLLAREL, na.rm = TRUE)) ## # A tibble: 2 × 3 ## ACUsed mean mean_se ## &lt;lgl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 FALSE 972. 25.8 ## 2 TRUE 1435. 15.8 To conduct this in R, we use svyttest(): ttest_ex3 &lt;- recs_des %&gt;% svyttest(formula = DOLLAREL ~ ACUsed, design = ., na.rm = TRUE) broom::tidy(ttest_ex3) ## # A tibble: 1 × 8 ## estimate statistic p.value parameter conf.low conf.high method ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 463. 14.8 3.08e-26 94 401. 525. Design-based… ## # ℹ 1 more variable: alternative &lt;chr&gt; The results indicate that the difference in electrical bills for those that used AC and those that did not is, on average, $462.87. The difference appears to be statistically significant as the t-statistic is 14.8 and the p-value is \\(3.08\\times 10^{-26}\\). Households that used AC spent, on average, $462.90 more in 2015. Example 4: Paired two-sample t-test Let’s say we want to test whether the temperature that U.S. households set their thermostat at night differs depending on the season (comparing summer23 and winter24 temperatures). We could set up the hypothesis as follows: \\(H_0: \\mu_{summer} = \\mu_{winter}\\) where \\(\\mu_{summer}\\) is the temperature that U.S. households set their thermostat to during summer nights, and \\(\\mu_{winter}\\) is the temperature that U.S. households set their thermostat to during winter nights \\(H_A: \\mu_{summer} \\neq \\mu_{winter}\\) To conduct this in R, we use svyttest() by calculating the temperature difference on the left-hand side as follows: ttest_ex4 &lt;- recs_des %&gt;% svyttest(design = ., formula = SummerTempNight - WinterTempNight ~ 0, na.rm = TRUE) broom::tidy(ttest_ex4) ## # A tibble: 1 × 8 ## estimate statistic p.value parameter conf.low conf.high method ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 3.21 29.1 8.83e-49 94 3.00 3.43 Design-based… ## # ℹ 1 more variable: alternative &lt;chr&gt; U.S. households set their thermostat on average 3.2\\(^\\circ\\)F warmer in summer nights than winter nights, which is statistically significant (t = 29.1, p-value = \\(8.83\\times 10^{-49}\\)). 6.4 Chi-Square Tests Chi-square tests (\\(\\chi^2\\)) allow us to examine multiple proportions using a goodness-of-fit test, a test of independence, or a test of homogeneity. These three tests have the same \\(\\chi^2\\) distributions but with slightly different underlying assumptions. First, goodness-of-fit tests are used when comparing observed data to expected data. For example, this could be used to determine if respondent demographics (the observed data) match known population information (the expected data). In this case, we can set up the hypothesis test as follows: \\(H_0: p_1 = \\pi_1, ~ p_2 = \\pi_2, ~ ..., ~ p_k = \\pi_k\\) where \\(p_i\\) is the observed proportion for category \\(i\\), \\(\\pi_i\\) is expected proportion for category \\(i\\), and \\(k\\) is the number of categories \\(H_A:\\) at least one level of \\(p_i\\) does not match \\(\\pi_i\\) Second, tests of independence are used when comparing two types of observed data to see if there is a relationship. For example, this could be used to determine if the proportion of respondents who voted for each political party in the presidential election matches the proportion of respondents who voted for each political party in a local election. In this case, we can set up the hypothesis test as follows: \\(H_0:\\) The two variables/factors are independent \\(H_A:\\) The two variables/factors are not independent Third, tests of homogeneity are used to compare two distributions to see if they match. For example, this could be used to determine if the highest education achieved is the same for both men and women. In this case, we can set up the hypothesis test as follows: \\(H_0: p_{1a} = p_{1b}, ~ p_{2a} = p_{2b}, ~ ..., ~ p_{ka} = p_{kb}\\) where \\(p_{ia}\\) is the observed proportion of category \\(i\\) for subgroup \\(a\\), \\(p_{ib}\\) is the observed proportion of category \\(i\\) for subgroup \\(a\\) and \\(k\\) is the number of categories \\(H_A:\\) at least one category of \\(p_{ia}\\) does not match \\(p_{ib}\\) As with t-tests, the difference between using \\(\\chi^2\\) tests with non-survey data and survey data is based on the underlying variance estimation. The functions in the {survey} package will account for these nuances, provided the design object is correctly defined. For basic variance estimation formulas for different survey design types, refer to Chapter 3. 6.4.1 Syntax When we do not have survey data, we may be able to use the chisq.test() function from the {stats} package. However, this function does not allow for weights or the variance structure to be accounted for with survey data. Therefore, when using survey data, we need to use one of two functions: svygofchisq(): For goodness of fit tests svychisq(): For tests of independence and homogeneity The non-survey data function of chisq.test() requires either a single set of counts and given proportions (for goodness of fit tests) or two sets of counts for tests of independence and homogeneity. The functions we use with survey data require respondent-level data and formulas instead of counts. This ensures that the variances are correctly calculated. First, the function for the goodness of fit tests is svygofchisq(): svygofchisq(formula, p, design, na.rm = TRUE, ...) The arguments are: formula: Formula specifying a single factor variable p: Vector of probabilities for the categories of the factor in the correct order. If they probabilities do not sum to 1, they will be rescaled to sum to 1. design: Survey design object …: Other arguments to pass on, such as na.rm Based on the order of the arguments, we again must use the dot (.) notation if we pipe in the survey design object or explicitly name the arguments (as described at the beginning of this chapter). For the goodness of fit tests, the formula will be a single variable formula = ~var as we compare the observed data from this variable to the expected data. The expected probabilities are then entered in the p argument and need to be a vector of the same length as the number of categories in the variable. For example, if we want to know if the proportion of males and females matches a distribution of 30/70, then the sex variable (with two categories) would be used formula = ~SEX, and the proportions would be included as p = c(.3, .7). It is important to note that the variable entered into the formula should be formatted as either a factor or a character. The examples below provide more detail and tips on how to make sure the levels match up correctly. For tests of homogeneity and independence, the svychisq() function should be used. The syntax is as follows: svychisq( formula, design, statistic = c(&quot;F&quot;, &quot;Chisq&quot;, &quot;Wald&quot;, &quot;adjWald&quot;, &quot;lincom&quot;, &quot;saddlepoint&quot;), na.rm = TRUE ) The arguments are: formula: Model formula specifying the table (shown in examples) design: Survey design object statistic: Type of test statistic to use in test (details below) na.rm: Remove missing values There are six statistics that are accepted in this formula. For tests of homogeneity (when comparing cross-tabulations), the F or Chisq statistics should be used.25 The F statistic is the default and uses the Rao-Scott second-order correction. This correction is designed to assist with complicated sampling designs (i.e., those other than a simple random sample) (Scott 2007). The Chisq statistic is an adjusted version of the Pearson \\(\\chi^2\\) statistic. The version of this statistic in the svychisq() function compares the design effect estimate from the provided survey data to what the \\(\\chi^2\\) distribution would have been if the data came from a simple random sampling. For tests of independence, the Wald and adjWald are recommended as they provide a better adjustment for variable comparisons (Lumley 2010). If the data has a small number of primary sampling units (PSUs) compared to the degrees of freedom, then the adjWald statistic should be used to account for this. The lincom and saddlepoint statistics are available for more complicated data structures. The formula argument will always be one-sided, unlike the svyttest() function. The two variables of interest should be included with a plus sign: formula = ~ var_1 + var_2. As with the svygofchisq() function, the variables entered into the formula should be formatted as either a factor or a character. Additionally, as with the t-test function, both svygofchisq() and svychisq() have the na.rm argument. If any data is missing, the \\(\\chi^2\\) tests will assume that NA is a category and include it in the calculation. Throughout this chapter, we will always set na.rm = TRUE, but before analyzing the survey data, review the notes provided in Chapter 4 to better understand how to handle missing data. 6.4.2 Examples Let’s walk through a few examples using the ANES data. Example 1: Goodness of Fit Test ANES asked respondents about their highest education level.26 Based on the data from the 2020 American Community Survey (ACS) 5-year estimates27, the education distribution of those 18+ in the U.S. is as follows: 11% had less than High School degree 27% had a High School degree 29% had some college or associate’s degree 33% had a bachelor’s degree or higher If we want to see if the weighted distribution from the ANES 2020 data matches this distribution, we could set up the hypothesis as follows: \\(H_0: p_1 = 0.11, ~ p_2 = 0.27, ~ p_3 = 0.29, ~ p_4 = 0.33\\) \\(H_A:\\) at least one of the education levels does not match between the ANES and the ACS To conduct this in R, let’s first look at the education variable (Education) we have on the ANES data. Using the survey_mean() function discussed in Chapter 5, we can see the education levels and estimated proportions. anes_des %&gt;% drop_na(Education) %&gt;% group_by(Education) %&gt;% summarize(p = survey_mean()) ## # A tibble: 5 × 3 ## Education p p_se ## &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Less than HS 0.0805 0.00568 ## 2 High school 0.277 0.0102 ## 3 Post HS 0.290 0.00713 ## 4 Bachelor&#39;s 0.226 0.00633 ## 5 Graduate 0.126 0.00499 Based on this output, we can see that we have different levels than the ACS data provides. Specifically, the education data from ANES has two levels for Bachelor’s Degree or Higher (Bachelor’s and Graduate), so these two categories need to be collapsed into a single category to match the ACS data. For this, we can use the {forcats} package from the tidyverse. The package’s fct_collapse() function helps us create a new variable by collapsing categories into a single one. Then, we will use the svygofchisq() function to compare the ANES data to the ACS data: anes_des_educ &lt;- anes_des %&gt;% mutate(Education2 = fct_collapse(Education, `Bachelor or Higher` = c(&quot;Bachelor&#39;s&quot;, &quot;Graduate&quot;))) anes_des_educ %&gt;% drop_na(Education2) %&gt;% group_by(Education2) %&gt;% summarize(p = survey_mean()) ## # A tibble: 4 × 3 ## Education2 p p_se ## &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Less than HS 0.0805 0.00568 ## 2 High school 0.277 0.0102 ## 3 Post HS 0.290 0.00713 ## 4 Bachelor or Higher 0.352 0.00732 chi_ex1 &lt;- anes_des_educ %&gt;% svygofchisq(formula = ~Education2, p = c(0.11, 0.27, 0.29, 0.33), design = ., na.rm = TRUE) chi_ex1 ## ## Design-based chi-squared test for given probabilities ## ## data: ~Education2 ## X-squared = 2172220, scale = 1.1e+05, df = 2.3e+00, p-value = ## 9e-05 The output from the svygofchisq() indicates that at least one proportion from ANES does not match the ACS data (\\(\\chi^2 =\\) 2.1722^{6}; \\(p-value =\\) 8.74^{-5}). To get a better idea of the differences, we can use the expected output along with survey_mean() to create a comparison table: ex1_table &lt;- anes_des_educ %&gt;% drop_na(Education2) %&gt;% group_by(Education2) %&gt;% summarize(Observed = survey_mean(vartype = &quot;ci&quot;)) %&gt;% rename(Education = Education2) %&gt;% mutate(Expected = c(0.11, 0.27, 0.29, 0.33)) %&gt;% select(Education, Expected, everything()) ex1_table ## # A tibble: 4 × 5 ## Education Expected Observed Observed_low Observed_upp ## &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Less than HS 0.11 0.0805 0.0691 0.0919 ## 2 High school 0.27 0.277 0.257 0.298 ## 3 Post HS 0.29 0.290 0.276 0.305 ## 4 Bachelor or Higher 0.33 0.352 0.337 0.367 This output includes our expected proportions from the ACS that we provided the svygofchisq() function along with the output of the observed proportions and their confidence intervals. This table shows that the “High school” and “Post HS” categories have nearly identical proportions but that the other two categories are slightly different. Looking at the confidence intervals, we can see that the ANES data skews to include fewer people in the “Less than HS” category and more people in the “Bachelor or Higher” category. This may be easier to see if we plot this (see Figure 6.1). ex1_table %&gt;% pivot_longer(cols = c(&quot;Expected&quot;, &quot;Observed&quot;), names_to = &quot;Names&quot;, values_to = &quot;Proportion&quot;) %&gt;% mutate(Observed_low = if_else(Names == &quot;Observed&quot;, Observed_low, NA_real_), Observed_upp = if_else(Names == &quot;Observed&quot;, Observed_upp, NA_real_)) %&gt;% ggplot(aes(x = Education, y = Proportion, color = Names)) + geom_point(alpha = 0.75, size = 2) + geom_errorbar(aes(ymin = Observed_low, ymax = Observed_upp), width = 0.25) + theme_bw() + scale_color_manual(name = &quot;Type&quot;, values = book_colors[c(4, 1)]) + theme(legend.position = &quot;none&quot;) FIGURE 6.1: Expected and observed proportions of education, showing the confidence intervals for the expected proportions and whether the observed proportions lie within them. Example 2: Test of Independence ANES asked respondents two questions about trust: How often can you trust the federal government to do what is right? How often can you trust other people? If we want to see if the distributions of these two questions are similar or not, we can conduct a test of independence. Here is how the hypothesis could be set up: \\(H_0:\\) People’s trust in the federal government and their trust in other people are independent (i.e., not related) \\(H_A:\\) People’s trust in the federal government and their trust in other people are not independent (i.e., they are related) To conduct this in R, we use the svychisq() function to compare the two variables: chi_ex2 &lt;- anes_des %&gt;% svychisq(formula = ~TrustGovernment + TrustPeople, design = ., statistic = &quot;Wald&quot;, na.rm = TRUE) chi_ex2 ## ## Design-based Wald test of association ## ## data: NextMethod() ## F = 21, ndf = 16, ddf = 51, p-value &lt;2e-16 The output from svychisq() indicates that the distribution of people’s trust in the federal government and their trust in other people are not independent, meaning that they are related. Let’s output the distributions in a table to see the relationship. The observed output from the test provides a cross-tabulation of the counts for each category: chi_ex2$observed ## TrustPeople ## TrustGovernment Always Most of the time About half the time ## Always 16.470 25.009 31.848 ## Most of the time 11.020 539.377 196.258 ## About half the time 11.772 934.858 861.971 ## Some of the time 17.007 1353.779 839.863 ## Never 3.174 236.785 174.272 ## TrustPeople ## TrustGovernment Some of the time Never ## Always 36.854 5.523 ## Most of the time 206.556 27.184 ## About half the time 428.871 65.024 ## Some of the time 932.628 89.596 ## Never 217.994 189.307 However, as researchers, we often want to know about the proportions and not just the respondent counts from the survey. There are a couple of different ways that we can do this. The first is using the counts from chi_ex2$observed to calculate the proportion. We can then pivot the table to create a cross-tabulation similar to the counts table above. Adding group_by() to the code means that we are obtaining the proportions within each level of that variable. In this case, we are looking at the distribution of TrustGovernment for each level of TrustPeople. chi_ex2$observed %&gt;% as_tibble() %&gt;% group_by(TrustPeople) %&gt;% mutate(prop = round(n/sum(n), 3)) %&gt;% select(-n) %&gt;% pivot_wider(names_from = TrustPeople, values_from = prop) %&gt;% gt(rowname_col = &quot;TrustGovernment&quot;) %&gt;% tab_stubhead(label = &quot;Trust in Government&quot;) %&gt;% tab_spanner(label = &quot;Trust in People&quot;, columns = everything()) %&gt;% cols_label(`Most of the time` = md(&quot;Most of&lt;br /&gt;the time&quot;), `About half the time` = md(&quot;About half&lt;br /&gt;the time&quot;), `Some of the time` = md(&quot;Some of&lt;br /&gt;the time&quot;)) %&gt;% tab_caption(&quot;Estimates of proportion of people by levels of trust in people and government, ANES 2020&quot;) #xahdlkimjs table { font-family: system-ui, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Noto Color Emoji'; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; } #xahdlkimjs thead, #xahdlkimjs tbody, #xahdlkimjs tfoot, #xahdlkimjs tr, #xahdlkimjs td, #xahdlkimjs th { border-style: none; } #xahdlkimjs p { margin: 0; padding: 0; } #xahdlkimjs .gt_table { display: table; border-collapse: collapse; line-height: normal; margin-left: auto; margin-right: auto; color: #333333; font-size: 16px; font-weight: normal; font-style: normal; background-color: #FFFFFF; width: auto; border-top-style: solid; border-top-width: 2px; border-top-color: #A8A8A8; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #A8A8A8; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; } #xahdlkimjs .gt_caption { padding-top: 4px; padding-bottom: 4px; } #xahdlkimjs .gt_title { color: #333333; font-size: 125%; font-weight: initial; padding-top: 4px; padding-bottom: 4px; padding-left: 5px; padding-right: 5px; border-bottom-color: #FFFFFF; border-bottom-width: 0; } #xahdlkimjs .gt_subtitle { color: #333333; font-size: 85%; font-weight: initial; padding-top: 3px; padding-bottom: 5px; padding-left: 5px; padding-right: 5px; border-top-color: #FFFFFF; border-top-width: 0; } #xahdlkimjs .gt_heading { background-color: #FFFFFF; text-align: center; border-bottom-color: #FFFFFF; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #xahdlkimjs .gt_bottom_border { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #xahdlkimjs .gt_col_headings { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #xahdlkimjs .gt_col_heading { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 6px; padding-left: 5px; padding-right: 5px; overflow-x: hidden; } #xahdlkimjs .gt_column_spanner_outer { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; padding-top: 0; padding-bottom: 0; padding-left: 4px; padding-right: 4px; } #xahdlkimjs .gt_column_spanner_outer:first-child { padding-left: 0; } #xahdlkimjs .gt_column_spanner_outer:last-child { padding-right: 0; } #xahdlkimjs .gt_column_spanner { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 5px; overflow-x: hidden; display: inline-block; width: 100%; } #xahdlkimjs .gt_spanner_row { border-bottom-style: hidden; } #xahdlkimjs .gt_group_heading { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; text-align: left; } #xahdlkimjs .gt_empty_group_heading { padding: 0.5px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: middle; } #xahdlkimjs .gt_from_md > :first-child { margin-top: 0; } #xahdlkimjs .gt_from_md > :last-child { margin-bottom: 0; } #xahdlkimjs .gt_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; margin: 10px; border-top-style: solid; border-top-width: 1px; border-top-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; overflow-x: hidden; } #xahdlkimjs .gt_stub { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-right-style: solid; border-right-width: 2px; border-right-color: #D3D3D3; padding-left: 5px; padding-right: 5px; } #xahdlkimjs .gt_stub_row_group { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-right-style: solid; border-right-width: 2px; border-right-color: #D3D3D3; padding-left: 5px; padding-right: 5px; vertical-align: top; } #xahdlkimjs .gt_row_group_first td { border-top-width: 2px; } #xahdlkimjs .gt_row_group_first th { border-top-width: 2px; } #xahdlkimjs .gt_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #xahdlkimjs .gt_first_summary_row { border-top-style: solid; border-top-color: #D3D3D3; } #xahdlkimjs .gt_first_summary_row.thick { border-top-width: 2px; } #xahdlkimjs .gt_last_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #xahdlkimjs .gt_grand_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #xahdlkimjs .gt_first_grand_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-top-style: double; border-top-width: 6px; border-top-color: #D3D3D3; } #xahdlkimjs .gt_last_grand_summary_row_top { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-bottom-style: double; border-bottom-width: 6px; border-bottom-color: #D3D3D3; } #xahdlkimjs .gt_striped { background-color: rgba(128, 128, 128, 0.05); } #xahdlkimjs .gt_table_body { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #xahdlkimjs .gt_footnotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #xahdlkimjs .gt_footnote { margin: 0px; font-size: 90%; padding-top: 4px; padding-bottom: 4px; padding-left: 5px; padding-right: 5px; } #xahdlkimjs .gt_sourcenotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #xahdlkimjs .gt_sourcenote { font-size: 90%; padding-top: 4px; padding-bottom: 4px; padding-left: 5px; padding-right: 5px; } #xahdlkimjs .gt_left { text-align: left; } #xahdlkimjs .gt_center { text-align: center; } #xahdlkimjs .gt_right { text-align: right; font-variant-numeric: tabular-nums; } #xahdlkimjs .gt_font_normal { font-weight: normal; } #xahdlkimjs .gt_font_bold { font-weight: bold; } #xahdlkimjs .gt_font_italic { font-style: italic; } #xahdlkimjs .gt_super { font-size: 65%; } #xahdlkimjs .gt_footnote_marks { font-size: 75%; vertical-align: 0.4em; position: initial; } #xahdlkimjs .gt_asterisk { font-size: 100%; vertical-align: 0; } #xahdlkimjs .gt_indent_1 { text-indent: 5px; } #xahdlkimjs .gt_indent_2 { text-indent: 10px; } #xahdlkimjs .gt_indent_3 { text-indent: 15px; } #xahdlkimjs .gt_indent_4 { text-indent: 20px; } #xahdlkimjs .gt_indent_5 { text-indent: 25px; } TABLE 6.1: Estimates of proportion of people by levels of trust in people and government, ANES 2020 Trust in Government Trust in People Always Most ofthe time About halfthe time Some ofthe time Never Always 0.277 0.008 0.015 0.020 0.015 Most of the time 0.185 0.175 0.093 0.113 0.072 About half the time 0.198 0.303 0.410 0.235 0.173 Some of the time 0.286 0.438 0.399 0.512 0.238 Never 0.053 0.077 0.083 0.120 0.503 The second option is to use group_by() and survey_mean() functions to calculate the proportions from the ANES design object. A reminder that with more than one variable listed in the group_by() statement, the proportions are within the first variable listed. As mentioned above, we are looking at the distribution of TrustGovernment for each level of TrustPeople. chi_ex2_obs &lt;- anes_des %&gt;% drop_na(TrustPeople, TrustGovernment) %&gt;% group_by(TrustPeople, TrustGovernment) %&gt;% summarize(Observed = round(survey_mean(vartype = &quot;ci&quot;), 3), .groups = &quot;drop&quot;) chi_ex2_obs %&gt;% mutate(prop = paste0(Observed, &quot; (&quot;, Observed_low, &quot;, &quot;, Observed_upp, &quot;)&quot;)) %&gt;% select(TrustGovernment, TrustPeople, prop) %&gt;% pivot_wider(names_from = TrustPeople, values_from = prop) %&gt;% gt(rowname_col = &quot;TrustGovernment&quot;) %&gt;% tab_stubhead(label = &quot;Trust in Government&quot;) %&gt;% tab_spanner(label = &quot;Trust in People&quot;, columns = everything()) %&gt;% tab_options(page.orientation = &quot;landscape&quot;) %&gt;% tab_caption(&quot;Estimates of proportion of people by levels of trust in people and government with confidence intervals, ANES 2020&quot;) #vphoojcuph table { font-family: system-ui, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Noto Color Emoji'; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; } #vphoojcuph thead, #vphoojcuph tbody, #vphoojcuph tfoot, #vphoojcuph tr, #vphoojcuph td, #vphoojcuph th { border-style: none; } #vphoojcuph p { margin: 0; padding: 0; } #vphoojcuph .gt_table { display: table; border-collapse: collapse; line-height: normal; margin-left: auto; margin-right: auto; color: #333333; font-size: 16px; font-weight: normal; font-style: normal; background-color: #FFFFFF; width: auto; border-top-style: solid; border-top-width: 2px; border-top-color: #A8A8A8; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #A8A8A8; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; } #vphoojcuph .gt_caption { padding-top: 4px; padding-bottom: 4px; } #vphoojcuph .gt_title { color: #333333; font-size: 125%; font-weight: initial; padding-top: 4px; padding-bottom: 4px; padding-left: 5px; padding-right: 5px; border-bottom-color: #FFFFFF; border-bottom-width: 0; } #vphoojcuph .gt_subtitle { color: #333333; font-size: 85%; font-weight: initial; padding-top: 3px; padding-bottom: 5px; padding-left: 5px; padding-right: 5px; border-top-color: #FFFFFF; border-top-width: 0; } #vphoojcuph .gt_heading { background-color: #FFFFFF; text-align: center; border-bottom-color: #FFFFFF; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #vphoojcuph .gt_bottom_border { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #vphoojcuph .gt_col_headings { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #vphoojcuph .gt_col_heading { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 6px; padding-left: 5px; padding-right: 5px; overflow-x: hidden; } #vphoojcuph .gt_column_spanner_outer { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; padding-top: 0; padding-bottom: 0; padding-left: 4px; padding-right: 4px; } #vphoojcuph .gt_column_spanner_outer:first-child { padding-left: 0; } #vphoojcuph .gt_column_spanner_outer:last-child { padding-right: 0; } #vphoojcuph .gt_column_spanner { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 5px; overflow-x: hidden; display: inline-block; width: 100%; } #vphoojcuph .gt_spanner_row { border-bottom-style: hidden; } #vphoojcuph .gt_group_heading { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; text-align: left; } #vphoojcuph .gt_empty_group_heading { padding: 0.5px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: middle; } #vphoojcuph .gt_from_md > :first-child { margin-top: 0; } #vphoojcuph .gt_from_md > :last-child { margin-bottom: 0; } #vphoojcuph .gt_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; margin: 10px; border-top-style: solid; border-top-width: 1px; border-top-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; overflow-x: hidden; } #vphoojcuph .gt_stub { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-right-style: solid; border-right-width: 2px; border-right-color: #D3D3D3; padding-left: 5px; padding-right: 5px; } #vphoojcuph .gt_stub_row_group { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-right-style: solid; border-right-width: 2px; border-right-color: #D3D3D3; padding-left: 5px; padding-right: 5px; vertical-align: top; } #vphoojcuph .gt_row_group_first td { border-top-width: 2px; } #vphoojcuph .gt_row_group_first th { border-top-width: 2px; } #vphoojcuph .gt_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #vphoojcuph .gt_first_summary_row { border-top-style: solid; border-top-color: #D3D3D3; } #vphoojcuph .gt_first_summary_row.thick { border-top-width: 2px; } #vphoojcuph .gt_last_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #vphoojcuph .gt_grand_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #vphoojcuph .gt_first_grand_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-top-style: double; border-top-width: 6px; border-top-color: #D3D3D3; } #vphoojcuph .gt_last_grand_summary_row_top { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-bottom-style: double; border-bottom-width: 6px; border-bottom-color: #D3D3D3; } #vphoojcuph .gt_striped { background-color: rgba(128, 128, 128, 0.05); } #vphoojcuph .gt_table_body { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #vphoojcuph .gt_footnotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #vphoojcuph .gt_footnote { margin: 0px; font-size: 90%; padding-top: 4px; padding-bottom: 4px; padding-left: 5px; padding-right: 5px; } #vphoojcuph .gt_sourcenotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #vphoojcuph .gt_sourcenote { font-size: 90%; padding-top: 4px; padding-bottom: 4px; padding-left: 5px; padding-right: 5px; } #vphoojcuph .gt_left { text-align: left; } #vphoojcuph .gt_center { text-align: center; } #vphoojcuph .gt_right { text-align: right; font-variant-numeric: tabular-nums; } #vphoojcuph .gt_font_normal { font-weight: normal; } #vphoojcuph .gt_font_bold { font-weight: bold; } #vphoojcuph .gt_font_italic { font-style: italic; } #vphoojcuph .gt_super { font-size: 65%; } #vphoojcuph .gt_footnote_marks { font-size: 75%; vertical-align: 0.4em; position: initial; } #vphoojcuph .gt_asterisk { font-size: 100%; vertical-align: 0; } #vphoojcuph .gt_indent_1 { text-indent: 5px; } #vphoojcuph .gt_indent_2 { text-indent: 10px; } #vphoojcuph .gt_indent_3 { text-indent: 15px; } #vphoojcuph .gt_indent_4 { text-indent: 20px; } #vphoojcuph .gt_indent_5 { text-indent: 25px; } TABLE 6.2: Estimates of proportion of people by levels of trust in people and government with confidence intervals, ANES 2020 Trust in Government Trust in People Always Most of the time About half the time Some of the time Never Always 0.277 (0.11, 0.444) 0.008 (0.004, 0.012) 0.015 (0.006, 0.024) 0.02 (0.008, 0.033) 0.015 (0, 0.029) Most of the time 0.185 (-0.009, 0.38) 0.175 (0.157, 0.192) 0.093 (0.078, 0.109) 0.113 (0.085, 0.141) 0.072 (0.021, 0.123) About half the time 0.198 (0.046, 0.35) 0.303 (0.281, 0.324) 0.41 (0.378, 0.441) 0.235 (0.2, 0.271) 0.173 (0.099, 0.246) Some of the time 0.286 (0.069, 0.503) 0.438 (0.415, 0.462) 0.399 (0.365, 0.433) 0.512 (0.481, 0.543) 0.238 (0.178, 0.298) Never 0.053 (-0.01, 0.117) 0.077 (0.064, 0.089) 0.083 (0.063, 0.103) 0.12 (0.097, 0.142) 0.503 (0.422, 0.583) Both methods produce the same output as the svychisq() function does account for the survey design. However, calculating the proportions directly from the design object means we can also obtain the variance information. In this case, the table output displays the survey estimate followed by the confidence intervals. Based on the output, we can see that of those who never trust people, 50.3% also never trust the government, while the proportions of never trusting the government are much lower for each of the other levels of trusting people. We may find it easier to look at these proportions graphically. We can use ggplot() and facets to provide an overview: chi_ex2_obs %&gt;% mutate(TrustPeople = str_c(&quot;Trust in People:\\n&quot;, TrustPeople)) %&gt;% ggplot(aes(x = TrustGovernment, y = Observed, color = TrustGovernment)) + facet_wrap(~TrustPeople, ncol = 5) + geom_point() + geom_errorbar(aes(ymin = Observed_low, ymax = Observed_upp)) + ylab(&quot;Proportion&quot;) + xlab(&quot;&quot;) + theme_bw() + scale_color_manual(name = &quot;Trust in Government&quot;, values = book_colors) + theme(axis.text.x = element_blank(), axis.ticks.x = element_blank(), legend.position = &quot;bottom&quot;) + guides(col = guide_legend(nrow = 2)) FIGURE 6.2: Estimates of proportion of people by levels of trust in people and government with confidence intervals, ANES 2020 Example 3: Test of Homogeneity Researchers and politicians often look at specific demographics each election cycle to understand how each group is leaning or voting toward candidates. The ANES data is post-election, but we can still see if there are differences in how specific demographic groups voted. If we want to see if there is a difference in how each age group voted for the 2020 candidates, this would be a test of homogeneity, and we can set up the hypothesis as follows: \\[\\begin{align*} H_0: p_{1_{Biden}} &amp;= p_{1_{Trump}} = p_{1_{Other}},\\\\ p_{2_{Biden}} &amp;= p_{2_{Trump}} = p_{2_{Other}},\\\\ p_{3_{Biden}} &amp;= p_{3_{Trump}} = p_{3_{Other}},\\\\ p_{4_{Biden}} &amp;= p_{4_{Trump}} = p_{4_{Other}},\\\\ p_{5_{Biden}} &amp;= p_{5_{Trump}} = p_{5_{Other}},\\\\ p_{6_{Biden}} &amp;= p_{6_{Trump}} = p_{6_{Other}} \\end{align*}\\] where \\(p_{i_{Biden}}\\) is the observed proportion of each age group (\\(i\\)) that voted for Biden, \\(p_{i_{Trump}}\\) is the observed proportion of each age group (\\(i\\)) that voted for Trump, and \\(p_{i_{Other}}\\) is the observed proportion of each age group (\\(i\\)) that voted for another candidate \\(H_A:\\) at least one category of \\(p_{i_{Biden}}\\) does not match \\(p_{i_{Trump}}\\) or \\(p_{i_{Other}}\\) To conduct this in R, we use the svychisq() function to compare the two variables: chi_ex3 &lt;- anes_des %&gt;% drop_na(VotedPres2020_selection, AgeGroup) %&gt;% svychisq(formula = ~AgeGroup + VotedPres2020_selection, design = ., statistic = &quot;Chisq&quot;, na.rm = TRUE) chi_ex3 ## ## Pearson&#39;s X^2: Rao &amp; Scott adjustment ## ## data: NextMethod() ## X-squared = 169, df = 10, p-value &lt;2e-16 The output from svychisq() indicates a difference in how each age group voted in the 2020 election. To get a better idea of the different distributions, let’s output proportions to see the relationship. As we learned in Example 2 above, we can use chi_ex3$observed, or if we want to get the variance information (which is crucial with survey data), we can use survey_mean(). Remember, when we have two variables in group_by(), we obtain the proportions within each level of the variable listed. In this case, we are looking at the distribution of AgeGroup for each level of VotedPres2020_selection. chi_ex3_obs &lt;- anes_des %&gt;% filter(VotedPres2020 == &quot;Yes&quot;) %&gt;% drop_na(VotedPres2020_selection, AgeGroup) %&gt;% group_by(VotedPres2020_selection, AgeGroup) %&gt;% summarize(Observed = round(survey_mean(vartype = &quot;ci&quot;), 3)) chi_ex3_obs %&gt;% mutate(prop = paste0(Observed, &quot; (&quot;, Observed_low, &quot;, &quot;, Observed_upp, &quot;)&quot;)) %&gt;% select(AgeGroup, VotedPres2020_selection, prop) %&gt;% pivot_wider(names_from = VotedPres2020_selection, values_from = prop) %&gt;% gt(rowname_col = &quot;AgeGroup&quot;) %&gt;% tab_stubhead(label = &quot;Age Group&quot;) %&gt;% tab_caption(&quot;Distribution of age group by presidential candidate selection with confidence intervals&quot;) #olqabbismf table { font-family: system-ui, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Noto Color Emoji'; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; } #olqabbismf thead, #olqabbismf tbody, #olqabbismf tfoot, #olqabbismf tr, #olqabbismf td, #olqabbismf th { border-style: none; } #olqabbismf p { margin: 0; padding: 0; } #olqabbismf .gt_table { display: table; border-collapse: collapse; line-height: normal; margin-left: auto; margin-right: auto; color: #333333; font-size: 16px; font-weight: normal; font-style: normal; background-color: #FFFFFF; width: auto; border-top-style: solid; border-top-width: 2px; border-top-color: #A8A8A8; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #A8A8A8; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; } #olqabbismf .gt_caption { padding-top: 4px; padding-bottom: 4px; } #olqabbismf .gt_title { color: #333333; font-size: 125%; font-weight: initial; padding-top: 4px; padding-bottom: 4px; padding-left: 5px; padding-right: 5px; border-bottom-color: #FFFFFF; border-bottom-width: 0; } #olqabbismf .gt_subtitle { color: #333333; font-size: 85%; font-weight: initial; padding-top: 3px; padding-bottom: 5px; padding-left: 5px; padding-right: 5px; border-top-color: #FFFFFF; border-top-width: 0; } #olqabbismf .gt_heading { background-color: #FFFFFF; text-align: center; border-bottom-color: #FFFFFF; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #olqabbismf .gt_bottom_border { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #olqabbismf .gt_col_headings { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #olqabbismf .gt_col_heading { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 6px; padding-left: 5px; padding-right: 5px; overflow-x: hidden; } #olqabbismf .gt_column_spanner_outer { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; padding-top: 0; padding-bottom: 0; padding-left: 4px; padding-right: 4px; } #olqabbismf .gt_column_spanner_outer:first-child { padding-left: 0; } #olqabbismf .gt_column_spanner_outer:last-child { padding-right: 0; } #olqabbismf .gt_column_spanner { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 5px; overflow-x: hidden; display: inline-block; width: 100%; } #olqabbismf .gt_spanner_row { border-bottom-style: hidden; } #olqabbismf .gt_group_heading { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; text-align: left; } #olqabbismf .gt_empty_group_heading { padding: 0.5px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: middle; } #olqabbismf .gt_from_md > :first-child { margin-top: 0; } #olqabbismf .gt_from_md > :last-child { margin-bottom: 0; } #olqabbismf .gt_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; margin: 10px; border-top-style: solid; border-top-width: 1px; border-top-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; overflow-x: hidden; } #olqabbismf .gt_stub { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-right-style: solid; border-right-width: 2px; border-right-color: #D3D3D3; padding-left: 5px; padding-right: 5px; } #olqabbismf .gt_stub_row_group { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-right-style: solid; border-right-width: 2px; border-right-color: #D3D3D3; padding-left: 5px; padding-right: 5px; vertical-align: top; } #olqabbismf .gt_row_group_first td { border-top-width: 2px; } #olqabbismf .gt_row_group_first th { border-top-width: 2px; } #olqabbismf .gt_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #olqabbismf .gt_first_summary_row { border-top-style: solid; border-top-color: #D3D3D3; } #olqabbismf .gt_first_summary_row.thick { border-top-width: 2px; } #olqabbismf .gt_last_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #olqabbismf .gt_grand_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #olqabbismf .gt_first_grand_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-top-style: double; border-top-width: 6px; border-top-color: #D3D3D3; } #olqabbismf .gt_last_grand_summary_row_top { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-bottom-style: double; border-bottom-width: 6px; border-bottom-color: #D3D3D3; } #olqabbismf .gt_striped { background-color: rgba(128, 128, 128, 0.05); } #olqabbismf .gt_table_body { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #olqabbismf .gt_footnotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #olqabbismf .gt_footnote { margin: 0px; font-size: 90%; padding-top: 4px; padding-bottom: 4px; padding-left: 5px; padding-right: 5px; } #olqabbismf .gt_sourcenotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #olqabbismf .gt_sourcenote { font-size: 90%; padding-top: 4px; padding-bottom: 4px; padding-left: 5px; padding-right: 5px; } #olqabbismf .gt_left { text-align: left; } #olqabbismf .gt_center { text-align: center; } #olqabbismf .gt_right { text-align: right; font-variant-numeric: tabular-nums; } #olqabbismf .gt_font_normal { font-weight: normal; } #olqabbismf .gt_font_bold { font-weight: bold; } #olqabbismf .gt_font_italic { font-style: italic; } #olqabbismf .gt_super { font-size: 65%; } #olqabbismf .gt_footnote_marks { font-size: 75%; vertical-align: 0.4em; position: initial; } #olqabbismf .gt_asterisk { font-size: 100%; vertical-align: 0; } #olqabbismf .gt_indent_1 { text-indent: 5px; } #olqabbismf .gt_indent_2 { text-indent: 10px; } #olqabbismf .gt_indent_3 { text-indent: 15px; } #olqabbismf .gt_indent_4 { text-indent: 20px; } #olqabbismf .gt_indent_5 { text-indent: 25px; } TABLE 6.3: Distribution of age group by presidential candidate selection with confidence intervals Age Group Biden Trump Other 18-29 0.204 (0.177, 0.231) 0.114 (0.095, 0.133) 0.227 (0.15, 0.304) 30-39 0.169 (0.153, 0.185) 0.147 (0.123, 0.17) 0.306 (0.214, 0.398) 40-49 0.163 (0.146, 0.18) 0.157 (0.136, 0.178) 0.209 (0.128, 0.29) 50-59 0.154 (0.136, 0.173) 0.234 (0.207, 0.261) 0.107 (0.041, 0.172) 60-69 0.179 (0.16, 0.199) 0.192 (0.172, 0.213) 0.102 (0.025, 0.178) 70 or older 0.13 (0.118, 0.143) 0.156 (0.139, 0.174) 0.049 (0, 0.098) We can see that the age group distribution was younger for Biden and other candidates and older for Trump. For example, of those who voted for Biden, 20.4% were in the 18-29 age group, compared to only 11.4% of those who voted for Trump were in that age group. On the other side, 23.4% of those who voted for Trump were in the 50-59 age group compared to only 15.4% of those who voted for Biden. 6.5 Exercises The exercises use the design objects anes_des and recs_des as provided in the Prerequisites box in the beginning of the chapter. Here are some exercises for practicing conducting t-tests using svyttest(): Using the RECS data, do more than 50% of U.S. households use AC (ACUsed)? ttest_solution1 &lt;- recs_des %&gt;% svyttest(design = ., formula = ((ACUsed == TRUE) - 0.5) ~ 0, na.rm = TRUE) ttest_solution1 ## ## Design-based one-sample t-test ## ## data: ((ACUsed == TRUE) - 0.5) ~ 0 ## t = 45, df = 94, p-value &lt;2e-16 ## alternative hypothesis: true mean is not equal to 0 ## 95 percent confidence interval: ## 0.3533 0.3861 ## sample estimates: ## mean ## 0.3697 Using the RECS data, does the average temperature that U.S. households set their thermostats to differ between the day and night in the winter (WinterTempDay and WinterTempNight)? ttest_solution2 &lt;- recs_des %&gt;% svyttest(design = ., formula = WinterTempDay - WinterTempNight ~ 0, na.rm = TRUE) ttest_solution2 ## ## Design-based one-sample t-test ## ## data: WinterTempDay - WinterTempNight ~ 0 ## t = 31, df = 94, p-value &lt;2e-16 ## alternative hypothesis: true mean is not equal to 0 ## 95 percent confidence interval: ## 1.787 2.028 ## sample estimates: ## mean ## 1.907 Using the ANES data, does the average age (Age) of those who voted for Biden in 2020 (VotedPres2020_selection) differ from those who voted for another candidate? ttest_solution3 &lt;- anes_des %&gt;% svyttest(design = ., formula = Age ~ VotedPres2020_selection == &quot;Biden&quot;, na.rm = TRUE) ttest_solution3 ## ## Design-based t-test ## ## data: Age ~ VotedPres2020_selection == &quot;Biden&quot; ## t = -6, df = 50, p-value = 2e-07 ## alternative hypothesis: true difference in mean is not equal to 0 ## 95 percent confidence interval: ## -4.824 -2.395 ## sample estimates: ## difference in mean ## -3.61 If you wanted to determine if the political party affiliation differed for males and females, what test would you use? Goodness of fit test (svygofchisq()) Test of independence (svychisq()) Test of homogeneity (svychisq()) chisq_solution1 &lt;- &quot;c. Test of homogeneity (`svychisq()`)&quot; chisq_solution1 ## [1] &quot;c. Test of homogeneity (`svychisq()`)&quot; In the RECS data, is there a relationship between the type of housing unit (HousingUnitType) and the year the house was built (YearMade)? chisq_solution2 &lt;- recs_des %&gt;% svychisq(formula = ~HousingUnitType + YearMade, design = ., statistic = &quot;Wald&quot;, na.rm = TRUE) chisq_solution2 ## ## Design-based Wald test of association ## ## data: NextMethod() ## F = 32, ndf = 28, ddf = 95, p-value &lt;2e-16 In the ANES data, is there a difference in the distribution of gender (Gender) across early voting status in 2020 (EarlyVote2020)? chisq_solution3 &lt;- anes_des %&gt;% svychisq(formula = ~Gender + EarlyVote2020, design = ., statistic = &quot;F&quot;, na.rm = TRUE) chisq_solution3 ## ## Pearson&#39;s X^2: Rao &amp; Scott adjustment ## ## data: NextMethod() ## F = 0.27, ndf = 1, ddf = 51, p-value = 0.6 References "],["c07-modeling.html", "Chapter 7 Modeling 7.1 Introduction 7.2 Analysis of Variance (ANOVA) 7.3 Gaussian Linear Regression 7.4 Logistic Regression 7.5 Exercises", " Chapter 7 Modeling Prerequisites For this chapter, here are the libraries and helper functions we will need: library(tidyverse) library(survey) library(srvyr) library(osfr) source(&quot;helper-fun/helper-functions.R&quot;) library(broom) We will be using data from ANES and RECS. Here is the code to create the design objects for each to use throughout this chapter. For ANES, we need to adjust the weight so it sums to the population instead of the sample (see the ANES documentation and Chapter 4 for more information). anes_in &lt;- read_osf(&quot;anes_2020.rds&quot;) targetpop &lt;- 231592693 anes_adjwgt &lt;- anes_in %&gt;% mutate(Weight = Weight/sum(Weight) * targetpop) anes_des &lt;- anes_adjwgt %&gt;% as_survey_design(weights = Weight, strata = Stratum, ids = VarUnit, nest = TRUE) For RECS, details are included in the RECS documentation and Chapter 3. recs_in &lt;- read_osf(&quot;recs_2015.rds&quot;) recs_des &lt;- recs_in %&gt;% as_survey_rep(weights = NWEIGHT, repweights = starts_with(&quot;BRRWT&quot;), type = &quot;Fay&quot;, rho = 0.5, mse = TRUE) 7.1 Introduction Modeling data is a way for researchers to investigate the relationship between a single dependent variable and one or more independent variables. This builds upon the analyses conducted in Chapter 6, which looked at the relationships between just two variables. For example, in Example 3 in Section 6.3.2, we investigated if there is a relationship between the electrical bill cost and whether or not the household used air-conditioning. However, there are potentially other elements that could go into what the cost of electrical bill is in a household (e.g., outside temperature, desired internal temperature, types and number of appliances, etc.). T-tests only allow us to investigate the relationship of one independent variable at a time, but using models we can look into multiple variables and even explore interactions between these variables. There are several types of models, but in this chapter we will cover Analysis of Variance (ANOVA) and linear regression models following common Gaussian and logit distributions. Jonas Kristoffer Lindeløv has an interesting discussion of many statistical tests and models being equivalent to a linear model. For example, a one-way ANOVA is a linear model with one categorical independent variable, and a two-sample t-test is an ANOVA where the independent variable has exactly two levels. When modeling data, it is helpful to first create an equation that provides an overview as to what it is that we are modeling. The main structure of these models is as follows: \\[y_i=\\beta_0 +\\sum_{i=1}^p \\beta_i x_i + \\epsilon_i\\] where \\(y_i\\) is the outcome, \\(\\beta_0\\) is an intercept, \\(x_1, \\cdots, x_p\\) are the predictors with \\(\\beta_1, \\cdots, \\beta_p\\) as the associated coefficients, and \\(\\epsilon_i\\) is the error. Different models may not include an intercept, have interactions between different independent variables (\\(x_i\\)), or may have different underlying structures for the dependent variable (\\(y_i\\)). However, all linear models have the independent variables related to the dependent variable in a linear form. To specify these models in R, the formulas are the same with both survey data and other data. The left side of the formula is the response/dependent variable, and the right side of the formula has the predictor/independent variable(s). There are many symbols used in R to specify the formula. For example, a linear formula mathematically specified as \\[Y_i=\\beta_0+\\beta_1 X_i+\\epsilon_i\\] would be specified in R as y~x where the intercept is not explicitly included. To fit a model with no intercept, that is, \\[Y_i=\\beta_1 X_i+\\epsilon_i\\] it can be specified as y~x-1. Formula notation details in R can be found in the help file for formula28. A quick overview of the common formula notation is in the following table: Common symbols in formula notation Symbol Example Meaning + +X include this variable - -X delete this variable : X:Z include the interaction between these variables * X*Z include these variables and the interactions between them ^n (X+Z+Y)^3 include these variables and all interactions up to n-way I I(X-Z) as-as: include a new variable which is the difference of these variables There are often multiple ways to specify the same formula. For example, consider the following equation using the mtcars data \\[mpg_i=\\beta_0+\\beta_1cyl_{i}+\\beta_2disp_{i}+\\beta_3hp_{i}+\\beta_4cyl_{i}disp_{i}+\\beta_5cyl_{i}hp_{i}+\\beta_6disp_{i}hp_{i}+\\epsilon_i\\] This could be specified as any of the following: mpg~(cyl+disp+hp)^2 mpg~cyl+disp+hp+cyl:disp+cyl:hp+disp:hp mpg~cyl*disp+cyl*hp+disp*hp Note that the following two specifications are not the same: mpg~cyl:disp:hp this only has the interactions and not the main effect mpg~cyl*disp*hp this also has the 3-way interaction in addition to the main effects and 2-way interactions When using non-survey data such as experimental or observational data, researchers will use the glm() function for linear models. With survey data, however, we use svyglm() from the {survey} package to ensure that we account for the survey design and weights in modeling29. This allows us to generalize a model to the target population and accounts for the fact that the observations in the survey data may not be independent. As discussed in Chapter 6, modeling survey data cannot be directly done in {srvyr}, but can be done in the {survey} (Lumley 2010, 2023) package. In this chapter, we will provide syntax and examples for linear models, including ANOVA, Gaussian linear regression, and logistic regression. For details on other types of regression, including ordinal regression, log-linear models, and survival analysis, refer to Lumley (2010). Lumley (2010) also discusses custom models such as a negative binomial or Poisson model in Appendix E of his book. 7.2 Analysis of Variance (ANOVA) In ANOVA, we are testing whether the mean of an outcome is the same across two or more groups. Statistically, we set up this as follows: \\(H_0: \\mu_1 = \\mu_2= \\dots = \\mu_k\\) where \\(\\mu_i\\) is the mean outcome for group \\(i\\) \\(H_A: \\text{At least one mean is different}\\) Some assumptions when using ANOVA on survey data include: The outcome variable is normally distributed within each group The variances of the outcome variable between each group are approximately equal We do NOT assume independence between the groups as with general ANOVA. The covariance is accounted for in the survey design 7.2.1 Syntax To perform this type of analysis in R, the general syntax is as follows: des_obj %&gt;% svyglm( formula = outcome ~ group, design = ., na.action = na.omit, df.resid = NULL ) The arguments are: formula: Formula in the form of outcome~group. The group variable must be a factor or character. design: a tbl_svy object created by as_survey na.action: handling of missing data df.resid: degrees of freedom for Wald tests (optional) - defaults to using degf(design)-(g-1) where \\(g\\) is the number of groups The function svyglm() does not have the design as the first argument so the dot (.) notation is used to pass it with a pipe (see Chapter 6 for more details). The default for missing data is na.omit, this means that we are removing all records with any missing data in either predictors or outcomes from analyses. There are other options for handling missing data and we recommend looking at the help documentation for na.omit (run help(na.omit) or ?na.omit) for more information on options to use for na.action. For a discussion of how to handle missing data see Chapter 4. 7.2.2 Example Looking at an example will help us discuss the output and how to interpret the results. In RECS, respondents are asked what temperature they set their thermostat to during the day and evening when using the air-conditioning during the summer. To analyze this data, we filter the respondents to only those using AC (ACUsed). Then if we want to see if there are differences by region, we can use group_by(). A descriptive analysis of the temperature at night (SummerTempNight) set by region and the sample sizes is displayed below. recs_des %&gt;% filter(ACUsed) %&gt;% group_by(Region) %&gt;% summarize(SMN = survey_mean(SummerTempNight, na.rm = TRUE), n = unweighted(n()), n_na = unweighted(sum(is.na(SummerTempNight)))) ## # A tibble: 4 × 5 ## Region SMN SMN_se n n_na ## &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; ## 1 Northeast 70.5 0.197 682 0 ## 2 Midwest 71.4 0.151 1235 0 ## 3 South 72.0 0.118 1917 0 ## 4 West 72.1 0.299 1115 0 In the following code, we test whether this temperature varies by region by first using svyglm() to run the test and then using broom::tidy() to display the output. Note that the temperature setting is set to NA when the household does not use air-conditioning, and thus na.action=na.omit is specified to ignore these cases. anova_out &lt;- recs_des %&gt;% svyglm(design = ., formula = SummerTempNight ~ Region, na.action = na.omit) tidy(anova_out) ## # A tibble: 4 × 5 ## term estimate std.error statistic p.value ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 (Intercept) 70.5 0.197 358. 1.84e-146 ## 2 RegionMidwest 0.874 0.253 3.46 8.18e- 4 ## 3 RegionSouth 1.49 0.231 6.45 5.20e- 9 ## 4 RegionWest 1.66 0.353 4.70 9.27e- 6 In the output above, we can see the estimated coefficients (estimate), estimated standard errors of the coefficients (std.error), the t-statistic (statistic), and the p-value for each coefficient. In this output, the intercept represents the reference value of the Northeast region30. The other coefficients indicate the difference in temperature relative to the Northeast region. For example, in the Midwest, temperatures are set, on average, 0.874 degrees higher than in the Northeast during summer nights. 7.3 Gaussian Linear Regression Gaussian linear regression is a more generalized method than ANOVA where we fit a model of a continuous outcome with any number of categorical or continuous predictors, such that \\[y_i=\\beta_0 +\\sum_{i=1}^p \\beta_i x_i + \\epsilon_i\\] where \\(y_i\\) is the outcome, \\(\\beta_0\\) is an intercept, \\(x_1, \\cdots, x_n\\) are the predictors with \\(\\beta_1, \\cdots, \\beta_p\\) as the associated coefficients, and \\(\\epsilon_i\\) is the error. Assumptions in Gaussian linear regression using survey data include: The residuals (\\(\\epsilon_i\\)) are normally distributed, but there is not an assumption of independence, and the correlation structure is captured in the survey design object There is a linear relationship between the outcome variable and the independent variables The residuals are homoscedastic, that is, the error term is the same across all values of independent variables 7.3.1 Syntax The syntax for this regression uses the same function as ANOVA, but can have more than one variable listed on the right-hand side of the formula: des_obj %&gt;% svyglm( formula = outcomevar ~ x1 + x2 + x3, design = ., na.action = na.omit, df.resid = NULL ) The arguments are: formula: Formula in the form of y~x design: a tbl_svy object created by as_survey na.action: handling of missing data df.resid: degrees of freedom for Wald tests (optional) - defaults to using degf(design)-p where \\(p\\) is the rank of the design matrix As discussed at the beginning of the chapter, the formula on the right-hand side can be specified in many ways, whether interactions are desired or not, for example. 7.3.2 Examples Example 1: Linear Regression with Single Variable On RECS, we can obtain information on the square footage of homes and the electric bills. We assume that square footage is related to the amount of money spent on electricity and examine a model for this. Before any modeling, we first plot the data to determine whether it is reasonable to assume a linear relationship. In Figure 7.1, each hexagon represents the weighted count of households in the bin and we can see a general positive linear trend (as the square footage increases so does the amount of money spent on electricity). FIGURE 7.1: Relationship between square footage and dollars spent on electricity, RECS 2015 Given that the plot shows a potential relationship, fitting a model will allow us to determine if the relationship is statistically significant. The model is fit below with electricity expenditure as the outcome. m_electric_sqft &lt;- recs_des %&gt;% svyglm(design = ., formula = DOLLAREL ~ TOTSQFT_EN, na.action = na.omit) tidy(m_electric_sqft) ## # A tibble: 2 × 5 ## term estimate std.error statistic p.value ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 (Intercept) 880. 26.3 33.4 5.51e-54 ## 2 TOTSQFT_EN 0.246 0.0134 18.4 6.01e-33 In the output above, we can see the estimated coefficients (estimate), estimated standard errors of the coefficients (std.error), the t-statistic (statistic), and the p-value for each coefficient. In these results, we can say that, on average, for every additional square foot of house size, the electricity bill increases by 24.6 cents and that square footage is significantly associated with electricity expenditure. This is a very simple model, and there are likely many more factors in electricity expenditure, including the type of cooling, number of appliances, location, and more. However, often starting with one variable models can help researchers understand what potential relationships there are between variables before fitting more complex models. Often researchers start with known relationships before building models to determine what impact additional variables have on the model. Example 2: Linear Regression with Additional Variables and Interactions In the following example, a model is fit to predict electricity expenditure, including Census region (factor/categorical), urbanicity (factor/categorical), square footage (double/numeric), and whether air-conditioning is used (logical/categorical) with all two-way interactions also included. As a reminder, using -1 means that we are fitting this model without an intercept. m_electric_multi &lt;- recs_des %&gt;% svyglm(design = ., formula = DOLLAREL ~ (Region + Urbanicity + TOTSQFT_EN + ACUsed)^2 - 1, na.action = na.omit) tidy(m_electric_multi) %&gt;% print(n = 50) ## # A tibble: 25 × 5 ## term estimate std.error statistic p.value ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 RegionNortheast 6.19e+2 94.8 6.53 8.42e- 9 ## 2 RegionMidwest 4.98e+2 79.4 6.27 2.47e- 8 ## 3 RegionSouth 8.55e+2 97.4 8.78 6.01e-13 ## 4 RegionWest 4.76e+2 60.8 7.83 3.49e-11 ## 5 UrbanicityUrban Cluster -1.18e+2 116. -1.02 3.12e- 1 ## 6 UrbanicityRural 2.22e+2 107. 2.07 4.16e- 2 ## 7 TOTSQFT_EN 1.96e-1 0.0474 4.13 9.69e- 5 ## 8 ACUsedTRUE 2.85e+2 105. 2.72 8.30e- 3 ## 9 RegionMidwest:UrbanicityUrban … 3.16e+2 101. 3.13 2.51e- 3 ## 10 RegionSouth:UrbanicityUrban Cl… 4.00e+1 107. 0.373 7.10e- 1 ## 11 RegionWest:UrbanicityUrban Clu… 2.39e+2 112. 2.13 3.65e- 2 ## 12 RegionMidwest:UrbanicityRural 4.68e+2 89.8 5.21 1.77e- 6 ## 13 RegionSouth:UrbanicityRural 1.74e+2 99.2 1.76 8.31e- 2 ## 14 RegionWest:UrbanicityRural 1.64e+2 105. 1.57 1.21e- 1 ## 15 RegionMidwest:TOTSQFT_EN -5.24e-2 0.0364 -1.44 1.55e- 1 ## 16 RegionSouth:TOTSQFT_EN 6.08e-2 0.0426 1.43 1.58e- 1 ## 17 RegionWest:TOTSQFT_EN 3.50e-2 0.0441 0.793 4.30e- 1 ## 18 RegionMidwest:ACUsedTRUE -1.34e+2 110. -1.22 2.26e- 1 ## 19 RegionSouth:ACUsedTRUE -1.36e+2 106. -1.29 2.02e- 1 ## 20 RegionWest:ACUsedTRUE -6.26e+1 100. -0.625 5.34e- 1 ## 21 UrbanicityUrban Cluster:TOTSQF… -2.09e-2 0.0337 -0.619 5.38e- 1 ## 22 UrbanicityRural:TOTSQFT_EN -7.89e-2 0.0269 -2.93 4.56e- 3 ## 23 UrbanicityUrban Cluster:ACUsed… -3.37e+1 88.5 -0.380 7.05e- 1 ## 24 UrbanicityRural:ACUsedTRUE 3.10e+0 89.7 0.0345 9.73e- 1 ## 25 TOTSQFT_EN:ACUsedTRUE 5.20e-2 0.0371 1.40 1.65e- 1 As shown above, there are many terms in this model. To test whether coefficients for a term are different from zero, the function regTermTest() can be used. For example, in the above regression, we can test whether the interaction of region and urbanicity is significant as follows: urb_reg_test &lt;- regTermTest(m_electric_multi, ~Urbanicity:Region) urb_reg_test ## Wald test for Urbanicity:Region ## in svyglm(design = ., formula = DOLLAREL ~ (Region + Urbanicity + ## TOTSQFT_EN + ACUsed)^2 - 1, na.action = na.omit) ## F = 7.167 on 6 and 71 df: p= 5.3e-06 This output indicates there is a significant interaction between urbanicity and region (p-value=\\(5.34\\times 10^{-6}\\)). To examine the predictions, residuals and more from the model, the function augment() from {broom} can be used. The augment() function will return a tibble with the independent and dependent variables and other fit statistics. The augment() function has not been specifically written for objects of class svyglm, and as such, a warning will be displayed indicating this at this time. As it was not written exactly for this class of objects, a little tweaking needs to be done after using augment to get the predicted (.fitted) and standard error (.se.fit) values. To obtain the standard error of the fitted values we need to use the attr() function on the .fitted values created by augment(). fitstats &lt;- augment(m_electric_multi) %&gt;% mutate(.se.fit = sqrt(attr(.fitted, &quot;var&quot;)), .fitted = as.numeric(.fitted)) fitstats ## # A tibble: 5,686 × 13 ## DOLLAREL Region Urbanicity TOTSQFT_EN ACUsed `(weights)` .fitted ## &lt;dbl&gt; &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; &lt;lgl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 967. West Urban Area 1808 TRUE 0.581 1209. ## 2 1366 South Rural 759 TRUE 0.693 1577. ## 3 2428. South Urban Area 2288 TRUE 1.12 1710. ## 4 1313. Midwest Urban Clust… 2573 TRUE 0.585 1261. ## 5 581. Northeast Urban Area 1024 TRUE 0.804 1157. ## 6 494 Northeast Urban Clust… 623 TRUE 1.25 893. ## 7 372. South Urban Area 832 TRUE 2.21 1261. ## 8 1737. Midwest Rural 2682 TRUE 0.735 1654. ## 9 1532. Northeast Urban Area 1900 TRUE 0.675 1375. ## 10 1974. South Urban Area 1230 TRUE 2.09 1383. ## # ℹ 5,676 more rows ## # ℹ 6 more variables: .resid &lt;dbl&gt;, .hat &lt;dbl&gt;, .sigma &lt;dbl&gt;, ## # .cooksd &lt;dbl&gt;, .std.resid &lt;dbl&gt;, .se.fit &lt;dbl&gt; These results can then be used in a variety of ways, including examining residual plots as illustrated in the code below and Figure 7.2. fitstats %&gt;% ggplot(aes(x = .fitted, .resid)) + geom_point() + geom_hline(yintercept = 0, color = &quot;red&quot;) + theme_minimal() + xlab(&quot;Fitted value of electricity cost&quot;) + ylab(&quot;Residual of model&quot;) + scale_y_continuous(labels = scales::dollar_format()) + scale_x_continuous(labels = scales::dollar_format()) FIGURE 7.2: Residual plot of electric cost model with covariates Region, Urbanicity, TOTSQFT_EN, and ACUsed Additionally, augment() can be used to predict outcomes for data not used in modeling. Perhaps, we would like to predict the energy expenditure for a home in an urban area in the south that uses air-conditioning and is 2,500 square feet. To do this, we first make a tibble including that additional data and then use the newdata argument in the augment() function. As before, to obtain the standard error of the predicted values we need to use the attr() function. add_data &lt;- recs_in %&gt;% select(DOEID, Region, Urbanicity, TOTSQFT_EN, ACUsed, DOLLAREL) %&gt;% rbind(tibble(DOEID = NA, Region = &quot;South&quot;, Urbanicity = &quot;Urban Area&quot;, TOTSQFT_EN = 2500, ACUsed = TRUE, DOLLAREL = NA)) %&gt;% tail(1) pred_data &lt;- augment(m_electric_multi, newdata = add_data) %&gt;% mutate(.se.fit = sqrt(attr(.fitted, &quot;var&quot;)), .fitted = as.numeric(.fitted)) pred_data ## # A tibble: 1 × 8 ## DOEID Region Urbanicity TOTSQFT_EN ACUsed DOLLAREL .fitted .se.fit ## &lt;dbl&gt; &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; &lt;lgl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 NA South Urban Area 2500 TRUE NA 1775. 37.2 In the above example, it is predicted that the energy expenditure would be $1775.48. 7.4 Logistic Regression Logistic regression is used to model a binary outcome and is a specific case of the generalized linear model (GLM). A GLM uses a link function to link the response variable to the linear model. In logistic regression, the link model is the logit function. Specifically, the model is specified as follows: \\[ y_i \\sim \\text{Bernoulli}(\\pi_i)\\] \\[\\begin{equation} \\log \\left(\\frac{\\pi_i}{1-\\pi_i} \\right)=\\beta_0 +\\sum_{i=1}^p \\beta_i x_i \\tag{7.1} \\end{equation}\\] which can be re-expressed as \\[ \\pi_i=\\frac{\\exp \\left(\\beta_0 +\\sum_{i=1}^p \\beta_i x_i \\right)}{1+\\exp \\left(\\beta_0 +\\sum_{i=1}^p \\beta_i x_i \\right)}.\\] where \\(y_i\\) is the outcome, \\(\\beta_0\\) is an intercept, and \\(x_1, \\cdots, x_n\\) are the predictors with \\(\\beta_1, \\cdots, \\beta_n\\) as the associated coefficients. Assumptions in logistic regression using survey data include: The outcome variable has two levels There is a linear relationship between the independent variables and the log odds (Equation (7.1)) The residuals are homoscedastic, that is, the error term is the same across all values of independent variables 7.4.1 Syntax The syntax for logistic regression is as follows: des_obj %&gt;% svyglm( formula = outcomevar ~ x1 + x2 + x3, design = ., na.action = na.omit, df.resid = NULL, family = quasibinomial ) he arguments are: formula: Formula in the form of y~x design: a tbl_svy object created by as_survey na.action: handling of missing data df.resid: degrees of freedom for Wald tests (optional) - defaults to using degf(design)-p where \\(p\\) is the rank of the design matrix family: the error distribution/link function to be used in the model Note svyglm() is the same function used in both ANOVA and linear regression. However, we’ve added the link function quasibinomial. While we can use the binomial link function, it is recommended to use the quasibinomial as our weights may not be integers, and the quasibinomial also allows for overdispersion. The quasibinomial family has a default logit link which is what is specified in the equations above. When specifying the outcome variable, it will likely be specified in one of two ways with survey data: A two level factor variable where the first level of the factor indicates a “failure” and the second level indicates a “success” A numeric variable which is 1 or 0 where 1 indicates a success A logical variable where TRUE indicates a success 7.4.2 Examples Example 1: Logistic Regression with Single Variable In the following example, the ANES data is used, and we are modeling whether someone usually has trust in the government31 by who someone voted for president in 2020. As a reminder, the leading candidates were Biden and Trump though people could vote for someone else not in the Democratic or Republican parties. Those votes are all grouped into an “Other” category. We first create a binary outcome for trusting in the government and plot the data. A scatter plot of the raw data is not useful as it is all 0 and 1 outcomes, so instead, we plot a summary of the data. anes_des_der &lt;- anes_des %&gt;% mutate(TrustGovernmentUsually = case_when(is.na(TrustGovernment) ~ NA, TRUE ~ TrustGovernment %in% c(&quot;Always&quot;, &quot;Most of the time&quot;))) anes_des_der %&gt;% group_by(VotedPres2020_selection) %&gt;% summarize(pct_trust = survey_mean(TrustGovernmentUsually, na.rm = TRUE, proportion = TRUE, vartype = &quot;ci&quot;), .groups = &quot;drop&quot;) %&gt;% filter(complete.cases(.)) %&gt;% ggplot(aes(x = VotedPres2020_selection, y = pct_trust, fill = VotedPres2020_selection)) + geom_bar(stat = &quot;identity&quot;) + geom_errorbar(aes(ymin = pct_trust_low, ymax = pct_trust_upp), width = 0.2) + scale_fill_manual(values = c(&quot;#0b3954&quot;, &quot;#bfd7ea&quot;, &quot;#8d6b94&quot;)) + xlab(&quot;Election choice (2022)&quot;) + ylab(&quot;Usually trust the government&quot;) + scale_y_continuous(labels = scales::percent) + guides(fill = &quot;none&quot;) + theme_minimal() FIGURE 7.3: Relationship between candidate selection and trust in government, ANES 2020 By looking at Figure 7.3 it appears that people who voted for Trump are more likely to say that they usually have trust in the government compared to those who voted for Biden and Other candidates. To determine if this insight is accurate, we next we fit the model. logistic_trust_vote &lt;- anes_des_der %&gt;% svyglm(design = ., formula = TrustGovernmentUsually ~ VotedPres2020_selection, family = quasibinomial) tidy(logistic_trust_vote) ## # A tibble: 3 × 5 ## term estimate std.error statistic p.value ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 (Intercept) -1.96 0.0740 -26.5 1.10e-30 ## 2 VotedPres2020_selectionTrump 0.397 0.102 3.90 2.89e- 4 ## 3 VotedPres2020_selectionOther -0.768 0.462 -1.66 1.03e- 1 In the output above, we can see the estimated coefficients (estimate), estimated standard errors of the coefficients (std.error), the t-statistic (statistic), and the p-value for each coefficient. This output indicates that respondents who voted for Trump are 0.397 times more likely to usually have trust in the government compared to those who voted for Biden (the reference level). Sometimes it is easier to talk about the odds instead of the likelihood. In this case, we can also see the exponentiated coefficients which illustrates the odds: tidy(logistic_trust_vote, exponentiate = TRUE) %&gt;% select(term, estimate) ## # A tibble: 3 × 2 ## term estimate ## &lt;chr&gt; &lt;dbl&gt; ## 1 (Intercept) 0.141 ## 2 VotedPres2020_selectionTrump 1.49 ## 3 VotedPres2020_selectionOther 0.464 We can interpret this as saying that the odds of usually trusting the government for someone who voted for Trump is 149% as likely to trust the government compared to a person who voted for Biden (the reference level). In comparison, a person who voted for neither Biden nor Trump is 46.4% as likely to trust the government as someone who voted for Biden. As with linear regression, the augment() can be used to predict values. By default, the prediction is the link function and not the probability. To predict the probability, add an argument of type.predict=\"response\" as demonstrated below: logistic_trust_vote %&gt;% augment(type.predict = &quot;response&quot;) %&gt;% mutate(.se.fit = sqrt(attr(.fitted, &quot;var&quot;)), .fitted = as.numeric(.fitted)) %&gt;% select(TrustGovernmentUsually, VotedPres2020_selection, .fitted, .se.fit) ## # A tibble: 5,860 × 4 ## TrustGovernmentUsually VotedPres2020_selection .fitted .se.fit ## &lt;lgl&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 FALSE Other 0.0614 0.0266 ## 2 FALSE Biden 0.124 0.00801 ## 3 FALSE Biden 0.124 0.00801 ## 4 FALSE Trump 0.173 0.00959 ## 5 FALSE Biden 0.124 0.00801 ## 6 FALSE Trump 0.173 0.00959 ## 7 FALSE Biden 0.124 0.00801 ## 8 TRUE Biden 0.124 0.00801 ## 9 FALSE Biden 0.124 0.00801 ## 10 FALSE Trump 0.173 0.00959 ## # ℹ 5,850 more rows Example 2: Interaction Effects Let’s look at another example with interaction effects. If we’re interested in understanding the demographics of people who voted for Biden, we could include Gender and Education in our model. First we need to create an indicator for voted for Biden. Note that this indicator places anyone who did not vote at all into VoteBiden = 0. anes_des_ind &lt;- anes_des %&gt;% mutate(VoteBiden = case_when(VotedPres2020_selection == &quot;Biden&quot; ~ 1, TRUE ~ 0)) Let’s first look at the main effects of gender and education. log_biden_main &lt;- anes_des_ind %&gt;% svyglm(design = ., formula = VoteBiden ~ Gender + Education, family = quasibinomial) tidy(log_biden_main) ## # A tibble: 6 × 5 ## term estimate std.error statistic p.value ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 (Intercept) -1.36 0.185 -7.35 2.69e- 9 ## 2 GenderFemale 0.109 0.0719 1.51 1.37e- 1 ## 3 EducationHigh school 0.440 0.198 2.22 3.11e- 2 ## 4 EducationPost HS 0.674 0.171 3.94 2.76e- 4 ## 5 EducationBachelor&#39;s 1.24 0.179 6.92 1.20e- 8 ## 6 EducationGraduate 1.56 0.198 7.88 4.47e-10 This main effect model indicates that respondents with a graduate degree are 1.56 times more likely to vote for Biden compared to respondents with less than a high school degree. However, we see that gender is not significant. It is possible that there is an interaction between gender and education. To determine this we can create a model that includes the interaction effects: log_biden_int &lt;- anes_des_ind %&gt;% svyglm(design = ., formula = VoteBiden ~ (Gender + Education)^2, family = quasibinomial) tidy(log_biden_int) ## # A tibble: 10 × 5 ## term estimate std.error statistic p.value ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 (Intercept) -1.10 0.276 -3.99 2.58e-4 ## 2 GenderFemale -0.484 0.411 -1.18 2.46e-1 ## 3 EducationHigh school 0.137 0.311 0.442 6.61e-1 ## 4 EducationPost HS 0.436 0.279 1.56 1.26e-1 ## 5 EducationBachelor&#39;s 1.03 0.282 3.66 6.92e-4 ## 6 EducationGraduate 1.11 0.290 3.83 4.25e-4 ## 7 GenderFemale:EducationHigh scho… 0.676 0.458 1.47 1.48e-1 ## 8 GenderFemale:EducationPost HS 0.554 0.416 1.33 1.91e-1 ## 9 GenderFemale:EducationBachelor&#39;s 0.490 0.416 1.18 2.45e-1 ## 10 GenderFemale:EducationGraduate 0.958 0.418 2.29 2.70e-2 The results from the interaction model show a single interaction effect that is significant. To better understand what this interaction means, we will want to plot the predicted probabilities. Let’s first obtain the predicted probabilities for each possible combination of variables using the augment() function. log_biden_pred &lt;- log_biden_int %&gt;% augment(type.predict = &quot;response&quot;) %&gt;% mutate(.se.fit = sqrt(attr(.fitted, &quot;var&quot;)), .fitted = as.numeric(.fitted)) %&gt;% select(VoteBiden, Gender, Education, .fitted, .se.fit) We can then use this information to plot the predicted probabilities to better understand the interaction effects. To create an interaction plot, the y-axis will be the predicted probabilities, and one of our x-variables will be on the x-axis and the other will be represented by multiple lines. Figure 7.4 shows the interaction plot with the gender variable on the x-axis and education represented by the lines. biden_int_plot &lt;- log_biden_pred %&gt;% filter(VoteBiden == 1) %&gt;% distinct() %&gt;% arrange(Gender, Education) %&gt;% mutate(Education = fct_reorder2(Education, Gender, .fitted)) %&gt;% ggplot(aes(x = Gender, y = .fitted, group = Education, color = Education, linetype = Education)) + geom_line(linewidth = 1.1) + scale_color_manual(values = book_colors) + ylab(&quot;Predicted Probability of Voting for Biden&quot;) + guides(fill = &quot;none&quot;) + theme_minimal() biden_int_plot FIGURE 7.4: Interaction Plot of Gender and Education Predicting the Probability of Voting for Biden From this plot we can see that respondents who indicated a male gender and had less than a high school education were more likely to vote for Biden than females among those with less than a high school education. Additionally, females with a graduate degree were more likely to vote for Biden than males with a graduate degree. Interactions in models can be difficult to understand from the coefficients alone. Using these interaction plots can help others understand the nuances of the results. 7.5 Exercises The type of housing unit may have an impact on energy expenses. Is there any relationship between housing unit type (HousingUnitType) and total energy expenditure (TOTALDOL)? First, find the average energy expenditure by housing unit type as a descriptive analysis and then do the test. The reference level in the comparison should be the housing unit type that is most common. recs_des %&gt;% group_by(HousingUnitType) %&gt;% summarize(Expense = survey_mean(TOTALDOL, na.rm = TRUE), HUs = survey_total()) %&gt;% arrange(desc(HUs)) ## # A tibble: 5 × 5 ## HousingUnitType Expense Expense_se HUs HUs_se ## &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Single-family detached 2193. 22.0 73871041. 0.00645 ## 2 Apartment: 5 or more units 1048. 21.2 21147792. 0.00271 ## 3 Apartment: 2-4 Units 1332. 36.6 9392242. 0.000239 ## 4 Single-family attached 1607. 33.8 7010132. 0.0253 ## 5 Mobile home 1752. 60.2 6787043. 0.0183 exp_unit_out &lt;- recs_des %&gt;% mutate(HousingUnitType = fct_infreq(HousingUnitType, NWEIGHT)) %&gt;% svyglm(design = ., formula = TOTALDOL ~ HousingUnitType, na.action = na.omit) tidy(exp_unit_out) ## # A tibble: 5 × 5 ## term estimate std.error statistic p.value ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 (Intercept) 2193. 22.0 99.6 1.07e-94 ## 2 HousingUnitTypeApartment: 5 or … -1145. 30.6 -37.4 5.08e-57 ## 3 HousingUnitTypeApartment: 2-4 U… -861. 42.2 -20.4 1.06e-35 ## 4 HousingUnitTypeSingle-family at… -585. 41.2 -14.2 8.02e-25 ## 5 HousingUnitTypeMobile home -441. 61.8 -7.13 2.33e-10 # Single-family detached units are most common There is a significant # relationship between energy expenditure and housing unit type Does temperature play a role in energy expenditure? Cooling degree days are a measure of how hot a place is. CDD65 for a given day indicates the number of degrees Fahrenheit warmer than 65°F (18.3°C) it is in a location. On a day that averages 65°F and below, CDD65=0. While a day that averages 85°F would have CDD80=20 because it is 20 degrees warmer. For each day in the year, this is summed to give an indicator of how hot the place is throughout the year. Similarly, HDD65 indicates the days colder than 65°F (18.3°C)32. Can energy expenditure be predicted using these temperature indicators along with square footage? Is there a significant relationship? Include main effects and two-way interactions. temps_sqft_exp &lt;- recs_des %&gt;% svyglm(design = ., formula = DOLLAREL ~ (TOTSQFT_EN + CDD65 + HDD65)^2, na.action = na.omit) tidy(temps_sqft_exp) ## # A tibble: 7 × 5 ## term estimate std.error statistic p.value ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 (Intercept) 353. 110. 3.20 0.00193 ## 2 TOTSQFT_EN 0.420 0.0643 6.53 0.00000000398 ## 3 CDD65 0.128 0.0321 4.00 0.000128 ## 4 HDD65 0.0399 0.0172 2.32 0.0226 ## 5 TOTSQFT_EN:CDD65 -0.00000150 0.0000177 -0.0852 0.932 ## 6 TOTSQFT_EN:HDD65 -0.0000366 0.00000922 -3.97 0.000143 ## 7 CDD65:HDD65 0.0000232 0.00000835 2.78 0.00660 Continuing with our results from question 2, create a plot between the actual and predicted expenditures and a residual plot for the predicted expenditures. temps_sqft_exp_fit &lt;- temps_sqft_exp %&gt;% augment() %&gt;% mutate(.se.fit = sqrt(attr(.fitted, &quot;var&quot;)), # extract the variance of the fitted value .fitted = as.numeric(.fitted)) temps_sqft_exp_fit %&gt;% ggplot(aes(x = DOLLAREL, y = .fitted)) + geom_point() + geom_abline(intercept = 0, slope = 1, color = &quot;red&quot;) + xlab(&quot;Actual expenditures&quot;) + ylab(&quot;Predicted expenditures&quot;) + theme_minimal() FIGURE 7.5: Actual and predicted electricity expenditures temps_sqft_exp_fit %&gt;% ggplot(aes(x = .fitted, y = .resid)) + geom_point() + geom_hline(yintercept = 0, color = &quot;red&quot;) + xlab(&quot;Predicted expenditure&quot;) + ylab(&quot;Residual value of expenditure&quot;) + theme_minimal() FIGURE 7.6: Residual plot of electric cost model with covariates TOTSQFT_EN, CDD65, and HDD65 Early voting expanded in 202033. Build a logistic model predicting early voting in 2020 (EarlyVote2020) using age (Age), education (Education), and party identification (PartyID). Include two-way interactions. earlyvote_mod &lt;- anes_des %&gt;% filter(!is.na(EarlyVote2020)) %&gt;% svyglm(design = ., formula = EarlyVote2020 ~ (Age + Education + PartyID)^2, family = quasibinomial) tidy(earlyvote_mod) %&gt;% arrange(p.value) ## # A tibble: 46 × 5 ## term estimate std.error statistic p.value ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Age:PartyIDIndependent -0.0585 0.0163 -3.58 0.0116 ## 2 PartyIDIndependent 4.99 1.62 3.09 0.0214 ## 3 Age:PartyIDNot very strong repu… -0.0494 0.0197 -2.51 0.0460 ## 4 PartyIDNot very strong republic… 4.03 1.64 2.46 0.0488 ## 5 (Intercept) 1.57 0.870 1.80 0.121 ## 6 EducationGraduate 1.47 0.973 1.51 0.183 ## 7 EducationHigh school:PartyIDStr… -1.33 1.00 -1.32 0.235 ## 8 PartyIDStrong republican 1.63 1.28 1.27 0.253 ## 9 EducationGraduate:PartyIDStrong… -1.21 0.998 -1.21 0.272 ## 10 EducationPost HS:PartyIDIndepen… -1.50 1.35 -1.11 0.311 ## # ℹ 36 more rows Continuing from Exercise 1, predict the probability of early voting for two people. Both are 28 years old and have a graduate degree, but one person is a strong Democrat, and the other is a strong Republican. add_vote_dat &lt;- anes_in %&gt;% select(EarlyVote2020, Age, Education, PartyID) %&gt;% rbind(tibble( EarlyVote2020 = NA, Age = 28, Education = &quot;Graduate&quot;, PartyID = c(&quot;Strong democrat&quot;, &quot;Strong republican&quot;) )) %&gt;% tail(2) log_ex_2_out &lt;- earlyvote_mod %&gt;% augment(newdata = add_vote_dat, type.predict = &quot;response&quot;) %&gt;% mutate(.se.fit = sqrt(attr(.fitted, &quot;var&quot;)), # extract the variance of the fitted value .fitted = as.numeric(.fitted)) References "],["c08-communicating-results.html", "Chapter 8 Communicating Results 8.1 Introduction 8.2 Describing Results through Text 8.3 Visualizing Data 8.4 Reproducibility", " Chapter 8 Communicating Results Prerequisites For this chapter, here are the packages and helper functions we will need: library(tidyverse) library(survey) library(srvyr) library(osfr) source(&quot;helper-fun/helper-functions.R&quot;) library(gt) library(gtsummary) We will be using data from ANES. Here is the code to create the ANES design object that will be used throughout the chapter. For ANES, we need to adjust the weight so it sums to the population instead of the sample (see the ANES documentation and Chapter 4 for more information). anes_in &lt;- read_osf(&quot;anes_2020.rds&quot;) targetpop &lt;- 231592693 anes_adjwgt &lt;- anes_in %&gt;% mutate(Weight = Weight/sum(Weight) * targetpop) anes_des &lt;- anes_adjwgt %&gt;% as_survey_design(weights = Weight, strata = Stratum, ids = VarUnit, nest = TRUE) 8.1 Introduction One of the most important aspects of data analysis is communicating the results to others. This could include other researchers familiar with our survey data or others who will be seeing this data and results for the first time. Ensuring that we are accurately discussing the methodology, analysis, and displaying results is crucial to making sure our audience comprehends what the results are saying. It is our responsibility to discuss and present the results carefully. Before beginning any dissemination of results, it is important to understand the audience. Some questions we might consider about our audience include: What medium will results be presented? Examples include a website or print media. Based on the media type, we might limit or enhance the use of graphical representation. How much does the audience know about the study and/or data being presented? Audiences can range from the general public to data experts. If we don’t expect our audience to know much about the study, we must describe it (see later recommendations). What are we trying to communicate? This could be summary statistics, trends, patterns, and more. Summary statistics might be best presented in tables, but trends and patterns might be better shared with plots. Is the audience accustomed to looking at plots? If not, let’s add text to describe how to read plots. What level of statistics knowledge does the audience have? If the audience does not have a strong statistics background, it could be useful to include text on standard errors, confidence intervals, and other estimate types that are being shared. 8.2 Describing Results through Text As researchers, we often focus on the data itself; communicating the results effectively can be a forgotten step. However, all of the steps that we as researchers need to consider when conducting analyses must also be communicated to our audience. The first few chapters of this book (Chapters 2 through 4) provided insights into what we need to consider when conducting analyses. Each of these topics should also be considered when presenting results to others. 8.2.1 Methodology If we use existing data, methodologically sound surveys will provide documentation about how the survey was fielded, the questionnaires, and the needed information for analyses. For example, the survey’s methodology reports should include the population of interest, sampling procedures, response rates, questionnaire documentation, weighting, and a general overview of disclosure statements. Many American organizations are part of the American Association for Public Opinion Research’s (AAPOR) Transparency Initiative, which requires the organization to include specific details in their methodology to ensure that people understand the context in which analyses can and should be conducted from each survey. Being transparent about these methods is crucial for the scientific rigor of the field. When using publicly available data, such as with the examples in this book, oftentimes, we can link to the methodology report in our final output. However, it is still important to provide high-level information that will make it easy for the audience to understand the context around the findings at a quick glance. For example, indicating who (age or other population information) is included in the study, where the study was done, and when the study was done helps the audience understand how generalizable the results are. Including the question wording will also ensure the audience understands the context and limitations if the response options are narrow. The details provided in Chapter 2 about what we as researchers need to consider when analyzing the data should also be provided to the audience when presenting the results. The inclusion of this material is especially important if no methodology report exists for the data used in the analyses. For example, if the researcher conducted the survey for the purposes of this analysis, then including as much information about the survey as possible in the write-up and dissemination of the findings is crucial. Following the AAPOR Transparency Initiative guidelines is a good way to ensure that all necessary information is provided to the audience. 8.2.2 Analysis In addition to how the survey was conducted and how weights were calculated, providing information about what data prep, cleaning, and analyses were used to obtain these results is also important. For example, in Chapter 6, we compared the distributions of education from the survey to the ACS. To do this, we needed to collapse education categories provided in the ANES data to match the ACS. Providing both the original question wording and response options and the steps taken to map to the ACS data are important for the audience to know to ensure transparency and a better understanding of the results. This particular example may seem obvious (combining a Bachelor’s Degree and a Graduate Degree into a single category). Still, there are cases where re-coding or handling missing data is more important to disclose as there could be multiple ways to handle the data, and the choice we made as researchers was just one of many. For example, many examples and exercises in this book remove missing data, as this is often the easiest way to handle missing data. However, in some cases, missing data could be a substantively important piece of information, and removing it could bias results. Disclosing how data was handled is crucial in helping the audience better understand the results. 8.2.3 Results Presenting and communicating results is more than just displaying a table with data or a nice-looking graph. Adding context around point estimates or model coefficients is important for helping the audience understand what the data mean. We, as researchers, can do a couple of things to help the audience understand the data. First, we can present the important data points in a sentence. For example, if we were looking at election polling data conducted before an election, we could say something like: As of [DATE], an estimated XX% of registered U.S. voters say they will vote for [CANDITATE NAME] for president in the [YEAR] general election. This sentence provides a few key pieces of information for the audience: [DATE]: Given that polling data is dependent on a point in time, providing the date of reference is important for understanding when this data is valid. Registered U.S. voters: This is the target population, and by including this information, we are telling the audience the population for reference and who was surveyed. [CANDITATE NAME] for president: This provides the information on the estimate. The number is the percentage of those voting for a specific candidate for a specific office. [YEAR] general election: As with the bullet above, this information provides more context around the specific election and year. The estimate would take on a different meaning if we changed it to a primary election instead of a general election, for example. This sentence also includes the word “estimated.” When presenting results in aggregate from surveys, it is important not to talk about estimates in the absolute as we have errors around each estimate. Using words like “estimated,” “on average,” or “around” will help convey the uncertainty with a given value. Including that uncertainty would be more informative to the audience. For example, a sentence could include uncertainty with a margin of error such as “XX% (+/- Y%)”. Confidence intervals can also be incorporated into the text to assist readers. Second, providing context and discussion around the meaning of the point can help the audience glean some insight into why the data is important. For example, when comparing two points, it could be helpful to indicate that there are statistically significant differences and the impact and usefulness of this information. This is where it is crucial as researchers to do our best to keep biases in check and present only the facts logically. If speculation is included, using statements like “the authors speculate” or “these findings may indicate” help relay the uncertainty around the notion while still lending a plausible solution. Additionally, researchers can present a few alternatives or competing discussion points to explain the results’ uncertainty further. It is important to remember that how we, as researchers, discuss these findings can greatly impact how the audience interprets them. Therefore, we should take extreme caution when talking about and presenting results. 8.3 Visualizing Data Data tables and graphs are used to portray a large amount of data in a concise manner. Although discussing key findings in the text is important, it is often easier for the audience to digest large amounts of data in graphical or table format. When used correctly, combining text, tables, and graphs is extremely powerful in presenting results. This section provides examples of using the {gt}, {gtsummary}, and {ggplot} packages to enhance the dissemination of results. 8.3.1 Tables Tables are a great way to provide a large amount of data when we want the individual data points to be read. However, it is important to present tables in a readable format. Numbers should be aligned, and rows and columns should be easy to follow. Using key visualization techniques, we can create tables that are informative and nice to look at. Many packages can be used to create easy-to-read tables (e.g., {kable} + {kableExtra}, {gt}, {gtsummary}, {DT}, {formattable}, {flextable}, {reactable}). We will focus on {gt} here, but we encourage learning about others as they may have additional helpful components. We like the {gt} package as it is flexible, pipeable, and has many extensions to make beautiful tables. At this time, {gtsummary} needs additional features for recommended wide use for survey analysis. It lacks the ability to work with replicate designs. We provide one example using {gtsummary} and hope it can become a better tool over time. 8.3.1.1 Transitioning {srvyr} Output to a {gt} Table Let’s start by using some of the data we calculated earlier in this book. In Chapter 6, we looked at data on trust in government with the proportions calculated below: trust_gov &lt;- anes_des %&gt;% drop_na(TrustGovernment) %&gt;% group_by(TrustGovernment) %&gt;% summarize(trust_gov_p = survey_prop()) trust_gov ## # A tibble: 5 × 3 ## TrustGovernment trust_gov_p trust_gov_p_se ## &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Always 0.0155 0.00204 ## 2 Most of the time 0.132 0.00553 ## 3 About half the time 0.309 0.00829 ## 4 Some of the time 0.434 0.00855 ## 5 Never 0.110 0.00566 The native output that R produces may work for initial viewing inside RStudio or when creating basic output with an R Markdown or Quarto document. However, when viewing these results in other publications, such as the print version of this book, or for more official dissemination, adjusting the display can make it easier for users to follow. Looking at the output from trust_gov, there are a couple of items that are probably obvious to fix: (1) use percentages instead of proportions and (2) the variable names as the column headers. The {gt} package is a good tool for implementing better labeling and creating publishable tables. Let’s walk through some code as we implement a few changes to improve the table’s usefulness. We begin with the gt() function to initiate the table and use the argument rowname_col to make the TrustGovernment column the labels for each row (called the table “stub”). The cols_label() function is used to create informative column labels instead of variable names, and the tab_spanner() function is applied to add a label across multiple columns. In this case, we apply the label “Trust in Government, 2020” across all the columns except the stub. Finally, the fmt_percent() function is used to format the proportions into percentages and reduce the number of decimals shown. Note, the tab_caption() function is used to add a table title for the book and allows for cross-referencing in R Markdown Quarto and bookdown, as well as adding it to the list of tables in the book. trust_gov_gt &lt;- trust_gov %&gt;% gt(rowname_col = &quot;TrustGovernment&quot;) %&gt;% cols_label(trust_gov_p = &quot;%&quot;, trust_gov_p_se = &quot;s.e. (%)&quot;) %&gt;% tab_spanner(label = &quot;Trust in Government, 2020&quot;, columns = c(trust_gov_p, trust_gov_p_se)) %&gt;% fmt_percent(decimals = 1) %&gt;% tab_caption(&quot;Example of gt table with trust in government estimates.&quot;) trust_gov_gt #kpkdnvzpnr table { font-family: system-ui, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Noto Color Emoji'; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; } #kpkdnvzpnr thead, #kpkdnvzpnr tbody, #kpkdnvzpnr tfoot, #kpkdnvzpnr tr, #kpkdnvzpnr td, #kpkdnvzpnr th { border-style: none; } #kpkdnvzpnr p { margin: 0; padding: 0; } #kpkdnvzpnr .gt_table { display: table; border-collapse: collapse; line-height: normal; margin-left: auto; margin-right: auto; color: #333333; font-size: 16px; font-weight: normal; font-style: normal; background-color: #FFFFFF; width: auto; border-top-style: solid; border-top-width: 2px; border-top-color: #A8A8A8; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #A8A8A8; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; } #kpkdnvzpnr .gt_caption { padding-top: 4px; padding-bottom: 4px; } #kpkdnvzpnr .gt_title { color: #333333; font-size: 125%; font-weight: initial; padding-top: 4px; padding-bottom: 4px; padding-left: 5px; padding-right: 5px; border-bottom-color: #FFFFFF; border-bottom-width: 0; } #kpkdnvzpnr .gt_subtitle { color: #333333; font-size: 85%; font-weight: initial; padding-top: 3px; padding-bottom: 5px; padding-left: 5px; padding-right: 5px; border-top-color: #FFFFFF; border-top-width: 0; } #kpkdnvzpnr .gt_heading { background-color: #FFFFFF; text-align: center; border-bottom-color: #FFFFFF; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #kpkdnvzpnr .gt_bottom_border { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #kpkdnvzpnr .gt_col_headings { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #kpkdnvzpnr .gt_col_heading { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 6px; padding-left: 5px; padding-right: 5px; overflow-x: hidden; } #kpkdnvzpnr .gt_column_spanner_outer { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; padding-top: 0; padding-bottom: 0; padding-left: 4px; padding-right: 4px; } #kpkdnvzpnr .gt_column_spanner_outer:first-child { padding-left: 0; } #kpkdnvzpnr .gt_column_spanner_outer:last-child { padding-right: 0; } #kpkdnvzpnr .gt_column_spanner { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 5px; overflow-x: hidden; display: inline-block; width: 100%; } #kpkdnvzpnr .gt_spanner_row { border-bottom-style: hidden; } #kpkdnvzpnr .gt_group_heading { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; text-align: left; } #kpkdnvzpnr .gt_empty_group_heading { padding: 0.5px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: middle; } #kpkdnvzpnr .gt_from_md > :first-child { margin-top: 0; } #kpkdnvzpnr .gt_from_md > :last-child { margin-bottom: 0; } #kpkdnvzpnr .gt_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; margin: 10px; border-top-style: solid; border-top-width: 1px; border-top-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; overflow-x: hidden; } #kpkdnvzpnr .gt_stub { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-right-style: solid; border-right-width: 2px; border-right-color: #D3D3D3; padding-left: 5px; padding-right: 5px; } #kpkdnvzpnr .gt_stub_row_group { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-right-style: solid; border-right-width: 2px; border-right-color: #D3D3D3; padding-left: 5px; padding-right: 5px; vertical-align: top; } #kpkdnvzpnr .gt_row_group_first td { border-top-width: 2px; } #kpkdnvzpnr .gt_row_group_first th { border-top-width: 2px; } #kpkdnvzpnr .gt_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #kpkdnvzpnr .gt_first_summary_row { border-top-style: solid; border-top-color: #D3D3D3; } #kpkdnvzpnr .gt_first_summary_row.thick { border-top-width: 2px; } #kpkdnvzpnr .gt_last_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #kpkdnvzpnr .gt_grand_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #kpkdnvzpnr .gt_first_grand_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-top-style: double; border-top-width: 6px; border-top-color: #D3D3D3; } #kpkdnvzpnr .gt_last_grand_summary_row_top { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-bottom-style: double; border-bottom-width: 6px; border-bottom-color: #D3D3D3; } #kpkdnvzpnr .gt_striped { background-color: rgba(128, 128, 128, 0.05); } #kpkdnvzpnr .gt_table_body { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #kpkdnvzpnr .gt_footnotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #kpkdnvzpnr .gt_footnote { margin: 0px; font-size: 90%; padding-top: 4px; padding-bottom: 4px; padding-left: 5px; padding-right: 5px; } #kpkdnvzpnr .gt_sourcenotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #kpkdnvzpnr .gt_sourcenote { font-size: 90%; padding-top: 4px; padding-bottom: 4px; padding-left: 5px; padding-right: 5px; } #kpkdnvzpnr .gt_left { text-align: left; } #kpkdnvzpnr .gt_center { text-align: center; } #kpkdnvzpnr .gt_right { text-align: right; font-variant-numeric: tabular-nums; } #kpkdnvzpnr .gt_font_normal { font-weight: normal; } #kpkdnvzpnr .gt_font_bold { font-weight: bold; } #kpkdnvzpnr .gt_font_italic { font-style: italic; } #kpkdnvzpnr .gt_super { font-size: 65%; } #kpkdnvzpnr .gt_footnote_marks { font-size: 75%; vertical-align: 0.4em; position: initial; } #kpkdnvzpnr .gt_asterisk { font-size: 100%; vertical-align: 0; } #kpkdnvzpnr .gt_indent_1 { text-indent: 5px; } #kpkdnvzpnr .gt_indent_2 { text-indent: 10px; } #kpkdnvzpnr .gt_indent_3 { text-indent: 15px; } #kpkdnvzpnr .gt_indent_4 { text-indent: 20px; } #kpkdnvzpnr .gt_indent_5 { text-indent: 25px; } TABLE 8.1: Example of gt table with trust in government estimates. Trust in Government, 2020 % s.e. (%) Always 1.6% 0.2% Most of the time 13.2% 0.6% About half the time 30.9% 0.8% Some of the time 43.4% 0.9% Never 11.0% 0.6% A few more things we can add are a title, a data source note, and a footnote with the question information using the functions tab_header(), tab_source_note(), and tab_footnote(). trust_gov_gt %&gt;% tab_header(&quot;American voter&#39;s trust in the federal government, 2020&quot;) %&gt;% tab_source_note(&quot;American National Election Studies, 2020&quot;) %&gt;% tab_footnote(&quot;Question text: How often can you trust the federal government in Washington to do what is right?&quot;) %&gt;% tab_caption(&quot;Example of gt table with trust in government estimates with additional context.&quot;) #hcqursgxsk table { font-family: system-ui, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Noto Color Emoji'; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; } #hcqursgxsk thead, #hcqursgxsk tbody, #hcqursgxsk tfoot, #hcqursgxsk tr, #hcqursgxsk td, #hcqursgxsk th { border-style: none; } #hcqursgxsk p { margin: 0; padding: 0; } #hcqursgxsk .gt_table { display: table; border-collapse: collapse; line-height: normal; margin-left: auto; margin-right: auto; color: #333333; font-size: 16px; font-weight: normal; font-style: normal; background-color: #FFFFFF; width: auto; border-top-style: solid; border-top-width: 2px; border-top-color: #A8A8A8; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #A8A8A8; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; } #hcqursgxsk .gt_caption { padding-top: 4px; padding-bottom: 4px; } #hcqursgxsk .gt_title { color: #333333; font-size: 125%; font-weight: initial; padding-top: 4px; padding-bottom: 4px; padding-left: 5px; padding-right: 5px; border-bottom-color: #FFFFFF; border-bottom-width: 0; } #hcqursgxsk .gt_subtitle { color: #333333; font-size: 85%; font-weight: initial; padding-top: 3px; padding-bottom: 5px; padding-left: 5px; padding-right: 5px; border-top-color: #FFFFFF; border-top-width: 0; } #hcqursgxsk .gt_heading { background-color: #FFFFFF; text-align: center; border-bottom-color: #FFFFFF; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #hcqursgxsk .gt_bottom_border { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #hcqursgxsk .gt_col_headings { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #hcqursgxsk .gt_col_heading { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 6px; padding-left: 5px; padding-right: 5px; overflow-x: hidden; } #hcqursgxsk .gt_column_spanner_outer { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; padding-top: 0; padding-bottom: 0; padding-left: 4px; padding-right: 4px; } #hcqursgxsk .gt_column_spanner_outer:first-child { padding-left: 0; } #hcqursgxsk .gt_column_spanner_outer:last-child { padding-right: 0; } #hcqursgxsk .gt_column_spanner { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 5px; overflow-x: hidden; display: inline-block; width: 100%; } #hcqursgxsk .gt_spanner_row { border-bottom-style: hidden; } #hcqursgxsk .gt_group_heading { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; text-align: left; } #hcqursgxsk .gt_empty_group_heading { padding: 0.5px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: middle; } #hcqursgxsk .gt_from_md > :first-child { margin-top: 0; } #hcqursgxsk .gt_from_md > :last-child { margin-bottom: 0; } #hcqursgxsk .gt_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; margin: 10px; border-top-style: solid; border-top-width: 1px; border-top-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; overflow-x: hidden; } #hcqursgxsk .gt_stub { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-right-style: solid; border-right-width: 2px; border-right-color: #D3D3D3; padding-left: 5px; padding-right: 5px; } #hcqursgxsk .gt_stub_row_group { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-right-style: solid; border-right-width: 2px; border-right-color: #D3D3D3; padding-left: 5px; padding-right: 5px; vertical-align: top; } #hcqursgxsk .gt_row_group_first td { border-top-width: 2px; } #hcqursgxsk .gt_row_group_first th { border-top-width: 2px; } #hcqursgxsk .gt_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #hcqursgxsk .gt_first_summary_row { border-top-style: solid; border-top-color: #D3D3D3; } #hcqursgxsk .gt_first_summary_row.thick { border-top-width: 2px; } #hcqursgxsk .gt_last_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #hcqursgxsk .gt_grand_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #hcqursgxsk .gt_first_grand_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-top-style: double; border-top-width: 6px; border-top-color: #D3D3D3; } #hcqursgxsk .gt_last_grand_summary_row_top { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-bottom-style: double; border-bottom-width: 6px; border-bottom-color: #D3D3D3; } #hcqursgxsk .gt_striped { background-color: rgba(128, 128, 128, 0.05); } #hcqursgxsk .gt_table_body { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #hcqursgxsk .gt_footnotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #hcqursgxsk .gt_footnote { margin: 0px; font-size: 90%; padding-top: 4px; padding-bottom: 4px; padding-left: 5px; padding-right: 5px; } #hcqursgxsk .gt_sourcenotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #hcqursgxsk .gt_sourcenote { font-size: 90%; padding-top: 4px; padding-bottom: 4px; padding-left: 5px; padding-right: 5px; } #hcqursgxsk .gt_left { text-align: left; } #hcqursgxsk .gt_center { text-align: center; } #hcqursgxsk .gt_right { text-align: right; font-variant-numeric: tabular-nums; } #hcqursgxsk .gt_font_normal { font-weight: normal; } #hcqursgxsk .gt_font_bold { font-weight: bold; } #hcqursgxsk .gt_font_italic { font-style: italic; } #hcqursgxsk .gt_super { font-size: 65%; } #hcqursgxsk .gt_footnote_marks { font-size: 75%; vertical-align: 0.4em; position: initial; } #hcqursgxsk .gt_asterisk { font-size: 100%; vertical-align: 0; } #hcqursgxsk .gt_indent_1 { text-indent: 5px; } #hcqursgxsk .gt_indent_2 { text-indent: 10px; } #hcqursgxsk .gt_indent_3 { text-indent: 15px; } #hcqursgxsk .gt_indent_4 { text-indent: 20px; } #hcqursgxsk .gt_indent_5 { text-indent: 25px; } TABLE 8.2: Example of gt table with trust in government estimates with additional context. American voter's trust in the federal government, 2020 Trust in Government, 2020 % s.e. (%) Always 1.6% 0.2% Most of the time 13.2% 0.6% About half the time 30.9% 0.8% Some of the time 43.4% 0.9% Never 11.0% 0.6% American National Election Studies, 2020 Question text: How often can you trust the federal government in Washington to do what is right? 8.3.1.2 Expanding Tables using {gtsummary} The {gtsummary} package simultaneously summarizes data and creates publication-ready tables. Its origins are in clinical trial data but it has been extended to include survey analysis in some limited ways. At this time, it only works with survey objects using Taylor’s Series Linearization and not replicate methods. A limited set of summary statistics are available. For categorical variables, the following summary statistics are available: {n} frequency {N} denominator, or cohort size {p} percentage {p.std.error} standard error of the sample proportion {deff} design effect of the sample proportion {n_unweighted} unweighted frequency {N_unweighted} unweighted denominator {p_unweighted} unweighted formatted percentage For continuous variables, the following summary statistics are available: {median} median {mean} mean {mean.std.error} standard error of the sample mean {deff} design effect of the sample mean {sd} standard deviation {var} variance {min} minimum {max} maximum {p##} any integer percentile, where ## is an integer from 0 to 100 {sum} sum In the following example, we will build up a table using {gtsummary}, which will be similar to the table in the {gt} example. The main function used is tbl_svysummary(). In this function, the variables we want to analyze are included in the include argument, and the statistics we want to display are in the statistic argument. To specify statistics, the syntax from the {glue} package is used where variables you want to insert are included inside curly brackets. To specify that we want, the proportion followed by the standard error of the proportion in parentheses, we use “{p} ({p.std.error})”. We must specify the statistics we want using the names of the statistics in the two lists above. To print this table in all format types, we use the as_gt() function to maintain the {gtsummary} formatting. anes_des %&gt;% tbl_svysummary(include = TrustGovernment, statistic = list(all_categorical() ~ &quot;{p} ({p.std.error})&quot;)) %&gt;% as_gt() %&gt;% tab_caption(&quot;Example of gtsummary table with trust in government estimates.&quot;) #kogibkckwm table { font-family: system-ui, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Noto Color Emoji'; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; } #kogibkckwm thead, #kogibkckwm tbody, #kogibkckwm tfoot, #kogibkckwm tr, #kogibkckwm td, #kogibkckwm th { border-style: none; } #kogibkckwm p { margin: 0; padding: 0; } #kogibkckwm .gt_table { display: table; border-collapse: collapse; line-height: normal; margin-left: auto; margin-right: auto; color: #333333; font-size: 16px; font-weight: normal; font-style: normal; background-color: #FFFFFF; width: auto; border-top-style: solid; border-top-width: 2px; border-top-color: #A8A8A8; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #A8A8A8; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; } #kogibkckwm .gt_caption { padding-top: 4px; padding-bottom: 4px; } #kogibkckwm .gt_title { color: #333333; font-size: 125%; font-weight: initial; padding-top: 4px; padding-bottom: 4px; padding-left: 5px; padding-right: 5px; border-bottom-color: #FFFFFF; border-bottom-width: 0; } #kogibkckwm .gt_subtitle { color: #333333; font-size: 85%; font-weight: initial; padding-top: 3px; padding-bottom: 5px; padding-left: 5px; padding-right: 5px; border-top-color: #FFFFFF; border-top-width: 0; } #kogibkckwm .gt_heading { background-color: #FFFFFF; text-align: center; border-bottom-color: #FFFFFF; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #kogibkckwm .gt_bottom_border { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #kogibkckwm .gt_col_headings { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #kogibkckwm .gt_col_heading { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 6px; padding-left: 5px; padding-right: 5px; overflow-x: hidden; } #kogibkckwm .gt_column_spanner_outer { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; padding-top: 0; padding-bottom: 0; padding-left: 4px; padding-right: 4px; } #kogibkckwm .gt_column_spanner_outer:first-child { padding-left: 0; } #kogibkckwm .gt_column_spanner_outer:last-child { padding-right: 0; } #kogibkckwm .gt_column_spanner { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 5px; overflow-x: hidden; display: inline-block; width: 100%; } #kogibkckwm .gt_spanner_row { border-bottom-style: hidden; } #kogibkckwm .gt_group_heading { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; text-align: left; } #kogibkckwm .gt_empty_group_heading { padding: 0.5px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: middle; } #kogibkckwm .gt_from_md > :first-child { margin-top: 0; } #kogibkckwm .gt_from_md > :last-child { margin-bottom: 0; } #kogibkckwm .gt_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; margin: 10px; border-top-style: solid; border-top-width: 1px; border-top-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; overflow-x: hidden; } #kogibkckwm .gt_stub { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-right-style: solid; border-right-width: 2px; border-right-color: #D3D3D3; padding-left: 5px; padding-right: 5px; } #kogibkckwm .gt_stub_row_group { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-right-style: solid; border-right-width: 2px; border-right-color: #D3D3D3; padding-left: 5px; padding-right: 5px; vertical-align: top; } #kogibkckwm .gt_row_group_first td { border-top-width: 2px; } #kogibkckwm .gt_row_group_first th { border-top-width: 2px; } #kogibkckwm .gt_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #kogibkckwm .gt_first_summary_row { border-top-style: solid; border-top-color: #D3D3D3; } #kogibkckwm .gt_first_summary_row.thick { border-top-width: 2px; } #kogibkckwm .gt_last_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #kogibkckwm .gt_grand_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #kogibkckwm .gt_first_grand_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-top-style: double; border-top-width: 6px; border-top-color: #D3D3D3; } #kogibkckwm .gt_last_grand_summary_row_top { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-bottom-style: double; border-bottom-width: 6px; border-bottom-color: #D3D3D3; } #kogibkckwm .gt_striped { background-color: rgba(128, 128, 128, 0.05); } #kogibkckwm .gt_table_body { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #kogibkckwm .gt_footnotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #kogibkckwm .gt_footnote { margin: 0px; font-size: 90%; padding-top: 4px; padding-bottom: 4px; padding-left: 5px; padding-right: 5px; } #kogibkckwm .gt_sourcenotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #kogibkckwm .gt_sourcenote { font-size: 90%; padding-top: 4px; padding-bottom: 4px; padding-left: 5px; padding-right: 5px; } #kogibkckwm .gt_left { text-align: left; } #kogibkckwm .gt_center { text-align: center; } #kogibkckwm .gt_right { text-align: right; font-variant-numeric: tabular-nums; } #kogibkckwm .gt_font_normal { font-weight: normal; } #kogibkckwm .gt_font_bold { font-weight: bold; } #kogibkckwm .gt_font_italic { font-style: italic; } #kogibkckwm .gt_super { font-size: 65%; } #kogibkckwm .gt_footnote_marks { font-size: 75%; vertical-align: 0.4em; position: initial; } #kogibkckwm .gt_asterisk { font-size: 100%; vertical-align: 0; } #kogibkckwm .gt_indent_1 { text-indent: 5px; } #kogibkckwm .gt_indent_2 { text-indent: 10px; } #kogibkckwm .gt_indent_3 { text-indent: 15px; } #kogibkckwm .gt_indent_4 { text-indent: 20px; } #kogibkckwm .gt_indent_5 { text-indent: 25px; } TABLE 8.3: Example of gtsummary table with trust in government estimates. Characteristic N = 231,034,1251 TrustGovernment     Always 1.6 (0.00)     Most of the time 13 (0.01)     About half the time 31 (0.01)     Some of the time 43 (0.01)     Never 11 (0.01)     Unknown 673,773 1 % (SE(%)) In this default table, the weighted number of missing (or Unknown) records is included. Additionally, the standard error is reported as a proportion while the proportion is styled as a percentage. In the next step, we remove the Unknown category by setting the missing argument to “no” and format the standard error as a percentage within the digits argument. Finally, we label the “TrustGovernment” variable to something more publication-ready using the label argument. anes_des %&gt;% tbl_svysummary(include = TrustGovernment, statistic = list(all_categorical() ~ &quot;{p} ({p.std.error})&quot;), missing = &quot;no&quot;, digits = list(TrustGovernment ~ style_percent), label = list(TrustGovernment ~ &quot;Trust in Government, 2020&quot;)) %&gt;% as_gt() %&gt;% tab_caption(&quot;Example of gtsummary table with trust in government estimates with labeling and digits options.&quot;) #jhrwokkyhy table { font-family: system-ui, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Noto Color Emoji'; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; } #jhrwokkyhy thead, #jhrwokkyhy tbody, #jhrwokkyhy tfoot, #jhrwokkyhy tr, #jhrwokkyhy td, #jhrwokkyhy th { border-style: none; } #jhrwokkyhy p { margin: 0; padding: 0; } #jhrwokkyhy .gt_table { display: table; border-collapse: collapse; line-height: normal; margin-left: auto; margin-right: auto; color: #333333; font-size: 16px; font-weight: normal; font-style: normal; background-color: #FFFFFF; width: auto; border-top-style: solid; border-top-width: 2px; border-top-color: #A8A8A8; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #A8A8A8; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; } #jhrwokkyhy .gt_caption { padding-top: 4px; padding-bottom: 4px; } #jhrwokkyhy .gt_title { color: #333333; font-size: 125%; font-weight: initial; padding-top: 4px; padding-bottom: 4px; padding-left: 5px; padding-right: 5px; border-bottom-color: #FFFFFF; border-bottom-width: 0; } #jhrwokkyhy .gt_subtitle { color: #333333; font-size: 85%; font-weight: initial; padding-top: 3px; padding-bottom: 5px; padding-left: 5px; padding-right: 5px; border-top-color: #FFFFFF; border-top-width: 0; } #jhrwokkyhy .gt_heading { background-color: #FFFFFF; text-align: center; border-bottom-color: #FFFFFF; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #jhrwokkyhy .gt_bottom_border { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #jhrwokkyhy .gt_col_headings { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #jhrwokkyhy .gt_col_heading { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 6px; padding-left: 5px; padding-right: 5px; overflow-x: hidden; } #jhrwokkyhy .gt_column_spanner_outer { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; padding-top: 0; padding-bottom: 0; padding-left: 4px; padding-right: 4px; } #jhrwokkyhy .gt_column_spanner_outer:first-child { padding-left: 0; } #jhrwokkyhy .gt_column_spanner_outer:last-child { padding-right: 0; } #jhrwokkyhy .gt_column_spanner { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 5px; overflow-x: hidden; display: inline-block; width: 100%; } #jhrwokkyhy .gt_spanner_row { border-bottom-style: hidden; } #jhrwokkyhy .gt_group_heading { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; text-align: left; } #jhrwokkyhy .gt_empty_group_heading { padding: 0.5px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: middle; } #jhrwokkyhy .gt_from_md > :first-child { margin-top: 0; } #jhrwokkyhy .gt_from_md > :last-child { margin-bottom: 0; } #jhrwokkyhy .gt_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; margin: 10px; border-top-style: solid; border-top-width: 1px; border-top-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; overflow-x: hidden; } #jhrwokkyhy .gt_stub { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-right-style: solid; border-right-width: 2px; border-right-color: #D3D3D3; padding-left: 5px; padding-right: 5px; } #jhrwokkyhy .gt_stub_row_group { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-right-style: solid; border-right-width: 2px; border-right-color: #D3D3D3; padding-left: 5px; padding-right: 5px; vertical-align: top; } #jhrwokkyhy .gt_row_group_first td { border-top-width: 2px; } #jhrwokkyhy .gt_row_group_first th { border-top-width: 2px; } #jhrwokkyhy .gt_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #jhrwokkyhy .gt_first_summary_row { border-top-style: solid; border-top-color: #D3D3D3; } #jhrwokkyhy .gt_first_summary_row.thick { border-top-width: 2px; } #jhrwokkyhy .gt_last_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #jhrwokkyhy .gt_grand_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #jhrwokkyhy .gt_first_grand_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-top-style: double; border-top-width: 6px; border-top-color: #D3D3D3; } #jhrwokkyhy .gt_last_grand_summary_row_top { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-bottom-style: double; border-bottom-width: 6px; border-bottom-color: #D3D3D3; } #jhrwokkyhy .gt_striped { background-color: rgba(128, 128, 128, 0.05); } #jhrwokkyhy .gt_table_body { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #jhrwokkyhy .gt_footnotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #jhrwokkyhy .gt_footnote { margin: 0px; font-size: 90%; padding-top: 4px; padding-bottom: 4px; padding-left: 5px; padding-right: 5px; } #jhrwokkyhy .gt_sourcenotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #jhrwokkyhy .gt_sourcenote { font-size: 90%; padding-top: 4px; padding-bottom: 4px; padding-left: 5px; padding-right: 5px; } #jhrwokkyhy .gt_left { text-align: left; } #jhrwokkyhy .gt_center { text-align: center; } #jhrwokkyhy .gt_right { text-align: right; font-variant-numeric: tabular-nums; } #jhrwokkyhy .gt_font_normal { font-weight: normal; } #jhrwokkyhy .gt_font_bold { font-weight: bold; } #jhrwokkyhy .gt_font_italic { font-style: italic; } #jhrwokkyhy .gt_super { font-size: 65%; } #jhrwokkyhy .gt_footnote_marks { font-size: 75%; vertical-align: 0.4em; position: initial; } #jhrwokkyhy .gt_asterisk { font-size: 100%; vertical-align: 0; } #jhrwokkyhy .gt_indent_1 { text-indent: 5px; } #jhrwokkyhy .gt_indent_2 { text-indent: 10px; } #jhrwokkyhy .gt_indent_3 { text-indent: 15px; } #jhrwokkyhy .gt_indent_4 { text-indent: 20px; } #jhrwokkyhy .gt_indent_5 { text-indent: 25px; } TABLE 8.4: Example of gtsummary table with trust in government estimates with labeling and digits options. Characteristic N = 231,034,1251 Trust in Government, 2020     Always 1.6 (0.2)     Most of the time 13 (0.6)     About half the time 31 (0.8)     Some of the time 43 (0.9)     Never 11 (0.6) 1 % (SE(%)) To remove the phrase “Characteristic” and the estimated population size, we can modify the header using the function modify_header() to update the label and stat_0. To add footnotes and a title, we do this after converting the object to a gt table using as_gt() and can use the same functions we did in Section 8.3.1.1 anes_des %&gt;% tbl_svysummary(include = TrustGovernment, statistic = list(all_categorical() ~ &quot;{p} ({p.std.error})&quot;), missing = &quot;no&quot;, digits = list(TrustGovernment ~ style_percent), label = list(TrustGovernment ~ &quot;Trust in Government, 2020&quot;)) %&gt;% modify_footnote(update = everything() ~ NA) %&gt;% modify_header(label = &quot; &quot;, stat_0 = &quot;% (s.e.)&quot;) %&gt;% as_gt() %&gt;% tab_header(&quot;American voter&#39;s trust in the federal government, 2020&quot;) %&gt;% tab_source_note(&quot;American National Election Studies, 2020&quot;) %&gt;% tab_footnote(&quot;Question text: How often can you trust the federal government in Washington to do what is right?&quot;) %&gt;% tab_caption(&quot;Example of gtsummary table with trust in government estimates with more labeling options and context.&quot;) #uqkclffrjq table { font-family: system-ui, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Noto Color Emoji'; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; } #uqkclffrjq thead, #uqkclffrjq tbody, #uqkclffrjq tfoot, #uqkclffrjq tr, #uqkclffrjq td, #uqkclffrjq th { border-style: none; } #uqkclffrjq p { margin: 0; padding: 0; } #uqkclffrjq .gt_table { display: table; border-collapse: collapse; line-height: normal; margin-left: auto; margin-right: auto; color: #333333; font-size: 16px; font-weight: normal; font-style: normal; background-color: #FFFFFF; width: auto; border-top-style: solid; border-top-width: 2px; border-top-color: #A8A8A8; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #A8A8A8; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; } #uqkclffrjq .gt_caption { padding-top: 4px; padding-bottom: 4px; } #uqkclffrjq .gt_title { color: #333333; font-size: 125%; font-weight: initial; padding-top: 4px; padding-bottom: 4px; padding-left: 5px; padding-right: 5px; border-bottom-color: #FFFFFF; border-bottom-width: 0; } #uqkclffrjq .gt_subtitle { color: #333333; font-size: 85%; font-weight: initial; padding-top: 3px; padding-bottom: 5px; padding-left: 5px; padding-right: 5px; border-top-color: #FFFFFF; border-top-width: 0; } #uqkclffrjq .gt_heading { background-color: #FFFFFF; text-align: center; border-bottom-color: #FFFFFF; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #uqkclffrjq .gt_bottom_border { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #uqkclffrjq .gt_col_headings { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #uqkclffrjq .gt_col_heading { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 6px; padding-left: 5px; padding-right: 5px; overflow-x: hidden; } #uqkclffrjq .gt_column_spanner_outer { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; padding-top: 0; padding-bottom: 0; padding-left: 4px; padding-right: 4px; } #uqkclffrjq .gt_column_spanner_outer:first-child { padding-left: 0; } #uqkclffrjq .gt_column_spanner_outer:last-child { padding-right: 0; } #uqkclffrjq .gt_column_spanner { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 5px; overflow-x: hidden; display: inline-block; width: 100%; } #uqkclffrjq .gt_spanner_row { border-bottom-style: hidden; } #uqkclffrjq .gt_group_heading { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; text-align: left; } #uqkclffrjq .gt_empty_group_heading { padding: 0.5px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: middle; } #uqkclffrjq .gt_from_md > :first-child { margin-top: 0; } #uqkclffrjq .gt_from_md > :last-child { margin-bottom: 0; } #uqkclffrjq .gt_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; margin: 10px; border-top-style: solid; border-top-width: 1px; border-top-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; overflow-x: hidden; } #uqkclffrjq .gt_stub { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-right-style: solid; border-right-width: 2px; border-right-color: #D3D3D3; padding-left: 5px; padding-right: 5px; } #uqkclffrjq .gt_stub_row_group { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-right-style: solid; border-right-width: 2px; border-right-color: #D3D3D3; padding-left: 5px; padding-right: 5px; vertical-align: top; } #uqkclffrjq .gt_row_group_first td { border-top-width: 2px; } #uqkclffrjq .gt_row_group_first th { border-top-width: 2px; } #uqkclffrjq .gt_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #uqkclffrjq .gt_first_summary_row { border-top-style: solid; border-top-color: #D3D3D3; } #uqkclffrjq .gt_first_summary_row.thick { border-top-width: 2px; } #uqkclffrjq .gt_last_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #uqkclffrjq .gt_grand_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #uqkclffrjq .gt_first_grand_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-top-style: double; border-top-width: 6px; border-top-color: #D3D3D3; } #uqkclffrjq .gt_last_grand_summary_row_top { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-bottom-style: double; border-bottom-width: 6px; border-bottom-color: #D3D3D3; } #uqkclffrjq .gt_striped { background-color: rgba(128, 128, 128, 0.05); } #uqkclffrjq .gt_table_body { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #uqkclffrjq .gt_footnotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #uqkclffrjq .gt_footnote { margin: 0px; font-size: 90%; padding-top: 4px; padding-bottom: 4px; padding-left: 5px; padding-right: 5px; } #uqkclffrjq .gt_sourcenotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #uqkclffrjq .gt_sourcenote { font-size: 90%; padding-top: 4px; padding-bottom: 4px; padding-left: 5px; padding-right: 5px; } #uqkclffrjq .gt_left { text-align: left; } #uqkclffrjq .gt_center { text-align: center; } #uqkclffrjq .gt_right { text-align: right; font-variant-numeric: tabular-nums; } #uqkclffrjq .gt_font_normal { font-weight: normal; } #uqkclffrjq .gt_font_bold { font-weight: bold; } #uqkclffrjq .gt_font_italic { font-style: italic; } #uqkclffrjq .gt_super { font-size: 65%; } #uqkclffrjq .gt_footnote_marks { font-size: 75%; vertical-align: 0.4em; position: initial; } #uqkclffrjq .gt_asterisk { font-size: 100%; vertical-align: 0; } #uqkclffrjq .gt_indent_1 { text-indent: 5px; } #uqkclffrjq .gt_indent_2 { text-indent: 10px; } #uqkclffrjq .gt_indent_3 { text-indent: 15px; } #uqkclffrjq .gt_indent_4 { text-indent: 20px; } #uqkclffrjq .gt_indent_5 { text-indent: 25px; } TABLE 8.5: Example of gtsummary table with trust in government estimates with more labeling options and context. American voter's trust in the federal government, 2020 % (s.e.) Trust in Government, 2020     Always 1.6 (0.2)     Most of the time 13 (0.6)     About half the time 31 (0.8)     Some of the time 43 (0.9)     Never 11 (0.6) American National Election Studies, 2020 Question text: How often can you trust the federal government in Washington to do what is right? Continuous variables can also be added, and we add a summary of the age variable to the table below by updating the include, statistic, and digits argument. Adding on additional variables is a large benefit to the {gtsummary} package. anes_des %&gt;% tbl_svysummary( include = c(TrustGovernment, Age), statistic = list( all_categorical() ~ &quot;{p} ({p.std.error})&quot;, all_continuous() ~ &quot;{mean} ({mean.std.error})&quot; ), missing = &quot;no&quot;, digits = list(TrustGovernment ~ style_percent, Age ~ c(1, 2)), label = list(TrustGovernment ~ &quot;Trust in Government, 2020&quot;) ) %&gt;% modify_header(label = &quot; &quot;, stat_0 = &quot;Summary&quot;) %&gt;% as_gt() %&gt;% tab_header(&quot;American voter&#39;s trust in the federal government, 2020&quot;) %&gt;% tab_source_note(&quot;American National Election Studies, 2020&quot;) %&gt;% tab_footnote( &quot;Question text: How often can you trust the federal government in Washington to do what is right?&quot; ) %&gt;% tab_caption(&quot;Example of gtsummary table with trust in government estimates and average age.&quot;) #xqossclppl table { font-family: system-ui, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Noto Color Emoji'; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; } #xqossclppl thead, #xqossclppl tbody, #xqossclppl tfoot, #xqossclppl tr, #xqossclppl td, #xqossclppl th { border-style: none; } #xqossclppl p { margin: 0; padding: 0; } #xqossclppl .gt_table { display: table; border-collapse: collapse; line-height: normal; margin-left: auto; margin-right: auto; color: #333333; font-size: 16px; font-weight: normal; font-style: normal; background-color: #FFFFFF; width: auto; border-top-style: solid; border-top-width: 2px; border-top-color: #A8A8A8; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #A8A8A8; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; } #xqossclppl .gt_caption { padding-top: 4px; padding-bottom: 4px; } #xqossclppl .gt_title { color: #333333; font-size: 125%; font-weight: initial; padding-top: 4px; padding-bottom: 4px; padding-left: 5px; padding-right: 5px; border-bottom-color: #FFFFFF; border-bottom-width: 0; } #xqossclppl .gt_subtitle { color: #333333; font-size: 85%; font-weight: initial; padding-top: 3px; padding-bottom: 5px; padding-left: 5px; padding-right: 5px; border-top-color: #FFFFFF; border-top-width: 0; } #xqossclppl .gt_heading { background-color: #FFFFFF; text-align: center; border-bottom-color: #FFFFFF; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #xqossclppl .gt_bottom_border { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #xqossclppl .gt_col_headings { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #xqossclppl .gt_col_heading { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 6px; padding-left: 5px; padding-right: 5px; overflow-x: hidden; } #xqossclppl .gt_column_spanner_outer { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; padding-top: 0; padding-bottom: 0; padding-left: 4px; padding-right: 4px; } #xqossclppl .gt_column_spanner_outer:first-child { padding-left: 0; } #xqossclppl .gt_column_spanner_outer:last-child { padding-right: 0; } #xqossclppl .gt_column_spanner { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 5px; overflow-x: hidden; display: inline-block; width: 100%; } #xqossclppl .gt_spanner_row { border-bottom-style: hidden; } #xqossclppl .gt_group_heading { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; text-align: left; } #xqossclppl .gt_empty_group_heading { padding: 0.5px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: middle; } #xqossclppl .gt_from_md > :first-child { margin-top: 0; } #xqossclppl .gt_from_md > :last-child { margin-bottom: 0; } #xqossclppl .gt_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; margin: 10px; border-top-style: solid; border-top-width: 1px; border-top-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; overflow-x: hidden; } #xqossclppl .gt_stub { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-right-style: solid; border-right-width: 2px; border-right-color: #D3D3D3; padding-left: 5px; padding-right: 5px; } #xqossclppl .gt_stub_row_group { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-right-style: solid; border-right-width: 2px; border-right-color: #D3D3D3; padding-left: 5px; padding-right: 5px; vertical-align: top; } #xqossclppl .gt_row_group_first td { border-top-width: 2px; } #xqossclppl .gt_row_group_first th { border-top-width: 2px; } #xqossclppl .gt_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #xqossclppl .gt_first_summary_row { border-top-style: solid; border-top-color: #D3D3D3; } #xqossclppl .gt_first_summary_row.thick { border-top-width: 2px; } #xqossclppl .gt_last_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #xqossclppl .gt_grand_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #xqossclppl .gt_first_grand_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-top-style: double; border-top-width: 6px; border-top-color: #D3D3D3; } #xqossclppl .gt_last_grand_summary_row_top { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-bottom-style: double; border-bottom-width: 6px; border-bottom-color: #D3D3D3; } #xqossclppl .gt_striped { background-color: rgba(128, 128, 128, 0.05); } #xqossclppl .gt_table_body { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #xqossclppl .gt_footnotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #xqossclppl .gt_footnote { margin: 0px; font-size: 90%; padding-top: 4px; padding-bottom: 4px; padding-left: 5px; padding-right: 5px; } #xqossclppl .gt_sourcenotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #xqossclppl .gt_sourcenote { font-size: 90%; padding-top: 4px; padding-bottom: 4px; padding-left: 5px; padding-right: 5px; } #xqossclppl .gt_left { text-align: left; } #xqossclppl .gt_center { text-align: center; } #xqossclppl .gt_right { text-align: right; font-variant-numeric: tabular-nums; } #xqossclppl .gt_font_normal { font-weight: normal; } #xqossclppl .gt_font_bold { font-weight: bold; } #xqossclppl .gt_font_italic { font-style: italic; } #xqossclppl .gt_super { font-size: 65%; } #xqossclppl .gt_footnote_marks { font-size: 75%; vertical-align: 0.4em; position: initial; } #xqossclppl .gt_asterisk { font-size: 100%; vertical-align: 0; } #xqossclppl .gt_indent_1 { text-indent: 5px; } #xqossclppl .gt_indent_2 { text-indent: 10px; } #xqossclppl .gt_indent_3 { text-indent: 15px; } #xqossclppl .gt_indent_4 { text-indent: 20px; } #xqossclppl .gt_indent_5 { text-indent: 25px; } TABLE 8.6: Example of gtsummary table with trust in government estimates and average age. American voter's trust in the federal government, 2020 Summary1 Trust in Government, 2020     Always 1.6 (0.2)     Most of the time 13 (0.6)     About half the time 31 (0.8)     Some of the time 43 (0.9)     Never 11 (0.6) Age 47.3 (0.36) American National Election Studies, 2020 Question text: How often can you trust the federal government in Washington to do what is right? 1 % (SE(%)); Mean (SE) The { gtsummary } also allows calculating statistics by different groups easily. Let’s adapt the prior example to perform analysis by whether the person voted for president in 2020. The argument for by is updated and the header names are updated. Finally, we update the header. anes_des %&gt;% drop_na(VotedPres2020) %&gt;% tbl_svysummary(include = TrustGovernment, statistic = list(all_categorical() ~ &quot;{p} ({p.std.error})&quot;), missing = &quot;no&quot;, digits = list(TrustGovernment ~ style_percent), label = list(TrustGovernment ~ &quot;Trust in Government, 2020&quot;), by = VotedPres2020) %&gt;% modify_header(label = &quot; &quot;, stat_1 = &quot;Voted&quot;, stat_2 = &quot;Didn&#39;t vote&quot;) %&gt;% as_gt() %&gt;% tab_header(&quot;American voter&#39;s trust in the federal government by whether they voted in the 2020 presidential election&quot;) %&gt;% tab_source_note(&quot;American National Election Studies, 2020&quot;) %&gt;% tab_footnote(&quot;Question text: How often can you trust the federal government in Washington to do what is right?&quot;) %&gt;% tab_caption(&quot;Example of gtsummary table with trust in government estimates by voting status.&quot;) #vnyhqfyukq table { font-family: system-ui, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Noto Color Emoji'; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; } #vnyhqfyukq thead, #vnyhqfyukq tbody, #vnyhqfyukq tfoot, #vnyhqfyukq tr, #vnyhqfyukq td, #vnyhqfyukq th { border-style: none; } #vnyhqfyukq p { margin: 0; padding: 0; } #vnyhqfyukq .gt_table { display: table; border-collapse: collapse; line-height: normal; margin-left: auto; margin-right: auto; color: #333333; font-size: 16px; font-weight: normal; font-style: normal; background-color: #FFFFFF; width: auto; border-top-style: solid; border-top-width: 2px; border-top-color: #A8A8A8; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #A8A8A8; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; } #vnyhqfyukq .gt_caption { padding-top: 4px; padding-bottom: 4px; } #vnyhqfyukq .gt_title { color: #333333; font-size: 125%; font-weight: initial; padding-top: 4px; padding-bottom: 4px; padding-left: 5px; padding-right: 5px; border-bottom-color: #FFFFFF; border-bottom-width: 0; } #vnyhqfyukq .gt_subtitle { color: #333333; font-size: 85%; font-weight: initial; padding-top: 3px; padding-bottom: 5px; padding-left: 5px; padding-right: 5px; border-top-color: #FFFFFF; border-top-width: 0; } #vnyhqfyukq .gt_heading { background-color: #FFFFFF; text-align: center; border-bottom-color: #FFFFFF; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #vnyhqfyukq .gt_bottom_border { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #vnyhqfyukq .gt_col_headings { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #vnyhqfyukq .gt_col_heading { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 6px; padding-left: 5px; padding-right: 5px; overflow-x: hidden; } #vnyhqfyukq .gt_column_spanner_outer { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; padding-top: 0; padding-bottom: 0; padding-left: 4px; padding-right: 4px; } #vnyhqfyukq .gt_column_spanner_outer:first-child { padding-left: 0; } #vnyhqfyukq .gt_column_spanner_outer:last-child { padding-right: 0; } #vnyhqfyukq .gt_column_spanner { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 5px; overflow-x: hidden; display: inline-block; width: 100%; } #vnyhqfyukq .gt_spanner_row { border-bottom-style: hidden; } #vnyhqfyukq .gt_group_heading { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; text-align: left; } #vnyhqfyukq .gt_empty_group_heading { padding: 0.5px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: middle; } #vnyhqfyukq .gt_from_md > :first-child { margin-top: 0; } #vnyhqfyukq .gt_from_md > :last-child { margin-bottom: 0; } #vnyhqfyukq .gt_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; margin: 10px; border-top-style: solid; border-top-width: 1px; border-top-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; overflow-x: hidden; } #vnyhqfyukq .gt_stub { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-right-style: solid; border-right-width: 2px; border-right-color: #D3D3D3; padding-left: 5px; padding-right: 5px; } #vnyhqfyukq .gt_stub_row_group { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-right-style: solid; border-right-width: 2px; border-right-color: #D3D3D3; padding-left: 5px; padding-right: 5px; vertical-align: top; } #vnyhqfyukq .gt_row_group_first td { border-top-width: 2px; } #vnyhqfyukq .gt_row_group_first th { border-top-width: 2px; } #vnyhqfyukq .gt_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #vnyhqfyukq .gt_first_summary_row { border-top-style: solid; border-top-color: #D3D3D3; } #vnyhqfyukq .gt_first_summary_row.thick { border-top-width: 2px; } #vnyhqfyukq .gt_last_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #vnyhqfyukq .gt_grand_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #vnyhqfyukq .gt_first_grand_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-top-style: double; border-top-width: 6px; border-top-color: #D3D3D3; } #vnyhqfyukq .gt_last_grand_summary_row_top { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-bottom-style: double; border-bottom-width: 6px; border-bottom-color: #D3D3D3; } #vnyhqfyukq .gt_striped { background-color: rgba(128, 128, 128, 0.05); } #vnyhqfyukq .gt_table_body { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #vnyhqfyukq .gt_footnotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #vnyhqfyukq .gt_footnote { margin: 0px; font-size: 90%; padding-top: 4px; padding-bottom: 4px; padding-left: 5px; padding-right: 5px; } #vnyhqfyukq .gt_sourcenotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #vnyhqfyukq .gt_sourcenote { font-size: 90%; padding-top: 4px; padding-bottom: 4px; padding-left: 5px; padding-right: 5px; } #vnyhqfyukq .gt_left { text-align: left; } #vnyhqfyukq .gt_center { text-align: center; } #vnyhqfyukq .gt_right { text-align: right; font-variant-numeric: tabular-nums; } #vnyhqfyukq .gt_font_normal { font-weight: normal; } #vnyhqfyukq .gt_font_bold { font-weight: bold; } #vnyhqfyukq .gt_font_italic { font-style: italic; } #vnyhqfyukq .gt_super { font-size: 65%; } #vnyhqfyukq .gt_footnote_marks { font-size: 75%; vertical-align: 0.4em; position: initial; } #vnyhqfyukq .gt_asterisk { font-size: 100%; vertical-align: 0; } #vnyhqfyukq .gt_indent_1 { text-indent: 5px; } #vnyhqfyukq .gt_indent_2 { text-indent: 10px; } #vnyhqfyukq .gt_indent_3 { text-indent: 15px; } #vnyhqfyukq .gt_indent_4 { text-indent: 20px; } #vnyhqfyukq .gt_indent_5 { text-indent: 25px; } TABLE 8.7: Example of gtsummary table with trust in government estimates by voting status. American voter's trust in the federal government by whether they voted in the 2020 presidential election Voted1 Didn’t vote1 Trust in Government, 2020     Always 1.1 (0.2) 3.2 (0.7)     Most of the time 14 (0.6) 12 (1.4)     About half the time 32 (0.8) 29 (1.8)     Some of the time 45 (0.9) 39 (1.9)     Never 9.0 (0.6) 18 (1.7) American National Election Studies, 2020 Question text: How often can you trust the federal government in Washington to do what is right? 1 % (SE(%)) 8.3.2 Charts and Plots Survey analysis can result in an abundance of printed summary statistics and models. Even with the best analysis, the results can be overwhelming and difficult to comprehend. This is where charts and plots play a key role in our work. By transforming complex data into a visual representation, we can recognize patterns, relationships, and trends with greater ease. R has many packages for creating compelling and insightful charts. We will focus on {ggplot2}, a member of the {tidyverse}. This package is a powerful, flexible tool for creating a wide range of data visualization. {ggplot2} follows the “grammar of graphics,” a framework that incrementally adds layers of chart components. We can customize visual elements such as scales, colors, labels, and annotations to enhance the understanding of data. After creating the design object that we’ve been using previously, we select our desired data points by modifying the existing design to add other outcomes and calculate estimates. Below, we create a binary variable TrustGovernmentUsually, which is TRUE when TrustGovernment is “Always” or “Most of the time” and FALSE otherwise. Then, we calculate the percentage of people who usually trust the government by who they voted for in the 2020 presidential election (VotedPres2020_selection). We remove the cases where people did not vote or did not indicate for whom they voted. anes_des_der &lt;- anes_des %&gt;% mutate(TrustGovernmentUsually = case_when(is.na(TrustGovernment) ~ NA, TRUE ~ TrustGovernment %in% c(&quot;Always&quot;, &quot;Most of the time&quot;))) %&gt;% drop_na(VotedPres2020_selection) %&gt;% group_by(VotedPres2020_selection) %&gt;% summarize(pct_trust = survey_mean(TrustGovernmentUsually, na.rm = TRUE, proportion = TRUE, vartype = &quot;ci&quot;), .groups = &quot;drop&quot;) anes_des_der ## # A tibble: 3 × 4 ## VotedPres2020_selection pct_trust pct_trust_low pct_trust_upp ## &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Biden 0.124 0.108 0.141 ## 2 Trump 0.173 0.155 0.193 ## 3 Other 0.0614 0.0249 0.144 Now, we can begin creating our chart with {ggplot2}. First, we set up our plot with ggplot(). Next, we state the data points we want to show with aes. Finally, we specify the type of plot with geom_*(), in this case, geom_bar(). This initial plot is displayed in Figure 8.1. p &lt;- anes_des_der %&gt;% ggplot(aes(x = VotedPres2020_selection, y = pct_trust)) + geom_bar(stat = &quot;identity&quot;) p FIGURE 8.1: Bar chart of trust in government by chosen 2020 presidential candidate This is a great starting-off point: we can see that the percentage of people saying they usually trust the government is higher for those who voted for Trump than Biden or other candidates. What if we wanted to add color to better differentiate the three groups? We can add fill under aesthetics, denoting that we want to use those data points to fill in the bars. pcolor &lt;- anes_des_der %&gt;% ggplot(aes(x = VotedPres2020_selection, y = pct_trust, fill = VotedPres2020_selection)) + geom_bar(stat = &quot;identity&quot;) pcolor FIGURE 8.2: Bar chart of trust in government by chosen 2020 presidential candidate with colors Let’s say we wanted to follow good statistical analysis practice and include our variability in our plot. We can add another geom, geom_errorbar(), to display the confidence intervals on top of our geom_bar() layer using a plus sign +. pcol_error &lt;- anes_des_der %&gt;% ggplot(aes(x = VotedPres2020_selection, y = pct_trust, fill = VotedPres2020_selection)) + geom_bar(stat = &quot;identity&quot;) + geom_errorbar(aes(ymin = pct_trust_low, ymax = pct_trust_upp), width = 0.2) pcol_error FIGURE 8.3: Bar chart of trust in government by chosen 2020 presidential candidate with colors and error bars We can continue adding to our plot until we achieve the visualization we’d like to present. pfull &lt;- anes_des_der %&gt;% ggplot(aes(x = VotedPres2020_selection, y = pct_trust, fill = VotedPres2020_selection)) + geom_bar(stat = &quot;identity&quot;) + geom_errorbar(aes(ymin = pct_trust_low, ymax = pct_trust_upp), width = 0.2) + scale_fill_manual(values = c(&quot;#0b3954&quot;, &quot;#bfd7ea&quot;, &quot;#8d6b94&quot;)) + xlab(&quot;Election choice (2020)&quot;) + ylab(&quot;Usually trust the government&quot;) + scale_y_continuous(labels = scales::percent) + guides(fill = &quot;none&quot;) + labs(title = &quot;Percent of voters who usually trust the government by chosen 2020 presidential candidate&quot;, caption = &quot;Source: American National Election Studies, 2020&quot;) pfull FIGURE 8.4: Bar chart of trust in government by chosen 2020 presidential candidate with colors, labels, error bars, and title 8.4 Reproducibility Reproducibility is the ability to recreate or replicate the results of a data analysis. If we pass an analysis project to another person, they should be able to run the entire project from start to finish and obtain the same results. Reproducibility is a crucial aspect of survey research because it enables the verification of findings and ensures that the conclusions are not dependent on a particular person running the workflow. Others can review and rerun projects to build on existing work, reducing redundancy and errors. Reproducibility requires that we consider several key components: Code: The source code used for data cleaning, analysis, modeling, and reporting must be available, discoverable, documented, and shared. Data: The raw data used in the workflow must be available, discoverable, documented, and shared. If the raw data is sensitive or proprietary, we should strive to provide as much data as possible that would allow others to run our workflow or direct others to where they can access a restricted use file (RUF). Environment: The environment of the project must be documented. Another analyst should be able to recreate the environment, including the R version, packages, operating system, and other dependencies used in the analysis. Methodology: The analysis methodology, including the rationale behind specific decisions, interpretations, and assumptions, must be documented. Others should be able to achieve the same analysis results based on the methodology report. Many tools, practices, and project management techniques exist to make survey analysis projects easy to reproduce. For best results, they should be decided upon and applied at the beginning of a project. Below are our suggestions for a survey analysis data workflow. This list is not comprehensive but aims to provide a starting point for teams looking to create a reproducible workflow. 8.4.1 Setting Random Number Seeds Some tasks in survey analysis require randomness, such as imputation, model training, or creating random samples. By default, the random numbers generated by R will change each time we rerun the code, making it difficult to reproduce the same results. By “setting the seed,” we can control the randomness and ensure that the random numbers remain consistent whenever we rerun the code. Others can use the same seed value to reproduce our random numbers and achieve the same results, facilitating reproducibility. In R, we can use the set.seed() function to control the randomness in our code. Set a seed value by providing an integer to the function: set.seed(999) runif(5) The runif() function generates five random numbers from a uniform distribution. Since the seed is set to 999, running runif() multiple times will always produce the same sequence: [1] 0.38907138 0.58306072 0.09466569 0.85263123 0.78674676 It is important to note that set.seed() should be used before random number generation but is only necessary once per program to make the entire program reproducible. For example, we might set the seed at the top of a program where libraries tend to be loaded. 8.4.2 Git A survey analysis project produces a lot of code. As code evolves throughout a project, keeping track of the latest version becomes challenging. If a team of analysts is working on the same script, someone may use an outdated version, resulting in incorrect results or duplicative work. Version control systems like Git can help alleviate these pains. Git is a system that helps track changes in computer files. Survey analysis can use Git to follow the evolution of code and manage asynchronous work. With Git, it is easy to see any changes made in a script, revert changes, and resolve conflicts between versions. Services such as GitHub or GitLab provide hosting and sharing of files as well as version control with Git. For example, we can visit the GitHub repository for this book (https://github.com/tidy-survey-r/tidy-survey-book) and see the files that build the book, when they were committed to the repository, and the history of modifications over time. In addition to code scripts, platforms like GitHub can store data and documentation. They provide a way to maintain a history of data modifications through versioning and timestamps. By saving the data and documentation alongside the code, it becomes easier for others to refer to and access everything they need in one place. Using version control in data science projects makes collaboration and maintenance more manageable. One excellent resource is Happy Git and GitHub for the useR by Jenny Bryan and Jim Hester. 8.4.3 {renv} The {renv} package is a popular option for managing dependencies and creating virtual environments in R. It creates isolated, project-specific environments that record the packages and their versions used in the code. When initiated, {renv} checks whether the installed packages are consistent with the record. If not, it restores the correct versions for running the project. With {renv}, others can replicate the project’s environment to rerun the code and obtain consistent results. 8.4.4 Quarto/R Markdown Quarto and R Markdown are powerful tools that allow us to create documents that combine code and text. These documents present analysis results alongside the report’s narrative, so there’s no need to copy and paste code output into the final documentation. By eliminating manual steps, we can reduce the chances of errors in the final output. Rerunning a Quarto or R Markdown document re-executes the underlying code. Another team member can recreate the report and obtain the same results. Parameterization Quarto and R Markdown’s parameterization is an important aspect of reproducibility in reporting. Parameters can control various aspects of the analysis, such as dates, geography, or other analysis variables. By parameterizing our code, we can define and modify these parameters to explore different scenarios or inputs. For example, we can create a document that provides survey analysis results for Michigan. By defining a state parameter, we can rerun the same analysis for Wisconsin without having to edit the code throughout the document. We can define parameterization in the header or code chunks of our Quarto/R Markdown documents. Again, we can easily modify and document the values of these parameters, reducing errors that may occur by manually editing code throughout the script. Parameterization is also a flexible way for others to replicate the analysis and explore variations. 8.4.5 The {targets} package The {targets} package is a workflow manager enabling us to document, automate, and execute complex data workflows with multiple steps and dependencies. We define the order of execution for our code. Only the affected code and its downstream targets are re-executed when we change a script. The {targets} package also provides interactive progress monitoring and reporting, allowing us to track the status and progress of our analysis pipeline. This tool helps with reproducibility by tracking dependencies, inputs, and outputs of each step of our workflow. As noted above, many tools, practices, and project management techniques exist for achieving reproducibility. Most critical is deciding on reproducibility goals with our team and the requirements to achieve them before deciding on workflow and documentation. "],["c09-ncvs-vignette.html", "Chapter 9 National Crime Victimization Survey Vignette 9.1 Introduction 9.2 Data Structure 9.3 Survey Notation 9.4 Data File Preparation 9.5 Survey Design Objects 9.6 Calculating Estimates 9.7 Exercises", " Chapter 9 National Crime Victimization Survey Vignette Prerequisites For this chapter, here are the packages and helper functions we will need: library(tidyverse) library(srvyr) library(osfr) source(&quot;helper-fun/helper-functions.R&quot;) library(gt) We will be using data from NCVS. Here is the code to read in the three datasets that we will be working with: inc_in &lt;- read_osf(&quot;ncvs_2021_incident.rds&quot;) hh_in &lt;- read_osf(&quot;ncvs_2021_household.rds&quot;) pers_in &lt;- read_osf(&quot;ncvs_2021_person.rds&quot;) 9.1 Introduction The United States National Crime Victimization Survey (NCVS) is a household survey sponsored by the Bureau of Justice Statistics (BJS), which collects data on criminal victimization, including characteristics of the crimes, offenders, and victims. Crime types include both household and personal crimes, as well as violent and non-violent crimes. The target population of this survey is all people in the United States age 12 and older living in housing units and noninstitutional group quarters. The NCVS has been ongoing since 1992. An earlier survey, the National Crime Survey, was run from 1972 to 1991 (Bureau of Justice Statistics 2017). The survey is administered using a rotating panel. When an address enters the sample, the residents of that address are interviewed every six months for a total of seven interviews. If the initial residents move away from the address during the period, the new residents are included in the survey, as people are not followed when they move. NCVS data is publicly available and distributed by Inter-university Consortium for Political and Social Research (ICPSR)34, with data going back to 1992. The vignette in this book will include data from 2021 (United States. Bureau of Justice Statistics 2022). The NCVS data structure is complicated, and the User’s Guide contains examples for analysis in SAS, SUDAAN, SPSS, and Stata, but not R (Shook-Sa, Bonnie, Couzens, G. Lance, and Berzofsky, Marcus 2015). This vignette will adapt those examples for R. 9.2 Data Structure The data from ICPSR is distributed with five files, each having its unique identifier indicated: Address Record - YEARQ, IDHH Household Record - YEARQ, IDHH Person Record - YEARQ, IDHH, IDPER Incident Record - YEARQ, IDHH, IDPER 2021 Collection Year Incident - YEARQ, IDHH, IDPER We will focus on the household, person, and incident files. From these files, we selected a subset of columns for examples to use in this vignette. We have included data in our OSF repository, but you can download the complete files at ICPSR35. 9.3 Survey Notation The NCVS User Guide (Shook-Sa, Bonnie, Couzens, G. Lance, and Berzofsky, Marcus 2015) uses the following notation: \\(i\\) represents NCVS households, identified on the household-level file with the household identification number IDHH. \\(j\\) represents NCVS individual respondents within households \\(i\\), identified on the person-level file with the person identification number IDPER. \\(k\\) represents reporting periods (i.e., YEARQ) for households \\(i\\) and individual respondent \\(j\\). \\(l\\) represents victimization records for respondent \\(j\\) in household \\(i\\) and reporting period \\(k\\). Each record on the NCVS incident-level file is associated with a victimization record \\(l\\). \\(D\\) represents one or more domain characteristics of interest in the calculation of NCVS estimates. For victimization totals and proportions, domains can be defined on the basis of crime types (e.g., violent crimes, property crimes), characteristics of victims (e.g., age, sex, household income), or characteristics of the victimizations (e.g., victimizations reported to police, victimizations committed with a weapon present). Domains could also be a combination of all of these types of characteristics. For example, in the calculation of victimization rates, domains are defined on the basis of the characteristics of the victims. \\(A_a\\) represents the level \\(a\\) of covariate \\(A\\). Covariate \\(A\\) is defined in the calculation of victimization proportions and represents the characteristic for which the analyst wants to obtain the distribution of victimizations in domain \\(D\\). \\(C\\) represents the personal or property crime for which we want to obtain a victimization rate. In this vignette, we will discuss four estimates: Victimization totals estimate the number of criminal victimizations with a given characteristic. As demonstrated below, these can be calculated from any of the data files. The estimated victimization total, \\(\\hat{t}_D\\) for domain \\(D\\) is estimated as \\[ \\hat{t}_D = \\sum_{ijkl \\in D} v_{ijkl}\\] where \\(v_{ijkl}\\) is the series-adjusted victimization weight for household \\(i\\), respondent \\(j\\), reporting period \\(k\\), and victimization \\(l\\), that is WGTVICCY. Victimization proportions estimate characteristics among victimizations or victims. Victimization proportions are calculated using the incident data file. The estimated victimization proportion for domain \\(D\\) across level \\(a\\) of covariate \\(A\\), \\(\\hat{p}_{A_a,D}\\) is \\[ \\hat{p}_{A_a,D} =\\frac{\\sum_{ijkl \\in A_a, D} v_{ijkl}}{\\sum_{ijkl \\in D} v_{ijkl}}.\\] The numerator is the number of incidents with a particular characteristic in a domain, and the denominator is the number of incidents in a domain. Victimization rates are estimates of the number of victimizations per 1,000 persons or households in the population36. Victimization rates are calculated using the household or person-level data files. The estimated victimization rate for crime \\(C\\) in domain \\(D\\) is \\[\\hat{VR}_{C,D}= \\frac{\\sum_{ijkl \\in C,D} v_{ijkl}}{\\sum_{ijk \\in D} w_{ijk}}\\times 1000\\] where \\(w_{ijk}\\) is the person weight (WGTPERCY) or household weight (WGTHHCY) for personal and household crimes, respectively. The numerator is the number of incidents in a domain, and the denominator is the number of persons or households in a domain. Notice that the weights in the numerator and denominator are different - this is important, and in the syntax and examples below, we will discuss how to make an estimate that involves two weights. Prevalence rates are estimates of the percentage of the population (persons or households) who are victims of a crime. These are estimated using the household or person-level data files. The estimated prevalence rate for crime \\(C\\) in domain \\(D\\) is \\[ \\hat{PR}_{C, D}= \\frac{\\sum_{ijk \\in {C,D}} I_{ij}w_{ijk}}{\\sum_{ijk \\in D} w_{ijk}} \\times 100\\] where \\(I_{ij}\\) is an indicator that a person or household in domain \\(D\\) was a victim of crime \\(C\\) at any time in the year. The numerator is the number of victims in domain \\(D\\) for crime \\(C\\), and the denominator is the number of people or households in the population. 9.4 Data File Preparation Some work is necessary to prepare the files before analysis. The design variables indicating pseudostratum (V2117) and half-sample code (V2118) are only included on the household file, so they must be added to the person and incident files for any analysis. For victimization rates, we need to know the victimization status for both victims and non-victims. Therefore, the incident file must be summarized and merged onto the household or person files for household-level and person-level crimes, respectively. We begin this vignette by discussing how to create these incident summary files. This is following Section 2.2 of the NCVS User’s Guide (Shook-Sa, Bonnie, Couzens, G. Lance, and Berzofsky, Marcus 2015). 9.4.1 Preparing Files for Estimation of Victimization Rates Each record on the incident file represents one victimization, which is not the same as one incident. Some victimizations have several instances that make it difficult for the victim to differentiate the details of these incidents, labeled as “series crimes”. Appendix A of the User’s Guide indicates how to calculate the series weight in other statistical languages. Here, we adapt that code for R. Essentially, if a victimization is a series crime, its series weight is top-coded at 10 based on the number of actual victimizations. If an incident is a series crime, but the number of occurrences is unknown, the series weight is set to 6. A description of the variables used to create indicators of series and the associated weights is included in Table 9.1. TABLE 9.1: Codebook for incident variables - related to series weight Description Value Label V4016 How many times incident occur last 6 mos 1-996 Number of times 997 Don’t know V4017 How many incidents 1 1-5 incidents (not a “series”) 2 6 or more incidents 8 Residue (invalid data) V4018 Incidents similar in detail 1 Similar 2 Different (not in a “series”) 8 Residue (invalid data) V4019 Enough detail to distinguish incidents 1 Yes (not a “series”) 2 No (is a “series”) 8 Residue (invalid data) WGTVICCY Adjusted victimization weight Numeric We want to create four variables to indicate if an incident is a series crime. First, we create a variable called series using V4017, V4018, and V4019. Next, we top code the number of incidents (V4016). Finally, we create the series weight using our new top-coded variable and the existing weight. inc_series &lt;- inc_in %&gt;% mutate(series = case_when(V4017 %in% c(1, 8) ~ 1, V4018 %in% c(2, 8) ~ 1, V4019 %in% c(1, 8) ~ 1, TRUE ~ 2 # series ), n10v4016 = case_when(V4016 %in% c(997, 998) ~ NA_real_, V4016 &gt; 10 ~ 10, TRUE ~ V4016), serieswgt = case_when(series == 2 &amp; is.na(n10v4016) ~ 6, series == 2 ~ n10v4016, TRUE ~ 1), NEWWGT = WGTVICCY * serieswgt) The next step in preparing the files for estimation is to create indicators on the victimization file for characteristics of interest. Almost all BJS publications limit the analysis to records where the victimization occurred in the United States, where V4022 is not equal to 1, and we will do this for all estimates as well. A brief codebook of variables for this task is located in Table 9.2 TABLE 9.2: Codebook for incident variables - crime type indicators and characteristics Variable Description Value Label V4022 In what city/town/village 1 Outside U.S. 2 Not inside a city/town/village 3 Same city/town/village as present residence 4 Different city/town/village as present residence 5 Don’t know 6 Don’t know if 2, 4, or 5 V4049 Did offender have weapon 1 Yes 2 No 3 Don’t know V4050 What was weapon 1 At least one good entry 3 Indicates “Yes-Type Weapon-NA” 7 Indicates “Gun Type Unknown” 8 No good entry V4051 Hand gun 0 No 1 Yes V4052 Other gun 0 No 1 Yes V4053 Knife 0 No 1 Yes V4399 Reported to police 1 Yes 2 No 3 Don’t know V4529 Type of crime code 01 Completed rape 02 Attempted rape 03 Sexual attack with serious assault 04 Sexual attack with minor assault 05 Completed robbery with injury from serious assault 06 Completed robbery with injury from minor assault 07 Completed robbery without injury from minor assault 08 Attempted robbery with injury from serious assault 09 Attempted robbery with injury from minor assault 10 Attempted robbery without injury 11 Completed aggravated assault with injury 12 Attempted aggravated assault with weapon 13 Threatened assault with weapon 14 Simple assault completed with injury 15 Sexual assault without injury 16 Unwanted sexual contact without force 17 Assault without weapon without injury 18 Verbal threat of rape 19 Verbal threat of sexual assault 20 Verbal threat of assault 21 Completed purse snatching 22 Attempted purse snatching 23 Pocket picking (completed only) 31 Completed burglary, forcible entry 32 Completed burglary, unlawful entry without force 33 Attempted forcible entry 40 Completed motor vehicle theft 41 Attempted motor vehicle theft 54 Completed theft less than $10 55 Completed theft $10 to $49 56 Completed theft $50 to $249 57 Completed theft $250 or greater 58 Completed theft value NA 59 Attempted theft Using these variables, we will create the following indicators: Property crime V4529 &gt;= 31 Variable: Property Violent crime V4529 &lt;= 20 Variable: Violent Property crime reported to the police V4529 &gt;= 31 and V4399=1 Variable: Property_ReportPolice Violent crime reported to the police V4529 &lt; 31 and V4399=1 Variable: Violent_ReportPolice Aggravated assault without a weapon V4529 in 11:12 and V4049=2 Variable: AAST_NoWeap Aggravated assault with a firearm V4529 in 11:12 and V4049=1 and (V4051=1 or V4052=1 or V4050=7) Variable: AAST_Firearm Aggravated assault with a knife or sharp object V4529 in 11:12 and V4049=1 and (V4053=1 or V4054=1) Variable: AAST_Knife Aggravated assault with another type of weapon V4529 in 11:12 and V4049=1 and V4050=1 and not firearm or knife Variable: AAST_Other inc_ind &lt;- inc_series %&gt;% filter(V4022 != 1) %&gt;% mutate(WeapCat = case_when(is.na(V4049) ~ NA_character_, V4049 == 2 ~ &quot;NoWeap&quot;, V4049 == 3 ~ &quot;UnkWeapUse&quot;, V4050 == 3 ~ &quot;Other&quot;, V4051 == 1 | V4052 == 1 | V4050 == 7 ~ &quot;Firearm&quot;, V4053 == 1 | V4054 == 1 ~ &quot;Knife&quot;, TRUE ~ &quot;Other&quot;), V4529_num = parse_number(as.character(V4529)), ReportPolice = V4399 == 1, Property = V4529_num &gt;= 31, Violent = V4529_num &lt;= 20, Property_ReportPolice = Property &amp; ReportPolice, Violent_ReportPolice = Violent &amp; ReportPolice, AAST = V4529_num %in% 11:13, AAST_NoWeap = AAST &amp; WeapCat == &quot;NoWeap&quot;, AAST_Firearm = AAST &amp; WeapCat == &quot;Firearm&quot;, AAST_Knife = AAST &amp; WeapCat == &quot;Knife&quot;, AAST_Other = AAST &amp; WeapCat == &quot;Other&quot;) This is a good point to pause to look at the output of crosswalks between an original variable and a derived one to check that the logic was programmed correctly and that everything ends up in the expected category. inc_series %&gt;% count(V4022) ## # A tibble: 6 × 2 ## V4022 n ## &lt;fct&gt; &lt;int&gt; ## 1 1 34 ## 2 2 65 ## 3 3 7697 ## 4 4 1143 ## 5 5 39 ## 6 8 4 inc_ind %&gt;% count(V4022) ## # A tibble: 5 × 2 ## V4022 n ## &lt;fct&gt; &lt;int&gt; ## 1 2 65 ## 2 3 7697 ## 3 4 1143 ## 4 5 39 ## 5 8 4 inc_ind %&gt;% count(WeapCat, V4049, V4050, V4051, V4052, V4052, V4053, V4054) ## # A tibble: 13 × 8 ## WeapCat V4049 V4050 V4051 V4052 V4053 V4054 n ## &lt;chr&gt; &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; &lt;int&gt; ## 1 Firearm 1 1 0 1 0 0 15 ## 2 Firearm 1 1 0 1 1 1 1 ## 3 Firearm 1 1 1 0 0 0 125 ## 4 Firearm 1 1 1 0 1 0 2 ## 5 Firearm 1 1 1 1 0 0 3 ## 6 Firearm 1 7 0 0 0 0 3 ## 7 Knife 1 1 0 0 0 1 14 ## 8 Knife 1 1 0 0 1 0 71 ## 9 NoWeap 2 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; 1794 ## 10 Other 1 1 0 0 0 0 147 ## 11 Other 1 3 0 0 0 0 26 ## 12 UnkWeapUse 3 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; 519 ## 13 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; 6228 inc_ind %&gt;% count(V4529, Property, Violent, AAST) %&gt;% print(n = 40) ## # A tibble: 34 × 5 ## V4529 Property Violent AAST n ## &lt;fct&gt; &lt;lgl&gt; &lt;lgl&gt; &lt;lgl&gt; &lt;int&gt; ## 1 1 FALSE TRUE FALSE 45 ## 2 2 FALSE TRUE FALSE 20 ## 3 3 FALSE TRUE FALSE 11 ## 4 4 FALSE TRUE FALSE 3 ## 5 5 FALSE TRUE FALSE 24 ## 6 6 FALSE TRUE FALSE 26 ## 7 7 FALSE TRUE FALSE 59 ## 8 8 FALSE TRUE FALSE 5 ## 9 9 FALSE TRUE FALSE 7 ## 10 10 FALSE TRUE FALSE 57 ## 11 11 FALSE TRUE TRUE 97 ## 12 12 FALSE TRUE TRUE 91 ## 13 13 FALSE TRUE TRUE 163 ## 14 14 FALSE TRUE FALSE 165 ## 15 15 FALSE TRUE FALSE 24 ## 16 16 FALSE TRUE FALSE 12 ## 17 17 FALSE TRUE FALSE 357 ## 18 18 FALSE TRUE FALSE 14 ## 19 19 FALSE TRUE FALSE 3 ## 20 20 FALSE TRUE FALSE 607 ## 21 21 FALSE FALSE FALSE 2 ## 22 22 FALSE FALSE FALSE 2 ## 23 23 FALSE FALSE FALSE 19 ## 24 31 TRUE FALSE FALSE 248 ## 25 32 TRUE FALSE FALSE 634 ## 26 33 TRUE FALSE FALSE 188 ## 27 40 TRUE FALSE FALSE 256 ## 28 41 TRUE FALSE FALSE 97 ## 29 54 TRUE FALSE FALSE 407 ## 30 55 TRUE FALSE FALSE 1006 ## 31 56 TRUE FALSE FALSE 1686 ## 32 57 TRUE FALSE FALSE 1420 ## 33 58 TRUE FALSE FALSE 798 ## 34 59 TRUE FALSE FALSE 395 inc_ind %&gt;% count(ReportPolice, V4399) ## # A tibble: 4 × 3 ## ReportPolice V4399 n ## &lt;lgl&gt; &lt;fct&gt; &lt;int&gt; ## 1 FALSE 2 5670 ## 2 FALSE 3 103 ## 3 FALSE 8 12 ## 4 TRUE 1 3163 inc_ind %&gt;% count(AAST, WeapCat, AAST_NoWeap, AAST_Firearm, AAST_Knife, AAST_Other) ## # A tibble: 11 × 7 ## AAST WeapCat AAST_NoWeap AAST_Firearm AAST_Knife AAST_Other n ## &lt;lgl&gt; &lt;chr&gt; &lt;lgl&gt; &lt;lgl&gt; &lt;lgl&gt; &lt;lgl&gt; &lt;int&gt; ## 1 FALSE Firearm FALSE FALSE FALSE FALSE 34 ## 2 FALSE Knife FALSE FALSE FALSE FALSE 23 ## 3 FALSE NoWeap FALSE FALSE FALSE FALSE 1769 ## 4 FALSE Other FALSE FALSE FALSE FALSE 27 ## 5 FALSE UnkWeapUse FALSE FALSE FALSE FALSE 516 ## 6 FALSE &lt;NA&gt; FALSE FALSE FALSE FALSE 6228 ## 7 TRUE Firearm FALSE TRUE FALSE FALSE 115 ## 8 TRUE Knife FALSE FALSE TRUE FALSE 62 ## 9 TRUE NoWeap TRUE FALSE FALSE FALSE 25 ## 10 TRUE Other FALSE FALSE FALSE TRUE 146 ## 11 TRUE UnkWeapUse FALSE FALSE FALSE FALSE 3 After creating indicators of victimization types and characteristics, the file is summarized, and crimes are summed across persons or households by YEARQ. Property crimes (i.e., crimes committed against households, such as household burglary or motor vehicle theft) are summed across households, and personal crimes (i.e., crimes committed against an individual, such as assault, robbery, and personal theft) are summed across persons. The indicators are summed using the serieswgt, and the variable WGTVICCY needs to be retained for later analysis. inc_hh_sums &lt;- inc_ind %&gt;% filter(V4529_num &gt; 23) %&gt;% # restrict to household crimes group_by(YEARQ, IDHH) %&gt;% summarize(WGTVICCY = WGTVICCY[1], across(starts_with(&quot;Property&quot;), ~ sum(. * serieswgt), .names = &quot;{.col}&quot;), .groups = &quot;drop&quot;) inc_pers_sums &lt;- inc_ind %&gt;% filter(V4529_num &lt;= 23) %&gt;% # restrict to person crimes group_by(YEARQ, IDHH, IDPER) %&gt;% summarize(WGTVICCY = WGTVICCY[1], across(c(starts_with(&quot;Violent&quot;), starts_with(&quot;AAST&quot;)), ~ sum(. * serieswgt), .names = &quot;{.col}&quot;), .groups = &quot;drop&quot;) Now, we merge the victimization summary files into the appropriate files. For any record on the household or person file that is not on the victimization file, the victimization counts are set to 0 after merging. In this step, we will also create the victimization adjustment factor. See 2.2.4 in the User’s Guide for details of why this adjustment is created (Shook-Sa, Bonnie, Couzens, G. Lance, and Berzofsky, Marcus (2015)). It is calculated as follows: \\[ A_{ijk}=\\frac{v_{ijk}}{w_{ijk}}\\] where \\(w_{ijk}\\) is the person weight (WGTPERCY) for personal crimes or the household weight (WGTHHCY) for household crimes, and \\(v_{ijk}\\) is the victimization weight (WGTVICCY) for household \\(i\\), respondent \\(j\\), in reporting period \\(k\\). The adjustment factor is set to 0 if no incidents are reported. # Set up a list of 0s for each crime type/characteristic to replace # NA&#39;s hh_z_list &lt;- rep(0, ncol(inc_hh_sums) - 3) %&gt;% as.list() %&gt;% setNames(names(inc_hh_sums)[-(1:3)]) pers_z_list &lt;- rep(0, ncol(inc_pers_sums) - 4) %&gt;% as.list() %&gt;% setNames(names(inc_pers_sums)[-(1:4)]) hh_vsum &lt;- hh_in %&gt;% full_join(inc_hh_sums, by = c(&quot;YEARQ&quot;, &quot;IDHH&quot;)) %&gt;% replace_na(hh_z_list) %&gt;% mutate(ADJINC_WT = if_else(is.na(WGTVICCY), 0, WGTVICCY/WGTHHCY)) pers_vsum &lt;- pers_in %&gt;% full_join(inc_pers_sums, by = c(&quot;YEARQ&quot;, &quot;IDHH&quot;, &quot;IDPER&quot;)) %&gt;% replace_na(pers_z_list) %&gt;% mutate(ADJINC_WT = if_else(is.na(WGTVICCY), 0, WGTVICCY/WGTPERCY)) 9.4.2 Derived Demographic Variables A final step in file preparation for the household and person files is creating any derived variables on the household and person files, such as income categories or age categories, for subgroup analysis. We can do this step before or after merging the victimization counts. 9.4.2.1 Household Variables For the household file, we create categories for tenure (rental status), urbanicity, income, place size, and region. A codebook of the household variables are located in Table 9.3. TABLE 9.3: Codebook for household variables Variable Description Value Label V2015 Tenure 1 Owned or being bought 2 Rented for cash 3 No cash rent SC214A Household Income 01 Less than $5,000 02 $5,000 to $7,499 03 $7,500 to $9,999 04 $10,000 to $12,499 05 $12,500 to $14,999 06 $15,000 to $17,499 07 $17,500 to $19,999 08 $20,000 to $24,999 09 $25,000 to $29,999 10 $30,000 to $34,999 11 $35,000 to $39,999 12 $40,000 to $49,999 13 $50,000 to $74,999 15 $75,000 to $99,999 16 $100,000-$149,999 17 $150,000-$199,999 18 $200,000 or more V2126B Place Size Code 00 Not in a place 13 Under 10,000 16 10,000-49,999 17 50,000-99,999 18 100,000-249,999 19 250,000-499,999 20 500,000-999,999 21 1,000,000-2,499,999 22 2,500,000-4,999,999 23 5,000,000 or more V2127B Region 1 Northeast 2 Midwest 3 South 4 West V2143 Urbanicity 1 Urban 2 Suburban 3 Rural hh_vsum_der &lt;- hh_vsum %&gt;% mutate(Tenure = factor(case_when(V2015 == 1 ~ &quot;Owned&quot;, !is.na(V2015) ~ &quot;Rented&quot;), levels = c(&quot;Owned&quot;, &quot;Rented&quot;)), Urbanicity = factor(case_when(V2143 == 1 ~ &quot;Urban&quot;, V2143 == 2 ~ &quot;Suburban&quot;, V2143 == 3 ~ &quot;Rural&quot;), levels = c(&quot;Urban&quot;, &quot;Suburban&quot;, &quot;Rural&quot;)), SC214A_num = as.numeric(as.character(SC214A)), Income = case_when(SC214A_num &lt;= 8 ~ &quot;Less than $25,000&quot;, SC214A_num &lt;= 12 ~ &quot;$25,000-49,999&quot;, SC214A_num &lt;= 15 ~ &quot;$50,000-99,999&quot;, SC214A_num &lt;= 17 ~ &quot;$100,000-199,999&quot;, SC214A_num &lt;= 18 ~ &quot;$200,000 or more&quot;), Income = fct_reorder(Income, SC214A_num, .na_rm = FALSE), PlaceSize = case_match(as.numeric(as.character(V2126B)), 0 ~ &quot;Not in a place&quot;, 13 ~ &quot;Under 10,000&quot;, 16 ~ &quot;10,000-49,999&quot;, 17 ~ &quot;50,000-99,999&quot;, 18 ~ &quot;100,000-249,999&quot;, 19 ~ &quot;250,000-499,999&quot;, 20 ~ &quot;500,000-999,999&quot;, c(21, 22, 23) ~ &quot;1,000,000 or more&quot;), PlaceSize = fct_reorder(PlaceSize, as.numeric(V2126B)), Region = case_match(as.numeric(V2127B), 1 ~ &quot;Northeast&quot;, 2 ~ &quot;Midwest&quot;, 3 ~ &quot;South&quot;, 4 ~ &quot;West&quot;), Region = fct_reorder(Region, as.numeric(V2127B))) As before, we want to check to make sure the recoded variables we create match the existing data as expected. hh_vsum_der %&gt;% count(Tenure, V2015) ## # A tibble: 4 × 3 ## Tenure V2015 n ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; ## 1 Owned 1 101944 ## 2 Rented 2 46269 ## 3 Rented 3 1925 ## 4 &lt;NA&gt; &lt;NA&gt; 106322 hh_vsum_der %&gt;% count(Urbanicity, V2143) ## # A tibble: 3 × 3 ## Urbanicity V2143 n ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; ## 1 Urban 1 26878 ## 2 Suburban 2 173491 ## 3 Rural 3 56091 hh_vsum_der %&gt;% count(Income, SC214A) ## # A tibble: 18 × 3 ## Income SC214A n ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; ## 1 Less than $25,000 1 7841 ## 2 Less than $25,000 2 2626 ## 3 Less than $25,000 3 3949 ## 4 Less than $25,000 4 5546 ## 5 Less than $25,000 5 5445 ## 6 Less than $25,000 6 4821 ## 7 Less than $25,000 7 5038 ## 8 Less than $25,000 8 11887 ## 9 $25,000-49,999 9 11550 ## 10 $25,000-49,999 10 13689 ## 11 $25,000-49,999 11 13655 ## 12 $25,000-49,999 12 23282 ## 13 $50,000-99,999 13 44601 ## 14 $50,000-99,999 15 33353 ## 15 $100,000-199,999 16 34287 ## 16 $100,000-199,999 17 15317 ## 17 $200,000 or more 18 16892 ## 18 &lt;NA&gt; &lt;NA&gt; 2681 hh_vsum_der %&gt;% count(PlaceSize, V2126B) ## # A tibble: 10 × 3 ## PlaceSize V2126B n ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; ## 1 Not in a place 0 69484 ## 2 Under 10,000 13 39873 ## 3 10,000-49,999 16 53002 ## 4 50,000-99,999 17 27205 ## 5 100,000-249,999 18 24461 ## 6 250,000-499,999 19 13111 ## 7 500,000-999,999 20 15194 ## 8 1,000,000 or more 21 6167 ## 9 1,000,000 or more 22 3857 ## 10 1,000,000 or more 23 4106 hh_vsum_der %&gt;% count(Region, V2127B) ## # A tibble: 4 × 3 ## Region V2127B n ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; ## 1 Northeast 1 41585 ## 2 Midwest 2 74666 ## 3 South 3 87783 ## 4 West 4 52426 9.4.2.2 Person Variables For the person file, we create categories for sex, race/Hispanic origin, age categories, and marital status. A codebook of the household variables is located in Table 9.4. We also merge the household demographics to the person file as well as the design variables (V2117 and V2118). TABLE 9.4: Codebook for person variables Variable Description Value Label V3014 Age 12 through 90 V3015 Current Marital Status 1 Married 2 Widowed 3 Divorced 4 Separated 5 Never married V3018 Sex 1 Male 2 Female V3023A Race 01 White only 02 Black only 03 American Indian, Alaska native only 04 Asian only 05 Hawaiian/Pacific Islander only 06 White-Black 07 White-American Indian 08 White-Asian 09 White-Hawaiian 10 Black-American Indian 11 Black-Asian 12 Black-Hawaiian/Pacific Islander 13 American Indian-Asian 14 Asian-Hawaiian/Pacific Islander 15 White-Black-American Indian 16 White-Black-Asian 17 White-American Indian-Asian 18 White-Asian-Hawaiian 19 2 or 3 races 20 4 or 5 races V3024 Hispanic Origin 1 Yes 2 No # Set label for usage later NHOPI &lt;- &quot;Native Hawaiian or Other Pacific Islander&quot; pers_vsum_der &lt;- pers_vsum %&gt;% mutate(Sex = factor(case_when(V3018 == 1 ~ &quot;Male&quot;, V3018 == 2 ~ &quot;Female&quot;)), RaceHispOrigin = factor(case_when(V3024 == 1 ~ &quot;Hispanic&quot;, V3023A == 1 ~ &quot;White&quot;, V3023A == 2 ~ &quot;Black&quot;, V3023A == 4 ~ &quot;Asian&quot;, V3023A == 5 ~ NHOPI, TRUE ~ &quot;Other&quot;), levels = c(&quot;White&quot;, &quot;Black&quot;, &quot;Hispanic&quot;, &quot;Asian&quot;, NHOPI, &quot;Other&quot;)), V3014_num = as.numeric(as.character(V3014)), AgeGroup = case_when(V3014_num &lt;= 17 ~ &quot;12-17&quot;, V3014_num &lt;= 24 ~ &quot;18-24&quot;, V3014_num &lt;= 34 ~ &quot;25-34&quot;, V3014_num &lt;= 49 ~ &quot;35-49&quot;, V3014_num &lt;= 64 ~ &quot;50-64&quot;, V3014_num &lt;= 90 ~ &quot;65 or older&quot;), AgeGroup = fct_reorder(AgeGroup, V3014_num), MaritalStatus = factor(case_when(V3015 == 1 ~ &quot;Married&quot;, V3015 == 2 ~ &quot;Widowed&quot;, V3015 == 3 ~ &quot;Divorced&quot;, V3015 == 4 ~ &quot;Separated&quot;, V3015 == 5 ~ &quot;Never married&quot;), levels = c(&quot;Never married&quot;, &quot;Married&quot;, &quot;Widowed&quot;, &quot;Divorced&quot;, &quot;Separated&quot;))) %&gt;% left_join(hh_vsum_der %&gt;% select(YEARQ, IDHH, V2117, V2118, Tenure:Region), by = c(&quot;YEARQ&quot;, &quot;IDHH&quot;)) As before, we want to check to make sure the recoded variables we create match the existing data as expected. pers_vsum_der %&gt;% count(Sex, V3018) ## # A tibble: 2 × 3 ## Sex V3018 n ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; ## 1 Female 2 150956 ## 2 Male 1 140922 pers_vsum_der %&gt;% count(RaceHispOrigin, V3024) ## # A tibble: 11 × 3 ## RaceHispOrigin V3024 n ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; ## 1 White 2 197292 ## 2 White 8 883 ## 3 Black 2 29947 ## 4 Black 8 120 ## 5 Hispanic 1 41450 ## 6 Asian 2 16015 ## 7 Asian 8 61 ## 8 Native Hawaiian or Other Pacific Islander 2 891 ## 9 Native Hawaiian or Other Pacific Islander 8 9 ## 10 Other 2 5161 ## 11 Other 8 49 pers_vsum_der %&gt;% filter(RaceHispOrigin != &quot;Hispanic&quot; | is.na(RaceHispOrigin)) %&gt;% count(RaceHispOrigin, V3023A) ## # A tibble: 20 × 3 ## RaceHispOrigin V3023A n ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; ## 1 White 1 198175 ## 2 Black 2 30067 ## 3 Asian 4 16076 ## 4 Native Hawaiian or Other Pacific Islander 5 900 ## 5 Other 3 1319 ## 6 Other 6 1217 ## 7 Other 7 1025 ## 8 Other 8 837 ## 9 Other 9 184 ## 10 Other 10 178 ## 11 Other 11 87 ## 12 Other 12 27 ## 13 Other 13 13 ## 14 Other 14 53 ## 15 Other 15 136 ## 16 Other 16 45 ## 17 Other 17 11 ## 18 Other 18 33 ## 19 Other 19 22 ## 20 Other 20 23 pers_vsum_der %&gt;% group_by(AgeGroup) %&gt;% summarize(minAge = min(V3014), maxAge = max(V3014), .groups = &quot;drop&quot;) ## # A tibble: 6 × 3 ## AgeGroup minAge maxAge ## &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 12-17 12 17 ## 2 18-24 18 24 ## 3 25-34 25 34 ## 4 35-49 35 49 ## 5 50-64 50 64 ## 6 65 or older 65 90 pers_vsum_der %&gt;% count(MaritalStatus, V3015) ## # A tibble: 6 × 3 ## MaritalStatus V3015 n ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; ## 1 Never married 5 90425 ## 2 Married 1 148131 ## 3 Widowed 2 17668 ## 4 Divorced 3 28596 ## 5 Separated 4 4524 ## 6 &lt;NA&gt; 8 2534 We then create tibbles that contain only the variables we need, which makes it easier for analyses. hh_vsum_slim &lt;- hh_vsum_der %&gt;% select(YEARQ:V2118, WGTVICCY:ADJINC_WT, Tenure, Urbanicity, Income, PlaceSize, Region) pers_vsum_slim &lt;- pers_vsum_der %&gt;% select(YEARQ:WGTPERCY, WGTVICCY:ADJINC_WT, Sex:Region) To calculate estimates about types of crime, such as what percentage of violent crimes are reported to the police, we must use the incident file. The incident file is not guaranteed to have every pseudostratum and half-sample code, so dummy records are created to append before estimation. Finally, we merge demographic variables onto the incident tibble. dummy_records &lt;- hh_vsum_slim %&gt;% distinct(V2117, V2118) %&gt;% mutate(Dummy = 1, WGTVICCY = 1, NEWWGT = 1) inc_analysis &lt;- inc_ind %&gt;% mutate(Dummy = 0) %&gt;% left_join(select(pers_vsum_slim, YEARQ, IDHH, IDPER, Sex:Region), by = c(&quot;YEARQ&quot;, &quot;IDHH&quot;, &quot;IDPER&quot;)) %&gt;% bind_rows(dummy_records) %&gt;% select(YEARQ:IDPER, WGTVICCY, NEWWGT, V4529, WeapCat, ReportPolice, Property:Region) The tibbles hh_vsum_slim, pers_vsum_slim, and inc_analysis can now be used to create design objects and calculate crime rate estimates. 9.5 Survey Design Objects All the data prep above is necessary to prepare the data for survey analysis. At this point, we can create the design objects and finally begin analysis. We will create three design objects for different types of analysis as they depend on which type of estimate we are creating. For the incident data, the weight of analysis is NEWWGT, which we constructed previously. The household and person-level data use WGTHHCY and WGTPERCY, respectively. For all analyses, V2117 is the strata variable, and V2118 is the cluster/PSU variable for analysis. inc_des &lt;- inc_analysis %&gt;% as_survey(weight = NEWWGT, strata = V2117, ids = V2118, nest = TRUE) hh_des &lt;- hh_vsum_slim %&gt;% as_survey(weight = WGTHHCY, strata = V2117, ids = V2118, nest = TRUE) pers_des &lt;- pers_vsum_slim %&gt;% as_survey(weight = WGTPERCY, strata = V2117, ids = V2118, nest = TRUE) 9.6 Calculating Estimates Now that we have prepared our data and created the design effects, we can calculate our estimates. As a reminder, those are: Victimization totals estimate the number of criminal victimizations with a given characteristic. Victimization proportions estimate characteristics among victimizations or victims. Victimization rates are estimates of the number of victimizations per 1,000 persons or households in the population. Prevalence rates are estimates of the percentage of the population (persons or households) who are victims of a crime. 9.6.1 Estimation 1: Victimization Totals There are two ways to calculate victimization totals. Using the incident design object (inc_des) is the most straightforward method, but the person (pers_des) and household (hh_des) design objects can be used as well if the adjustment factor (ADJINC_WT) is incorporated. In the example below, the total number of property and violent victimizations is first calculated using the incident file and then using the household and person design objects. The incident file is smaller, and thus, estimation is faster using that file, but the estimates will be the same as illustrated below: vt1 &lt;- inc_des %&gt;% summarize(Property_Vzn = survey_total(Property, na.rm = TRUE), Violent_Vzn = survey_total(Violent, na.rm = TRUE)) vt2a &lt;- hh_des %&gt;% summarize(Property_Vzn = survey_total(Property * ADJINC_WT, na.rm = TRUE)) vt2b &lt;- pers_des %&gt;% summarize(Violent_Vzn = survey_total(Violent * ADJINC_WT, na.rm = TRUE)) vt1 ## # A tibble: 1 × 4 ## Property_Vzn Property_Vzn_se Violent_Vzn Violent_Vzn_se ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 11682056. 263844. 4598306. 198115. vt2a ## # A tibble: 1 × 2 ## Property_Vzn Property_Vzn_se ## &lt;dbl&gt; &lt;dbl&gt; ## 1 11682056. 263844. vt2b ## # A tibble: 1 × 2 ## Violent_Vzn Violent_Vzn_se ## &lt;dbl&gt; &lt;dbl&gt; ## 1 4598306. 198115. The number of victimizations estimated using the incident file is equivalent to the person and household file method. There are 1.1682^{7} property incidents and 4.5983^{6} violent incidents in a six-month period. 9.6.2 Estimation 2: Victimization Proportions Victimization proportions are proportions describing features of a victimization. The key here is that these are questions among victimizations, not among the population. These types of estimates can only be calculated using the incident design object (inc_des). For example, we could be interested in the percentage of property victimizations reported to the police: prop1 &lt;- inc_des %&gt;% filter(Property) %&gt;% summarize(Pct = survey_mean(ReportPolice, na.rm = TRUE) * 100) prop1 ## # A tibble: 1 × 2 ## Pct Pct_se ## &lt;dbl&gt; &lt;dbl&gt; ## 1 30.8 0.798 Or, the percentage of violent victimizations that are in urban areas: prop2 &lt;- inc_des %&gt;% filter(Violent) %&gt;% summarize(Pct = survey_mean(Urbanicity == &quot;Urban&quot;, na.rm = TRUE) * 100) prop2 ## # A tibble: 1 × 2 ## Pct Pct_se ## &lt;dbl&gt; &lt;dbl&gt; ## 1 18.1 1.49 In 2021, we estimate that 30.8% of property crimes were reported to the police and 18.1% of violent crimes occurred in urban areas. 9.6.3 Estimation 3: Victimization Rates Victimization rates measure the number of victimizations per population. They are not an estimate of the proportion of households or persons who are victimized, which is a prevalence rate described in section 9.6.4. Victimization rates are estimated using the household (hh_des) or person (pers_des) design objects depending on the type of crime, and the adjustment factor (ADJINC_WT) must be incorporated. We return to the example of property and violent victimizations used in the example for victimization totals (section 9.6.1). In the following example, the property victimization totals are calculated as above, as well as the property victimization rate (using survey_mean()) and the population size using survey_total(). As mentioned in the introduction, victimization rates use the incident weight in the numerator and the person or household weight in the denominator. This is accomplished by calculating the rates with the weight adjustment (ADJINC_WT) multiplied by the estimate of interest. Let’s look at an example of property victimization. vr_prop &lt;- hh_des %&gt;% summarize(Property_Vzn = survey_total(Property * ADJINC_WT, na.rm = TRUE), Property_Rate = survey_mean(Property * ADJINC_WT * 1000, na.rm = TRUE), PopSize = survey_total(1, vartype = NULL)) vr_prop ## # A tibble: 1 × 5 ## Property_Vzn Property_Vzn_se Property_Rate Property_Rate_se PopSize ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 11682056. 263844. 90.3 1.95 129319232. In the output above, we see the estimate for property victimization rate in 2021 was 90.3 per 1,000 households, which is consistent with calculating as the number of victimizations per 1,000 population as demonstrated in the next chunk: vr_prop %&gt;% select(-ends_with(&quot;se&quot;)) %&gt;% mutate(Property_Rate_manual = Property_Vzn/PopSize * 1000) ## # A tibble: 1 × 4 ## Property_Vzn Property_Rate PopSize Property_Rate_manual ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 11682056. 90.3 129319232. 90.3 Victimization rates can also be calculated for particular characteristics of the victimization. In the following example, the rate of aggravated assault with no weapon, with a firearm, with a knife, and with another weapon. pers_des %&gt;% summarize(across(starts_with(&quot;AAST_&quot;), ~survey_mean(. * ADJINC_WT * 1000, na.rm = TRUE))) ## # A tibble: 1 × 8 ## AAST_NoWeap AAST_NoWeap_se AAST_Firearm AAST_Firearm_se AAST_Knife ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 0.249 0.0595 0.860 0.101 0.455 ## # ℹ 3 more variables: AAST_Knife_se &lt;dbl&gt;, AAST_Other &lt;dbl&gt;, ## # AAST_Other_se &lt;dbl&gt; A common desire is to calculate victimization rates by several characteristics. For example, we may want to calculate the violent victimization rate and aggravated assault rate by sex, race/Hispanic origin, age group, marital status, and household income. This requires a group_by() statement for each categorization separately. Thus, we make a function to do this and then use map_df() from the {purrr} package (part of the tidyverse) to loop through the variables. Finally, the {gt} package is used to make a publishable table. pers_est_by &lt;- function(byvar) { pers_des %&gt;% rename(Level := { { byvar } }) %&gt;% filter(!is.na(Level)) %&gt;% group_by(Level) %&gt;% summarize(Violent = survey_mean(Violent * ADJINC_WT * 1000, na.rm = TRUE), AAST = survey_mean(AAST * ADJINC_WT * 1000, na.rm = TRUE)) %&gt;% mutate(Variable = byvar, LevelNum = as.numeric(Level), Level = as.character(Level)) %&gt;% select(Variable, Level, LevelNum, everything()) } pers_est_df &lt;- c(&quot;Sex&quot;, &quot;RaceHispOrigin&quot;, &quot;AgeGroup&quot;, &quot;MaritalStatus&quot;, &quot;Income&quot;) %&gt;% map_df(pers_est_by) pers_est_df %&gt;% mutate(Variable = case_when(Variable == &quot;RaceHispOrigin&quot; ~ &quot;Race/Hispanic origin&quot;, Variable == &quot;MaritalStatus&quot; ~ &quot;Marital status&quot;, Variable == &quot;AgeGroup&quot; ~ &quot;Age&quot;, TRUE ~ Variable)) %&gt;% select(-LevelNum) %&gt;% group_by(Variable) %&gt;% gt(rowname_col = &quot;Level&quot;) %&gt;% tab_spanner(label = &quot;Violent crime&quot;, id = &quot;viol_span&quot;, columns = c(&quot;Violent&quot;, &quot;Violent_se&quot;)) %&gt;% tab_spanner(label = &quot;Aggravated assault&quot;, columns = c(&quot;AAST&quot;, &quot;AAST_se&quot;)) %&gt;% cols_label(Violent = &quot;Rate&quot;, Violent_se = &quot;SE&quot;, AAST = &quot;Rate&quot;, AAST_se = &quot;SE&quot;, ) %&gt;% fmt_number(columns = c(&quot;Violent&quot;, &quot;Violent_se&quot;, &quot;AAST&quot;, &quot;AAST_se&quot;), decimals = 1) %&gt;% tab_footnote(footnote = &quot;Includes rape or sexual assault, robbery, aggravated assault, and simple assault.&quot;, locations = cells_column_spanners(spanners = &quot;viol_span&quot;)) %&gt;% tab_footnote(footnote = &quot;Excludes persons of Hispanic origin&quot;, locations = cells_stub(rows = Level %in% c(&quot;White&quot;, &quot;Black&quot;, &quot;Asian&quot;, NHOPI, &quot;Other&quot;))) %&gt;% tab_footnote(footnote = &quot;Includes persons who identified as Native Hawaiian or Other Pacific Islander only.&quot;, locations = cells_stub(rows = Level == NHOPI)) %&gt;% tab_footnote(footnote = &quot;Includes persons who identified as American Indian or Alaska Native only or as two or more races.&quot;, locations = cells_stub(rows = Level == &quot;Other&quot;)) %&gt;% tab_source_note(source_note = &quot;Note: Rates per 1,000 persons age 12 or older.&quot;) %&gt;% tab_source_note(source_note = &quot;Source: Bureau of Justice Statistics, National Crime Victimization Survey, 2021.&quot;) %&gt;% tab_stubhead(label = &quot;Victim demographic&quot;) %&gt;% tab_caption(&quot;Rate and standard error of violent victimization, by type of crime and demographic characteristics, 2021&quot;) #yivmmdvpqx table { font-family: system-ui, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Noto Color Emoji'; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; } #yivmmdvpqx thead, #yivmmdvpqx tbody, #yivmmdvpqx tfoot, #yivmmdvpqx tr, #yivmmdvpqx td, #yivmmdvpqx th { border-style: none; } #yivmmdvpqx p { margin: 0; padding: 0; } #yivmmdvpqx .gt_table { display: table; border-collapse: collapse; line-height: normal; margin-left: auto; margin-right: auto; color: #333333; font-size: 16px; font-weight: normal; font-style: normal; background-color: #FFFFFF; width: auto; border-top-style: solid; border-top-width: 2px; border-top-color: #A8A8A8; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #A8A8A8; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; } #yivmmdvpqx .gt_caption { padding-top: 4px; padding-bottom: 4px; } #yivmmdvpqx .gt_title { color: #333333; font-size: 125%; font-weight: initial; padding-top: 4px; padding-bottom: 4px; padding-left: 5px; padding-right: 5px; border-bottom-color: #FFFFFF; border-bottom-width: 0; } #yivmmdvpqx .gt_subtitle { color: #333333; font-size: 85%; font-weight: initial; padding-top: 3px; padding-bottom: 5px; padding-left: 5px; padding-right: 5px; border-top-color: #FFFFFF; border-top-width: 0; } #yivmmdvpqx .gt_heading { background-color: #FFFFFF; text-align: center; border-bottom-color: #FFFFFF; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #yivmmdvpqx .gt_bottom_border { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #yivmmdvpqx .gt_col_headings { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #yivmmdvpqx .gt_col_heading { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 6px; padding-left: 5px; padding-right: 5px; overflow-x: hidden; } #yivmmdvpqx .gt_column_spanner_outer { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; padding-top: 0; padding-bottom: 0; padding-left: 4px; padding-right: 4px; } #yivmmdvpqx .gt_column_spanner_outer:first-child { padding-left: 0; } #yivmmdvpqx .gt_column_spanner_outer:last-child { padding-right: 0; } #yivmmdvpqx .gt_column_spanner { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 5px; overflow-x: hidden; display: inline-block; width: 100%; } #yivmmdvpqx .gt_spanner_row { border-bottom-style: hidden; } #yivmmdvpqx .gt_group_heading { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; text-align: left; } #yivmmdvpqx .gt_empty_group_heading { padding: 0.5px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: middle; } #yivmmdvpqx .gt_from_md > :first-child { margin-top: 0; } #yivmmdvpqx .gt_from_md > :last-child { margin-bottom: 0; } #yivmmdvpqx .gt_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; margin: 10px; border-top-style: solid; border-top-width: 1px; border-top-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; overflow-x: hidden; } #yivmmdvpqx .gt_stub { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-right-style: solid; border-right-width: 2px; border-right-color: #D3D3D3; padding-left: 5px; padding-right: 5px; } #yivmmdvpqx .gt_stub_row_group { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-right-style: solid; border-right-width: 2px; border-right-color: #D3D3D3; padding-left: 5px; padding-right: 5px; vertical-align: top; } #yivmmdvpqx .gt_row_group_first td { border-top-width: 2px; } #yivmmdvpqx .gt_row_group_first th { border-top-width: 2px; } #yivmmdvpqx .gt_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #yivmmdvpqx .gt_first_summary_row { border-top-style: solid; border-top-color: #D3D3D3; } #yivmmdvpqx .gt_first_summary_row.thick { border-top-width: 2px; } #yivmmdvpqx .gt_last_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #yivmmdvpqx .gt_grand_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #yivmmdvpqx .gt_first_grand_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-top-style: double; border-top-width: 6px; border-top-color: #D3D3D3; } #yivmmdvpqx .gt_last_grand_summary_row_top { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-bottom-style: double; border-bottom-width: 6px; border-bottom-color: #D3D3D3; } #yivmmdvpqx .gt_striped { background-color: rgba(128, 128, 128, 0.05); } #yivmmdvpqx .gt_table_body { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #yivmmdvpqx .gt_footnotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #yivmmdvpqx .gt_footnote { margin: 0px; font-size: 90%; padding-top: 4px; padding-bottom: 4px; padding-left: 5px; padding-right: 5px; } #yivmmdvpqx .gt_sourcenotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #yivmmdvpqx .gt_sourcenote { font-size: 90%; padding-top: 4px; padding-bottom: 4px; padding-left: 5px; padding-right: 5px; } #yivmmdvpqx .gt_left { text-align: left; } #yivmmdvpqx .gt_center { text-align: center; } #yivmmdvpqx .gt_right { text-align: right; font-variant-numeric: tabular-nums; } #yivmmdvpqx .gt_font_normal { font-weight: normal; } #yivmmdvpqx .gt_font_bold { font-weight: bold; } #yivmmdvpqx .gt_font_italic { font-style: italic; } #yivmmdvpqx .gt_super { font-size: 65%; } #yivmmdvpqx .gt_footnote_marks { font-size: 75%; vertical-align: 0.4em; position: initial; } #yivmmdvpqx .gt_asterisk { font-size: 100%; vertical-align: 0; } #yivmmdvpqx .gt_indent_1 { text-indent: 5px; } #yivmmdvpqx .gt_indent_2 { text-indent: 10px; } #yivmmdvpqx .gt_indent_3 { text-indent: 15px; } #yivmmdvpqx .gt_indent_4 { text-indent: 20px; } #yivmmdvpqx .gt_indent_5 { text-indent: 25px; } TABLE 9.5: Rate and standard error of violent victimization, by type of crime and demographic characteristics, 2021 Victim demographic Violent crime1 Aggravated assault Rate SE Rate SE Sex Female 15.5 0.9 2.3 0.2 Male 17.5 1.1 3.2 0.3 Race/Hispanic origin White2 16.1 0.9 2.7 0.3 Black2 18.5 2.2 3.7 0.7 Hispanic 15.9 1.7 2.3 0.4 Asian2 8.6 1.3 1.9 0.6 Native Hawaiian or Other Pacific Islander2,3 36.1 34.4 0.0 0.0 Other2,4 45.4 13.0 6.2 2.0 Age 12-17 13.2 2.2 2.5 0.8 18-24 23.1 2.1 3.9 0.9 25-34 22.0 2.1 4.0 0.6 35-49 19.4 1.6 3.6 0.5 50-64 16.9 1.9 2.0 0.3 65 or older 6.4 1.1 1.1 0.3 Marital status Never married 22.2 1.4 4.0 0.4 Married 9.5 0.9 1.5 0.2 Widowed 10.7 3.5 0.9 0.2 Divorced 27.4 2.9 4.0 0.7 Separated 36.8 6.7 8.8 3.1 Income Less than $25,000 29.6 2.5 5.1 0.7 $25,000-49,999 16.9 1.5 3.0 0.4 $50,000-99,999 14.6 1.1 1.9 0.3 $100,000-199,999 12.2 1.3 2.5 0.4 $200,000 or more 9.7 1.4 1.7 0.6 Note: Rates per 1,000 persons age 12 or older. Source: Bureau of Justice Statistics, National Crime Victimization Survey, 2021. 1 Includes rape or sexual assault, robbery, aggravated assault, and simple assault. 2 Excludes persons of Hispanic origin 3 Includes persons who identified as Native Hawaiian or Other Pacific Islander only. 4 Includes persons who identified as American Indian or Alaska Native only or as two or more races. 9.6.4 Estimation 4: Prevalence Rates Prevalence rates differ from victimization rates as the numerator is the number of people or households victimized rather than the number of victimizations. To calculate the prevalence rates, we must run another summary of the data by calculating an indicator for whether a person or household is a victim of a particular crime at any point in the year. Below is an example of calculating first the indicator and then the prevalence rate of violent crime and aggravated assault. pers_prev_des &lt;- pers_vsum_slim %&gt;% mutate(Year = floor(YEARQ)) %&gt;% mutate(Violent_Ind = sum(Violent) &gt; 0, AAST_Ind = sum(AAST) &gt; 0, .by = c(&quot;Year&quot;, &quot;IDHH&quot;, &quot;IDPER&quot;)) %&gt;% as_survey(weight = WGTPERCY, strata = V2117, ids = V2118, nest = TRUE) pers_prev_ests &lt;- pers_prev_des %&gt;% summarize(Violent_Prev = survey_mean(Violent_Ind * 100), AAST_Prev = survey_mean(AAST_Ind * 100)) pers_prev_ests ## # A tibble: 1 × 4 ## Violent_Prev Violent_Prev_se AAST_Prev AAST_Prev_se ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 0.980 0.0349 0.215 0.0143 In the example above, the indicator is multiplied by 100 to return a percentage rather than a proportion. In 2021, we estimate that 0.98% of people aged 12 and older were a victim of violent crime in the United States, and 0.22% were victims of aggravated assault. 9.7 Exercises What proportion of completed motor vehicle thefts are not reported to the police? Hint: Use the codebook to look at the definition of Type of Crime (V4529). ans1 &lt;- inc_des %&gt;% filter(str_detect(V4529, &quot;40|41&quot;)) %&gt;% summarize(Pct = survey_mean(ReportPolice, na.rm = TRUE) * 100) ans1 ## # A tibble: 1 × 2 ## Pct Pct_se ## &lt;dbl&gt; &lt;dbl&gt; ## 1 76.9 2.60 How many violent crimes occur in each region? inc_des %&gt;% filter(Violent) %&gt;% survey_count(Region) ## # A tibble: 4 × 3 ## Region n n_se ## &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Northeast 698406. 82419. ## 2 Midwest 1144407. 95860. ## 3 South 1394214. 107505. ## 4 West 1361278. 109479. What is the property victimization rate among each income level? hh_des %&gt;% group_by(Income) %&gt;% summarize(Property_Rate = survey_mean(Property * ADJINC_WT * 1000, na.rm = TRUE)) ## # A tibble: 6 × 3 ## Income Property_Rate Property_Rate_se ## &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Less than $25,000 111. 4.97 ## 2 $25,000-49,999 89.5 3.42 ## 3 $50,000-99,999 87.8 3.30 ## 4 $100,000-199,999 76.5 3.49 ## 5 $200,000 or more 91.8 5.69 ## 6 &lt;NA&gt; NaN NaN References "],["c10-ambarom-vignette.html", "Chapter 10 AmericasBarometer Vignette 10.1 Introduction 10.2 Data Structure 10.3 Preparing files 10.4 Survey design objects 10.5 Calculating estimates and making tables 10.6 Mapping survey data 10.7 Exercises", " Chapter 10 AmericasBarometer Vignette Prerequisites For this chapter, here are the libraries and helper functions we will need: library(tidyverse) library(srvyr) library(sf) library(rnaturalearth) library(rnaturalearthdata) library(gt) library(ggpattern) In this vignette, we will be using data from the 2021 AmericasBarometer survey. Download the raw files yourself from the LAPOP website. This book uses version 1.2 of the data and each country has its own file for a total of 22 files. To read all files into R and ignore the Stata labels, we recommend running code like this: stata_files &lt;- list.files(here(&quot;RawData&quot;, &quot;LAPOP_2021&quot;), &quot;*.dta&quot;) read_stata_unlabeled &lt;- function(file) { read_stata(file) %&gt;% zap_labels() %&gt;% zap_label() } ambarom_in &lt;- here(&quot;RawData&quot;, &quot;LAPOP_2021&quot;, stata_files) %&gt;% map_df(read_stata_unlabeled) %&gt;% select(pais, strata, upm, weight1500, strata, core_a_core_b, q2, q1tb, covid2at, a4, idio2, idio2cov, it1, jc13, m1, mil10a, mil10e, ccch1, ccch3, ccus1, ccus3, edr, ocup4a, q14, q11n, q12c, q12bn, starts_with(&quot;covidedu1&quot;), gi0n, r15, r18n, r18) The code above will read all files of type .dta in and stack them into one tibble. We then selected a subset of variables for this vignette. 10.1 Introduction The AmericasBarometer surveys are conducted by the LAPOP Lab (LAPOP 2023b). These surveys are public opinion surveys of the Americas focused on democracy. The study was launched in 2004/2005 with 11 countries, with the countries growing and fluctuating over time, and creates a study with consistent methodology across many countries. In 2021, the study included 22 countries ranging from the north in Canada to the South in Chile and Argentina (LAPOP 2023a). Historically, surveys were administered with face-to-face household interviews, but the COVID-19 pandemic changed the study significantly to the use of random-digit dialing (RDD) of mobile phones in all countries except the United States and Canada (LAPOP 2021c). In Canada, LAPOP collaborated with the Environics Institute to collect data from a panel of Canadians using a web survey (LAPOP 2021a). While in the United States, YouGov conducted the survey on behalf of LAPOP by conducting a web survey among their panelists (LAPOP 2021b). The survey has a core set of questions across the countries, but not all questions are asked everywhere. Additionally, some questions are only asked to half of the respondents within a country, presumably to reduce the burden as different sections are randomized to different respondents (LAPOP 2021d). 10.2 Data Structure Each country and year has its own file available in Stata format (.dta). In this vignette, we downloaded and stacked all the data from all 22 participating countries in 2021. We subset the data to a smaller set of columns as noted in the prerequisites box for usage in the vignette. To understand variables that are used across the several countries, the core questionnaire is useful (LAPOP 2021d). 10.3 Preparing files Many of the variables are coded as numeric and do not have intuitive variable names, so the next step is to create derived variables and analysis-ready data. Using the core questionnaire as a codebook, derived variables are created below with relevant factors with informative names. ambarom &lt;- ambarom_in %&gt;% mutate(Country = factor(case_match(pais, 1 ~ &quot;Mexico&quot;, 2 ~ &quot;Guatemala&quot;, 3 ~ &quot;El Salvador&quot;, 4 ~ &quot;Honduras&quot;, 5 ~ &quot;Nicaragua&quot;, 6 ~ &quot;Costa Rica&quot;, 7 ~ &quot;Panama&quot;, 8 ~ &quot;Colombia&quot;, 9 ~ &quot;Ecuador&quot;, 10 ~ &quot;Bolivia&quot;, 11 ~ &quot;Peru&quot;, 12 ~ &quot;Paraguay&quot;, 13 ~ &quot;Chile&quot;, 14 ~ &quot;Uruguay&quot;, 15 ~ &quot;Brazil&quot;, 17 ~ &quot;Argentina&quot;, 21 ~ &quot;Dominican Republic&quot;, 22 ~ &quot;Haiti&quot;, 23 ~ &quot;Jamaica&quot;, 24 ~ &quot;Guyana&quot;, 40 ~ &quot;United States&quot;, 41 ~ &quot;Canada&quot;)), CovidWorry = fct_reorder(case_match(covid2at, 1 ~ &quot;Very worried&quot;, 2 ~ &quot;Somewhat worried&quot;, 3 ~ &quot;A little worried&quot;, 4 ~ &quot;Not worried at all&quot;), covid2at, .na_rm = FALSE)) %&gt;% rename(Educ_NotInSchool = covidedu1_1, Educ_NormalSchool = covidedu1_2, Educ_VirtualSchool = covidedu1_3, Educ_Hybrid = covidedu1_4, Educ_NoSchool = covidedu1_5, BroadbandInternet = r18n, Internet = r18) At this point, it is helpful to check the cross-tabs between the original variables and the newly derived variables. By outputting these tables, we can check to make sure that we have correctly aligned the numeric data from the original data to the factored data with informative labels in the new data. ambarom %&gt;% count(Country, pais) %&gt;% print(n = 22) ## # A tibble: 22 × 3 ## Country pais n ## &lt;fct&gt; &lt;dbl&gt; &lt;int&gt; ## 1 Argentina 17 3011 ## 2 Bolivia 10 3002 ## 3 Brazil 15 3016 ## 4 Canada 41 2201 ## 5 Chile 13 2954 ## 6 Colombia 8 2993 ## 7 Costa Rica 6 2977 ## 8 Dominican Republic 21 3000 ## 9 Ecuador 9 3005 ## 10 El Salvador 3 3245 ## 11 Guatemala 2 3000 ## 12 Guyana 24 3011 ## 13 Haiti 22 3088 ## 14 Honduras 4 2999 ## 15 Jamaica 23 3121 ## 16 Mexico 1 2998 ## 17 Nicaragua 5 2997 ## 18 Panama 7 3183 ## 19 Paraguay 12 3004 ## 20 Peru 11 3038 ## 21 United States 40 1500 ## 22 Uruguay 14 3009 ambarom %&gt;% count(CovidWorry, covid2at) ## # A tibble: 5 × 3 ## CovidWorry covid2at n ## &lt;fct&gt; &lt;dbl&gt; &lt;int&gt; ## 1 Very worried 1 24327 ## 2 Somewhat worried 2 13233 ## 3 A little worried 3 11478 ## 4 Not worried at all 4 8628 ## 5 &lt;NA&gt; NA 6686 10.4 Survey design objects The technical report is the best source to understand how to specify the sampling design in R (LAPOP 2021c). The data includes two weights: wt and weight1500. The first weight variable is country-specific and sums to the sample size but is calibrated to reflect each country’s demographics, while the second weight variable sums to 1500 for each country. The second weight is indicated as the weight to use for multi-country analyses. While the documentation does not directly state this, the example Stata syntax (svyset upm [pw=weight1500], strata(strata)) indicates the variable upm is a clustering variable, and strata is the strata variable. Therefore, the design object is setup in R as follows: ambarom_des &lt;- ambarom %&gt;% as_survey_design(ids = upm, strata = strata, weight = weight1500) One interesting thing to note is that these can only give us estimates to compare countries but not multi-country estimates since the weights do not account for different sizes of countries. For example, Canada has about 10% of the population of the United States, but an estimate that uses records from both countries would weigh them equally. 10.5 Calculating estimates and making tables This survey was administered in 2021 between March and August, varying by country37. Given the state of the pandemic at that time, several questions about COVID were included. The first question about COVID asked whether people were worried about the possibility that they or someone in their household will get sick from coronavirus in the next three months. We will calculate the percentage of people in each country who are very worried or somewhat worried. In the following code, we calculate estimate for each country and then create a table of the estimates for display using the {gt} package. covid_worry_country_ests &lt;- ambarom_des %&gt;% mutate(CovidWorry_bin = fct_collapse(CovidWorry, WorriedHi = c(&quot;Very worried&quot;, &quot;Somewhat worried&quot;), WorriedLo = c(&quot;A little worried&quot;, &quot;Not worried at all&quot;))) %&gt;% group_by(Country) %&gt;% summarize(p = survey_mean(CovidWorry_bin == &quot;WorriedHi&quot;, na.rm = TRUE) * 100) covid_worry_country_ests %&gt;% gt(rowname_col = &quot;Country&quot;) %&gt;% cols_label(p = &quot;Percent&quot;, p_se = &quot;SE&quot;) %&gt;% tab_caption(&quot;Proportion worried about the possibility that they or someone in their household will get sick from coronavirus in the next 3 months&quot;) %&gt;% fmt_number(decimals = 1) %&gt;% tab_source_note(&quot;AmericasBarometer Surveys, 2021&quot;) #wgfqvyyzfm table { font-family: system-ui, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Noto Color Emoji'; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; } #wgfqvyyzfm thead, #wgfqvyyzfm tbody, #wgfqvyyzfm tfoot, #wgfqvyyzfm tr, #wgfqvyyzfm td, #wgfqvyyzfm th { border-style: none; } #wgfqvyyzfm p { margin: 0; padding: 0; } #wgfqvyyzfm .gt_table { display: table; border-collapse: collapse; line-height: normal; margin-left: auto; margin-right: auto; color: #333333; font-size: 16px; font-weight: normal; font-style: normal; background-color: #FFFFFF; width: auto; border-top-style: solid; border-top-width: 2px; border-top-color: #A8A8A8; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #A8A8A8; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; } #wgfqvyyzfm .gt_caption { padding-top: 4px; padding-bottom: 4px; } #wgfqvyyzfm .gt_title { color: #333333; font-size: 125%; font-weight: initial; padding-top: 4px; padding-bottom: 4px; padding-left: 5px; padding-right: 5px; border-bottom-color: #FFFFFF; border-bottom-width: 0; } #wgfqvyyzfm .gt_subtitle { color: #333333; font-size: 85%; font-weight: initial; padding-top: 3px; padding-bottom: 5px; padding-left: 5px; padding-right: 5px; border-top-color: #FFFFFF; border-top-width: 0; } #wgfqvyyzfm .gt_heading { background-color: #FFFFFF; text-align: center; border-bottom-color: #FFFFFF; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #wgfqvyyzfm .gt_bottom_border { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #wgfqvyyzfm .gt_col_headings { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #wgfqvyyzfm .gt_col_heading { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 6px; padding-left: 5px; padding-right: 5px; overflow-x: hidden; } #wgfqvyyzfm .gt_column_spanner_outer { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; padding-top: 0; padding-bottom: 0; padding-left: 4px; padding-right: 4px; } #wgfqvyyzfm .gt_column_spanner_outer:first-child { padding-left: 0; } #wgfqvyyzfm .gt_column_spanner_outer:last-child { padding-right: 0; } #wgfqvyyzfm .gt_column_spanner { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 5px; overflow-x: hidden; display: inline-block; width: 100%; } #wgfqvyyzfm .gt_spanner_row { border-bottom-style: hidden; } #wgfqvyyzfm .gt_group_heading { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; text-align: left; } #wgfqvyyzfm .gt_empty_group_heading { padding: 0.5px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: middle; } #wgfqvyyzfm .gt_from_md > :first-child { margin-top: 0; } #wgfqvyyzfm .gt_from_md > :last-child { margin-bottom: 0; } #wgfqvyyzfm .gt_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; margin: 10px; border-top-style: solid; border-top-width: 1px; border-top-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; overflow-x: hidden; } #wgfqvyyzfm .gt_stub { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-right-style: solid; border-right-width: 2px; border-right-color: #D3D3D3; padding-left: 5px; padding-right: 5px; } #wgfqvyyzfm .gt_stub_row_group { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-right-style: solid; border-right-width: 2px; border-right-color: #D3D3D3; padding-left: 5px; padding-right: 5px; vertical-align: top; } #wgfqvyyzfm .gt_row_group_first td { border-top-width: 2px; } #wgfqvyyzfm .gt_row_group_first th { border-top-width: 2px; } #wgfqvyyzfm .gt_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #wgfqvyyzfm .gt_first_summary_row { border-top-style: solid; border-top-color: #D3D3D3; } #wgfqvyyzfm .gt_first_summary_row.thick { border-top-width: 2px; } #wgfqvyyzfm .gt_last_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #wgfqvyyzfm .gt_grand_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #wgfqvyyzfm .gt_first_grand_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-top-style: double; border-top-width: 6px; border-top-color: #D3D3D3; } #wgfqvyyzfm .gt_last_grand_summary_row_top { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-bottom-style: double; border-bottom-width: 6px; border-bottom-color: #D3D3D3; } #wgfqvyyzfm .gt_striped { background-color: rgba(128, 128, 128, 0.05); } #wgfqvyyzfm .gt_table_body { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #wgfqvyyzfm .gt_footnotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #wgfqvyyzfm .gt_footnote { margin: 0px; font-size: 90%; padding-top: 4px; padding-bottom: 4px; padding-left: 5px; padding-right: 5px; } #wgfqvyyzfm .gt_sourcenotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #wgfqvyyzfm .gt_sourcenote { font-size: 90%; padding-top: 4px; padding-bottom: 4px; padding-left: 5px; padding-right: 5px; } #wgfqvyyzfm .gt_left { text-align: left; } #wgfqvyyzfm .gt_center { text-align: center; } #wgfqvyyzfm .gt_right { text-align: right; font-variant-numeric: tabular-nums; } #wgfqvyyzfm .gt_font_normal { font-weight: normal; } #wgfqvyyzfm .gt_font_bold { font-weight: bold; } #wgfqvyyzfm .gt_font_italic { font-style: italic; } #wgfqvyyzfm .gt_super { font-size: 65%; } #wgfqvyyzfm .gt_footnote_marks { font-size: 75%; vertical-align: 0.4em; position: initial; } #wgfqvyyzfm .gt_asterisk { font-size: 100%; vertical-align: 0; } #wgfqvyyzfm .gt_indent_1 { text-indent: 5px; } #wgfqvyyzfm .gt_indent_2 { text-indent: 10px; } #wgfqvyyzfm .gt_indent_3 { text-indent: 15px; } #wgfqvyyzfm .gt_indent_4 { text-indent: 20px; } #wgfqvyyzfm .gt_indent_5 { text-indent: 25px; } TABLE 10.1: Proportion worried about the possibility that they or someone in their household will get sick from coronavirus in the next 3 months Percent SE Argentina 65.8 1.1 Bolivia 71.6 1.0 Brazil 83.5 1.0 Canada 48.9 1.3 Chile 81.8 0.8 Colombia 67.9 1.1 Costa Rica 72.6 1.0 Dominican Republic 50.1 1.1 Ecuador 71.7 1.0 El Salvador 52.5 1.0 Guatemala 69.3 1.0 Guyana 60.0 1.6 Haiti 54.4 1.8 Honduras 64.6 1.1 Jamaica 28.4 0.9 Mexico 63.6 1.0 Nicaragua 80.0 1.0 Panama 70.2 1.0 Paraguay 61.5 1.1 Peru 77.1 2.5 United States 46.6 1.7 Uruguay 60.9 1.1 AmericasBarometer Surveys, 2021 Another question asked how education was affected by the pandemic. This question was asked among households with children under the age of 13, and respondents could select more than one option as follows: Did any of these children have their school education affected due to the pandemic?   - No, because they are not yet school age or because they do not attend school for another reason   - No, their classes continued normally   - Yes, they went to virtual or remote classes   - Yes, they switched to a combination of virtual and in-person classes   - Yes, they cut all ties with the school Multiple-choice questions are interesting. If we want to look at how education was impacted only among those in school, we need to filter to the relevant responses, which is anyone that responded no to the first part. The variable Educ_NotInSchool in the dataset has values of 0 and 1. A value of 1 means that the respondent selected the first option in the question (none of the children are in school) and a value of 0 means that at least one of their children are in school. Using this variable, we can filter the data to only those with a value of 0. There are three additional variables that we can look at that correlate to the second option (Educ_NormalSchool), third option (Educ_VirtualSchool), and fourth option (Educ_Hybrid). An unweighted cross-tab for the responses is included below, and we can see there is a wide-range of impacts and that many combinations of effects on education are possible. ambarom %&gt;% filter(Educ_NotInSchool == 0) %&gt;% distinct(Educ_NormalSchool, Educ_VirtualSchool, Educ_Hybrid) %&gt;% print(n = 50) ## # A tibble: 8 × 3 ## Educ_NormalSchool Educ_VirtualSchool Educ_Hybrid ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 0 1 0 ## 2 1 0 1 ## 3 0 0 1 ## 4 0 1 1 ## 5 0 0 0 ## 6 1 0 0 ## 7 1 1 1 ## 8 1 1 0 We might create multiple outcomes for a table as follows: Indicator that school continued as normal with no virtual or hybrid option Indicator that the education medium was changed - either virtual or hybrid In this next code chunk, we create these indicators, make national estimates, and display a summary table of the data. ambarom_des_educ &lt;- ambarom_des %&gt;% filter(Educ_NotInSchool == 0) %&gt;% mutate(Educ_OnlyNormal = (Educ_NormalSchool == 1 &amp; Educ_VirtualSchool == 0 &amp; Educ_Hybrid == 0), Educ_MediumChange = (Educ_VirtualSchool == 1 | Educ_Hybrid == 1)) covid_educ_ests &lt;- ambarom_des_educ %&gt;% group_by(Country) %&gt;% summarize(p_onlynormal = survey_mean(Educ_OnlyNormal, na.rm = TRUE) * 100, p_mediumchange = survey_mean(Educ_MediumChange, na.rm = TRUE) * 100, p_noschool = survey_mean(Educ_NoSchool, na.rm = TRUE) * 100, ) covid_educ_ests %&gt;% gt(rowname_col = &quot;Country&quot;) %&gt;% cols_label(p_onlynormal = &quot;%&quot;, p_onlynormal_se = &quot;SE&quot;, p_mediumchange = &quot;%&quot;, p_mediumchange_se = &quot;SE&quot;, p_noschool = &quot;%&quot;, p_noschool_se = &quot;SE&quot;) %&gt;% tab_spanner(label = &quot;Normal school only&quot;, columns = c(&quot;p_onlynormal&quot;, &quot;p_onlynormal_se&quot;)) %&gt;% tab_spanner(label = &quot;Medium change&quot;, columns = c(&quot;p_mediumchange&quot;, &quot;p_mediumchange_se&quot;)) %&gt;% tab_spanner(label = &quot;Cut ties with school&quot;, columns = c(&quot;p_noschool&quot;, &quot;p_noschool_se&quot;)) %&gt;% fmt_number(decimals = 1) %&gt;% tab_caption(&quot;Impact on education in households with children under the age of 13 who had children that would generally attend school.&quot;) %&gt;% tab_source_note(&quot;AmericasBarometer Surveys, 2021&quot;) #iglyrmoepn table { font-family: system-ui, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Noto Color Emoji'; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; } #iglyrmoepn thead, #iglyrmoepn tbody, #iglyrmoepn tfoot, #iglyrmoepn tr, #iglyrmoepn td, #iglyrmoepn th { border-style: none; } #iglyrmoepn p { margin: 0; padding: 0; } #iglyrmoepn .gt_table { display: table; border-collapse: collapse; line-height: normal; margin-left: auto; margin-right: auto; color: #333333; font-size: 16px; font-weight: normal; font-style: normal; background-color: #FFFFFF; width: auto; border-top-style: solid; border-top-width: 2px; border-top-color: #A8A8A8; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #A8A8A8; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; } #iglyrmoepn .gt_caption { padding-top: 4px; padding-bottom: 4px; } #iglyrmoepn .gt_title { color: #333333; font-size: 125%; font-weight: initial; padding-top: 4px; padding-bottom: 4px; padding-left: 5px; padding-right: 5px; border-bottom-color: #FFFFFF; border-bottom-width: 0; } #iglyrmoepn .gt_subtitle { color: #333333; font-size: 85%; font-weight: initial; padding-top: 3px; padding-bottom: 5px; padding-left: 5px; padding-right: 5px; border-top-color: #FFFFFF; border-top-width: 0; } #iglyrmoepn .gt_heading { background-color: #FFFFFF; text-align: center; border-bottom-color: #FFFFFF; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #iglyrmoepn .gt_bottom_border { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #iglyrmoepn .gt_col_headings { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #iglyrmoepn .gt_col_heading { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 6px; padding-left: 5px; padding-right: 5px; overflow-x: hidden; } #iglyrmoepn .gt_column_spanner_outer { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; padding-top: 0; padding-bottom: 0; padding-left: 4px; padding-right: 4px; } #iglyrmoepn .gt_column_spanner_outer:first-child { padding-left: 0; } #iglyrmoepn .gt_column_spanner_outer:last-child { padding-right: 0; } #iglyrmoepn .gt_column_spanner { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 5px; overflow-x: hidden; display: inline-block; width: 100%; } #iglyrmoepn .gt_spanner_row { border-bottom-style: hidden; } #iglyrmoepn .gt_group_heading { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; text-align: left; } #iglyrmoepn .gt_empty_group_heading { padding: 0.5px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: middle; } #iglyrmoepn .gt_from_md > :first-child { margin-top: 0; } #iglyrmoepn .gt_from_md > :last-child { margin-bottom: 0; } #iglyrmoepn .gt_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; margin: 10px; border-top-style: solid; border-top-width: 1px; border-top-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; overflow-x: hidden; } #iglyrmoepn .gt_stub { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-right-style: solid; border-right-width: 2px; border-right-color: #D3D3D3; padding-left: 5px; padding-right: 5px; } #iglyrmoepn .gt_stub_row_group { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-right-style: solid; border-right-width: 2px; border-right-color: #D3D3D3; padding-left: 5px; padding-right: 5px; vertical-align: top; } #iglyrmoepn .gt_row_group_first td { border-top-width: 2px; } #iglyrmoepn .gt_row_group_first th { border-top-width: 2px; } #iglyrmoepn .gt_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #iglyrmoepn .gt_first_summary_row { border-top-style: solid; border-top-color: #D3D3D3; } #iglyrmoepn .gt_first_summary_row.thick { border-top-width: 2px; } #iglyrmoepn .gt_last_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #iglyrmoepn .gt_grand_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #iglyrmoepn .gt_first_grand_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-top-style: double; border-top-width: 6px; border-top-color: #D3D3D3; } #iglyrmoepn .gt_last_grand_summary_row_top { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-bottom-style: double; border-bottom-width: 6px; border-bottom-color: #D3D3D3; } #iglyrmoepn .gt_striped { background-color: rgba(128, 128, 128, 0.05); } #iglyrmoepn .gt_table_body { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #iglyrmoepn .gt_footnotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #iglyrmoepn .gt_footnote { margin: 0px; font-size: 90%; padding-top: 4px; padding-bottom: 4px; padding-left: 5px; padding-right: 5px; } #iglyrmoepn .gt_sourcenotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #iglyrmoepn .gt_sourcenote { font-size: 90%; padding-top: 4px; padding-bottom: 4px; padding-left: 5px; padding-right: 5px; } #iglyrmoepn .gt_left { text-align: left; } #iglyrmoepn .gt_center { text-align: center; } #iglyrmoepn .gt_right { text-align: right; font-variant-numeric: tabular-nums; } #iglyrmoepn .gt_font_normal { font-weight: normal; } #iglyrmoepn .gt_font_bold { font-weight: bold; } #iglyrmoepn .gt_font_italic { font-style: italic; } #iglyrmoepn .gt_super { font-size: 65%; } #iglyrmoepn .gt_footnote_marks { font-size: 75%; vertical-align: 0.4em; position: initial; } #iglyrmoepn .gt_asterisk { font-size: 100%; vertical-align: 0; } #iglyrmoepn .gt_indent_1 { text-indent: 5px; } #iglyrmoepn .gt_indent_2 { text-indent: 10px; } #iglyrmoepn .gt_indent_3 { text-indent: 15px; } #iglyrmoepn .gt_indent_4 { text-indent: 20px; } #iglyrmoepn .gt_indent_5 { text-indent: 25px; } TABLE 10.2: Impact on education in households with children under the age of 13 who had children that would generally attend school. Normal school only Medium change Cut ties with school % SE % SE % SE Argentina 5.4 1.1 87.1 1.7 9.9 1.6 Brazil 4.3 1.2 81.5 2.3 22.1 2.5 Chile 0.7 0.3 96.2 1.0 4.0 1.0 Colombia 2.8 0.7 90.3 1.4 7.5 1.3 Dominican Republic 3.8 0.8 87.4 1.5 10.5 1.4 Ecuador 5.2 1.0 87.5 1.4 7.9 1.1 El Salvador 2.9 0.7 85.8 1.5 11.8 1.4 Guatemala 3.0 0.7 82.2 1.7 17.7 1.8 Guyana 3.3 0.7 85.3 1.7 13.0 1.6 Haiti 81.1 2.3 7.2 1.5 11.7 1.8 Honduras 3.7 0.9 80.7 1.7 16.9 1.6 Jamaica 5.4 0.9 88.1 1.4 7.5 1.2 Panama 7.2 1.2 89.4 1.4 3.8 0.9 Paraguay 4.7 0.9 90.7 1.4 6.4 1.2 Peru 2.0 0.6 91.8 1.2 6.8 1.1 Uruguay 8.6 1.4 84.3 2.0 8.0 1.6 AmericasBarometer Surveys, 2021 Of the countries that used this question, many had households where their children had an education medium change, except Haiti, where only 7.2% of households with students changed to virtual or hybrid learning. 10.6 Mapping survey data While the table presents the data well, a map could also be used. To obtain maps of the countries, the package {rnaturalearth} is used, subsetting North and South America using the function ne_countries(). This returns an sf object with many columns but, most importantly soverignt (sovereignty), geounit (country or territory), and geometry (the shape). As an example of the difference between soverignty and country/territory, the United States, Puerto Rico, and the US Virgin Islands are all separate units with the same sovereignty. This map (without data) is plotted in Figure 10.1. country_shape &lt;- ne_countries(scale = &quot;medium&quot;, returnclass = &quot;sf&quot;, continent = c(&quot;North America&quot;, &quot;South America&quot;)) country_shape %&gt;% ggplot() + geom_sf() FIGURE 10.1: Map of North and South America This map in Figure 10.1 is very wide as the Aleutian islands in Alaska extend into the Eastern Hemisphere. We can crop the shape file to only the Western Hemisphere to remove some of the trailing islands of Alaska. country_shape_crop &lt;- country_shape %&gt;% st_crop(c(xmin = -180, xmax = 0, ymin = -90, ymax = 90)) Now that we have the shape files we need, our next step is to match our survey data to the map. Countries can be called by different names (e.g., “U.S”, “U.S.A”, “United States”). To make sure we can plot our survey data on the map, we will need to make sure the country in both datasets match. To do this, we can use the anti_join() function and check to see what countries are in the survey data but not in the map data. As shown below, the United States is referred to as “United States” in the survey data but “United States of America” in the map data. The code below shows countries in the survey but not the map data. survey_country_list &lt;- ambarom %&gt;% distinct(Country) survey_country_list %&gt;% anti_join(country_shape_crop, by = c(Country = &quot;geounit&quot;)) ## # A tibble: 1 × 1 ## Country ## &lt;fct&gt; ## 1 United States The code below shows countries in the map data but not hte survey data. country_shape_crop %&gt;% as_tibble() %&gt;% select(geounit, sovereignt) %&gt;% anti_join(survey_country_list, by = c(geounit = &quot;Country&quot;)) %&gt;% arrange(geounit) %&gt;% print(n = 30) ## # A tibble: 30 × 2 ## geounit sovereignt ## &lt;chr&gt; &lt;chr&gt; ## 1 Anguilla United Kingdom ## 2 Antigua and Barbuda Antigua and Barbuda ## 3 Aruba Netherlands ## 4 Barbados Barbados ## 5 Belize Belize ## 6 Bermuda United Kingdom ## 7 British Virgin Islands United Kingdom ## 8 Cayman Islands United Kingdom ## 9 Cuba Cuba ## 10 Curaçao Netherlands ## 11 Dominica Dominica ## 12 Falkland Islands United Kingdom ## 13 Greenland Denmark ## 14 Grenada Grenada ## 15 Montserrat United Kingdom ## 16 Puerto Rico United States of America ## 17 Saint Barthelemy France ## 18 Saint Kitts and Nevis Saint Kitts and Nevis ## 19 Saint Lucia Saint Lucia ## 20 Saint Martin France ## 21 Saint Pierre and Miquelon France ## 22 Saint Vincent and the Grenadines Saint Vincent and the Grenadines ## 23 Sint Maarten Netherlands ## 24 Suriname Suriname ## 25 The Bahamas The Bahamas ## 26 Trinidad and Tobago Trinidad and Tobago ## 27 Turks and Caicos Islands United Kingdom ## 28 United States Virgin Islands United States of America ## 29 United States of America United States of America ## 30 Venezuela Venezuela With the mismatched names, there are several ways to remedy the data to join later. The most straightforward fix is to rename the shape object’s data before merging. We then can plot the survey estimates after merging the data. country_shape_upd &lt;- country_shape_crop %&gt;% mutate(geounit = if_else(geounit == &quot;United States of America&quot;, &quot;United States&quot;, geounit)) To merge the data and make a map, we begin with the map file, merge the estimates data, and then plot. Let’s use the outcomes we created in section 10.5 for the table output (covid_worry_country_ests and covid_educ_ests). Figures 10.2 and 10.3 display the maps for each measure. covid_sf &lt;- country_shape_upd %&gt;% full_join(covid_worry_country_ests, by = c(geounit = &quot;Country&quot;)) %&gt;% full_join(covid_educ_ests, by = c(geounit = &quot;Country&quot;)) ggplot() + geom_sf(data = covid_sf, aes(fill = p, geometry = geometry)) + scale_fill_gradientn(guide = &quot;colorbar&quot;, name = &quot;Percent&quot;, labels = scales::comma, colors = c(&quot;#BFD7EA&quot;, &quot;#087E8B&quot;, &quot;#0B3954&quot;), na.value = NA) + geom_sf_pattern(data = filter(covid_sf, is.na(p)), pattern = &quot;crosshatch&quot;, pattern_fill = &quot;black&quot;, fill = NA) + theme_minimal() FIGURE 10.2: Percent of people worried someone in their household will get COVID-19 in the next 3 months by country ggplot() + geom_sf(data = covid_sf, aes(fill = p_mediumchange, geometry = geometry)) + scale_fill_gradientn(guide = &quot;colorbar&quot;, name = &quot;Percent&quot;, labels = scales::comma, colors = c(&quot;#BFD7EA&quot;, &quot;#087E8B&quot;, &quot;#0B3954&quot;), na.value = NA) + geom_sf_pattern(data = filter(covid_sf, is.na(p_mediumchange)), pattern = &quot;crosshatch&quot;, pattern_fill = &quot;black&quot;, fill = NA) + theme_minimal() FIGURE 10.3: Percent of students who participated in virtual or hybrid learning In Figure 10.3 we can see that Canada, Mexico, and the United States have missing data (the crosshatch pattern). Reviewing the questionnaires indicate that these three countries did not include the education question in the survey. To better see the differences in the data, it may make sense to remove North America from the map and focus on Central and South America. This is done below by restricting the shape files to Latin America and the Caribbean as seen in Figure 10.4 covid_c_s &lt;- covid_sf %&gt;% filter(region_wb == &quot;Latin America &amp; Caribbean&quot;) ggplot() + geom_sf(data = covid_c_s, aes(fill = p_mediumchange, geometry = geometry)) + scale_fill_gradientn(guide = &quot;colorbar&quot;, name = &quot;Percent&quot;, labels = scales::comma, colors = c(&quot;#BFD7EA&quot;, &quot;#087E8B&quot;, &quot;#0B3954&quot;), na.value = NA) + geom_sf_pattern(data = filter(covid_c_s, is.na(p_mediumchange)), pattern = &quot;crosshatch&quot;, pattern_fill = &quot;black&quot;, fill = NA) + theme_minimal() FIGURE 10.4: Percent of students who participated in virtual or hybrid learning, Central and South America 10.7 Exercises Calculate the percentage of households with broadband internet and those with any internet at home, including from phone or tablet. Hint: if you see countries with 0% Internet usage, you may want to filter by something first. int_ests &lt;- ambarom_des %&gt;% filter(!is.na(Internet) | !is.na(BroadbandInternet)) %&gt;% group_by(Country) %&gt;% summarize(p_broadband = survey_mean(BroadbandInternet, na.rm = TRUE) * 100, p_internet = survey_mean(Internet, na.rm = TRUE) * 100) int_ests %&gt;% print(n = 30) ## # A tibble: 20 × 5 ## Country p_broadband p_broadband_se p_internet p_internet_se ## &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Argentina 62.3 1.13 86.2 0.871 ## 2 Bolivia 41.4 1.03 77.2 0.956 ## 3 Brazil 68.3 1.25 88.9 0.879 ## 4 Chile 63.1 1.06 93.5 0.550 ## 5 Colombia 45.7 1.15 68.7 1.09 ## 6 Costa Rica 49.6 1.07 84.4 0.798 ## 7 Dominican Republ… 37.1 1.04 73.7 1.05 ## 8 Ecuador 59.7 1.06 79.9 0.898 ## 9 El Salvador 30.2 0.906 63.9 0.985 ## 10 Guatemala 33.4 0.993 61.5 1.08 ## 11 Guyana 63.7 1.09 86.8 0.781 ## 12 Haiti 11.8 0.791 58.5 1.25 ## 13 Honduras 28.2 0.968 60.7 1.11 ## 14 Jamaica 64.2 0.986 91.5 0.602 ## 15 Mexico 44.9 1.05 70.9 1.05 ## 16 Nicaragua 39.1 1.12 76.3 1.09 ## 17 Panama 43.4 1.02 73.1 0.976 ## 18 Paraguay 33.3 0.971 72.9 1.01 ## 19 Peru 42.4 1.07 71.1 1.07 ## 20 Uruguay 62.7 1.08 90.6 0.699 Make a faceted map showing both broadband internet and any internet usage. internet_sf &lt;- country_shape_upd %&gt;% full_join(select(int_ests, p = p_internet, geounit = Country), by = &quot;geounit&quot;) %&gt;% mutate(Type = &quot;Internet&quot;) broadband_sf &lt;- country_shape_upd %&gt;% full_join(select(int_ests, p = p_broadband, geounit = Country), by = &quot;geounit&quot;) %&gt;% mutate(Type = &quot;Broadband&quot;) b_int_sf &lt;- internet_sf %&gt;% bind_rows(broadband_sf) %&gt;% filter(region_wb == &quot;Latin America &amp; Caribbean&quot;) b_int_sf %&gt;% ggplot(aes(fill = p)) + geom_sf() + facet_wrap(~Type) + scale_fill_gradientn(guide = &quot;colorbar&quot;, name = &quot;Percent&quot;, labels = scales::comma, colors = c(&quot;#BFD7EA&quot;, &quot;#087E8B&quot;, &quot;#0B3954&quot;), na.value = NA) + geom_sf_pattern(data = filter(b_int_sf, is.na(p)), pattern = &quot;crosshatch&quot;, pattern_fill = &quot;black&quot;, fill = NA) + theme_minimal() References "],["anes-cb.html", "A ANES Derived Variable Codebook A.1 Weighting variables A.2 Additional variables", " A ANES Derived Variable Codebook The full codebook with the original variables is available at https://electionstudies.org/wp-content/uploads/2022/02/anes_timeseries_2020_userguidecodebook_20220210.pdf A.1 Weighting variables V200010b Full sample post-election weight. V200010d Full sample variance stratum. V200010c Full sample variance unit. A.2 Additional variables InterviewMode MODE OF INTERVIEW: PRE-ELECTION INTERVIEW V200002 InterviewMode n Unweighted Freq 1 Video 274 0.037 2 Telephone 115 0.015 3 Web 7064 0.948 Total 7453 1.000 Variables used: V200002 Age RESPONDENT AGE AgeGroup n Unweighted Freq 18-29 871 0.117 30-39 1241 0.167 40-49 1081 0.145 50-59 1200 0.161 60-69 1436 0.193 70 or older 1330 0.178 NA 294 0.039 Total 7453 1.000 Variables used: V201507x Gender PRE: WHAT IS YOUR (R) SEX? [REVISED] What is your sex? V201600 Gender n Unweighted Freq -9 NA 51 0.007 1 Male 3375 0.453 2 Female 4027 0.540 Total 7453 1.000 Variables used: V201600 RaceEth PRE: SUMMARY: R SELF-IDENTIFIED RACE/ETHNICITY V201549x RaceEth n Unweighted Freq -9 NA 75 0.010 -8 NA 6 0.001 1 White 5420 0.727 2 Black 650 0.087 3 Hispanic 662 0.089 4 Asian, NH/PI 248 0.033 5 AI/AN 155 0.021 6 Other/multiple race 237 0.032 Total 7453 1.000 Variables used: V201549x PartyID PRE: SUMMARY: PARTY ID V201231x PartyID n Unweighted Freq -9 NA 23 0.003 -8 NA 2 0.000 1 Strong democrat 1796 0.241 2 Not very strong democrat 790 0.106 3 Independent-democrat 881 0.118 4 Independent 876 0.118 5 Independent-republican 782 0.105 6 Not very strong republican 758 0.102 7 Strong republican 1545 0.207 Total 7453 1.000 Variables used: V201231x Education What is the highest level of school you have completed or the highest degree you have received? V201510 Education n Unweighted Freq -9 NA 25 0.003 -8 NA 1 0.000 1 Less than HS 312 0.042 2 High school 1160 0.156 3 Post HS 1519 0.204 4 Post HS 550 0.074 5 Post HS 445 0.060 6 Bachelor’s 1877 0.252 7 Graduate 1092 0.147 8 Graduate 382 0.051 95 NA 90 0.012 Total 7453 1.000 Variables used: V201510 Income PRE: SUMMARY: TOTAL (FAMILY) INCOME V201617x Income n Unweighted Freq -9 NA 502 0.067 -5 NA 15 0.002 1 Under $9,999 647 0.087 2 $10,000-14,999 244 0.033 3 $15,000-19,999 185 0.025 4 $20,000-24,999 301 0.040 5 $25,000-29,999 228 0.031 6 $30,000-34,999 296 0.040 7 $35,000-39,999 226 0.030 8 $40,000-44,999 286 0.038 9 $45,000-49,999 213 0.029 10 $50,000-59,999 485 0.065 11 $60,000-64,999 294 0.039 12 $65,000-69,999 168 0.023 13 $70,000-74,999 243 0.033 14 $75,000-79,999 215 0.029 15 $80,000-89,999 383 0.051 16 $90,000-99,999 291 0.039 17 $100,000-109,999 451 0.061 18 $110,000-124,999 312 0.042 19 $125,000-149,999 323 0.043 20 $150,000-174,999 366 0.049 21 $175,000-249,999 374 0.050 22 $250,000 or more 405 0.054 Total 7453 1.000 V201617x Income7 n Unweighted Freq -9 NA 502 0.067 -5 NA 15 0.002 1 Under $20k 647 0.087 2 Under $20k 244 0.033 3 Under $20k 185 0.025 4 $20-40k 301 0.040 5 $20-40k 228 0.031 6 $20-40k 296 0.040 7 $20-40k 226 0.030 8 $40-60k 286 0.038 9 $40-60k 213 0.029 10 $40-60k 485 0.065 11 $60-80k 294 0.039 12 $60-80k 168 0.023 13 $60-80k 243 0.033 14 $60-80k 215 0.029 15 $80-100k 383 0.051 16 $80-100k 291 0.039 17 $100-125k 451 0.061 18 $100-125k 312 0.042 19 $125k or more 323 0.043 20 $125k or more 366 0.049 21 $125k or more 374 0.050 22 $125k or more 405 0.054 Total 7453 1.000 Variables used: V201617x CampaignInterest PRE: HOW INTERESTED IN FOLLOWING CAMPAIGNS Some people don’t pay much attention to political campaigns. How about you? Would you say that you have been very much interested, somewhat interested or not much interested in the political campaigns so far this year? V201006 CampaignInterest n Unweighted Freq -9 NA 1 0.000 1 Very much interested 3940 0.529 2 Somewhat interested 2569 0.345 3 Not much interested 943 0.127 Total 7453 1.000 Variables used: V201006 TrustGovernment PRE: HOW OFTEN TRUST GOVERNMENT IN WASHINGTON TO DO WHAT IS RIGHT [REVISED] How often can you trust the federal government in Washington to do what is right? V201233 TrustGovernment n Unweighted Freq -9 NA 26 0.003 -8 NA 3 0.000 1 Always 80 0.011 2 Most of the time 1016 0.136 3 About half the time 2313 0.310 4 Some of the time 3313 0.445 5 Never 702 0.094 Total 7453 1.000 Variables used: V201233 TrustPeople PRE: HOW OFTEN CAN PEOPLE BE TRUSTED Generally speaking, how often can you trust other people? V201237 TrustPeople n Unweighted Freq -9 NA 12 0.002 -8 NA 1 0.000 1 Always 48 0.006 2 Most of the time 3511 0.471 3 About half the time 2020 0.271 4 Some of the time 1597 0.214 5 Never 264 0.035 Total 7453 1.000 Variables used: V201237 VotedPres2016 PRE: DID R VOTE FOR PRESIDENT IN 2016 Four years ago, in 2016, Hillary Clinton ran on the Democratic ticket against Donald Trump for the Republicans. Do you remember for sure whether or not you voted in that election? Revised: Four years ago, in 2016, Hillary Clinton ran on the Democratic ticket against Donald Trump for the Republicans. We talk to many people who tell us they did not vote. And we talk to a few people who tell us they did vote, who really did not. We can tell they did not vote by checking with official government records. What about you? If we check the official government voter records, will they show that you voted in the 2016 presidential election, or that you did not vote in that election? V201101 V201102 VotedPres2016 n Unweighted Freq -9 -1 NA 13 0.002 -8 -1 NA 1 0.000 -1 -9 NA 6 0.001 -1 -8 NA 1 0.000 -1 1 Yes 3030 0.407 -1 2 No 743 0.100 1 -1 Yes 2780 0.373 2 -1 No 879 0.118 Total 7453 1.000 Variables used: V201101, V201102 VotedPres2016_selection PRE: RECALL OF LAST (2016) PRESIDENTIAL VOTE CHOICE Which one did you vote for? V201103 VotedPres2016_selection n Unweighted Freq -9 NA 41 0.006 -8 NA 2 0.000 -1 NA 1643 0.220 1 Clinton 2911 0.391 2 Trump 2466 0.331 5 Other 390 0.052 Total 7453 1.000 Variables used: V201103 VotedPres2020 PRE-POST: SUMMARY: VOTER TURNOUT IN 2020 V202109x VotedPres2020 n Unweighted Freq -2 NA 7 0.001 0 No 1039 0.139 1 Yes 6407 0.860 Total 7453 1.000 Variables used: V202109x VotedPres2020_selection POST: FOR WHOM DID R VOTE FOR PRESIDENT V202073 VotedPres2020_selection n Unweighted Freq -9 NA 53 0.007 -6 NA 4 0.001 -1 NA 1497 0.201 1 Biden 3267 0.438 2 Trump 2462 0.330 3 Other 69 0.009 4 Other 23 0.003 5 Other 56 0.008 7 Other 1 0.000 8 Other 3 0.000 11 NA 2 0.000 12 NA 16 0.002 Total 7453 1.000 Variables used: V202073 EarlyVote2020 / VotedPres2020 PRE: SUMMARY: REGISTRATION AND EARLY VOTE STATUS V201025x V202109x VotedPres2020 EarlyVote2020 n Unweighted Freq -4 1 Yes NA 1 0.000 1 -2 NA NA 3 0.000 1 0 No NA 301 0.040 1 1 Yes No 35 0.005 2 -2 NA NA 1 0.000 2 0 No NA 180 0.024 2 1 Yes No 109 0.015 3 -2 NA NA 3 0.000 3 0 No NA 558 0.075 3 1 Yes No 5891 0.790 4 1 Yes Yes 371 0.050 Total 7453 1.000 Variables used: V201025x, V202109x "],["recs-cb.html", "B RECS Derived Variable Codebook B.1 Weighting variables B.2 Categorical B.3 Continuous", " B RECS Derived Variable Codebook The full codebook with the original variables is available at https://www.eia.gov/consumption/residential/data/2015/index.php?view=microdata. B.1 Weighting variables DOEID Unique identifier for each respondent NWEIGHT Final sample weight BRRWT1-BRRWT96 Replicate weights B.2 Categorical Region Region n Unweighted Freq Northeast 794 0.140 Midwest 1327 0.233 South 2010 0.353 West 1555 0.273 Total 5686 1.000 Variables used: REGIONC Division Division n Unweighted Freq New England 253 0.044 Middle Atlantic 541 0.095 East North Central 836 0.147 West North Central 491 0.086 South Atlantic 1058 0.186 East South Central 372 0.065 West South Central 580 0.102 Mountain North 228 0.040 Mountain South 242 0.043 Pacific 1085 0.191 Total 5686 1.000 Variables used: DIVISION MSAStatus MSAStatus n Unweighted Freq Metropolitan Statistical Area 4745 0.835 Micropolitan Statistical Area 584 0.103 None 357 0.063 Total 5686 1.000 Variables used: METROMICRO Urbanicity Urbanicity n Unweighted Freq Urban Area 3928 0.691 Urban Cluster 598 0.105 Rural 1160 0.204 Total 5686 1.000 Variables used: UATYP10 HousingUnitType HousingUnitType n Unweighted Freq Mobile home 286 0.050 Single-family detached 3752 0.660 Single-family attached 479 0.084 Apartment: 2-4 Units 311 0.055 Apartment: 5 or more units 858 0.151 Total 5686 1.000 Variables used: TYPEHUQ YearMade YearMade n Unweighted Freq Before 1950 858 0.151 1950-1959 544 0.096 1960-1969 565 0.099 1970-1979 928 0.163 1980-1989 874 0.154 1990-1999 786 0.138 2000-2009 901 0.158 2010-2015 230 0.040 Total 5686 1.000 Variables used: YEARMADERANGE SpaceHeatingUsed SpaceHeatingUsed n Unweighted Freq FALSE 258 0.045 TRUE 5428 0.955 Total 5686 1.000 Variables used: HEATHOME HeatingBehavior HeatingBehavior n Unweighted Freq Set one temp and leave it 2156 0.379 Manually adjust at night/no one home 1414 0.249 Program thermostat to change at certain times 972 0.171 Turn on or off as needed 761 0.134 No control 114 0.020 Other 11 0.002 NA 258 0.045 Total 5686 1.000 Variables used: EQUIPMUSE ACUsed ACUsed n Unweighted Freq FALSE 737 0.13 TRUE 4949 0.87 Total 5686 1.00 Variables used: AIRCOND ACBehavior ACBehavior n Unweighted Freq Set one temp and leave it 1661 0.292 Manually adjust at night/no one home 984 0.173 Program thermostat to change at certain times 727 0.128 Turn on or off as needed 438 0.077 No control 2 0.000 NA 1874 0.330 Total 5686 1.000 Variables used: USECENAC ClimateRegion_BA ClimateRegion_BA n Unweighted Freq Hot-Dry/Mixed-Dry 750 0.132 Hot-Humid 1036 0.182 Mixed-Humid 1468 0.258 Cold/Very Cold 2008 0.353 Marine 424 0.075 Total 5686 1.000 Variables used: CLIMATE_REGION_PUB ClimateRegion_IECC ClimateRegion_IECC n Unweighted Freq 1A-2A 846 0.149 2B 106 0.019 3A 637 0.112 3B-4B 644 0.113 3C 209 0.037 4A 1021 0.180 4C 215 0.038 5A 1240 0.218 5B-5C 332 0.058 6A-6B 376 0.066 7A-7B-7AK-8AK 60 0.011 Total 5686 1.000 Variables used: IECC_CLIMATE_PUB B.3 Continuous WinterTempDay N Missing Minimum Median Maximum 258 50 70 90 Variables used: TEMPHOME WinterTempAway N Missing Minimum Median Maximum 258 50 68 90 Variables used: TEMPGONE WinterTempNight N Missing Minimum Median Maximum 258 50 68 90 Variables used: TEMPNITE SummerTempDay N Missing Minimum Median Maximum 737 50 72 90 Variables used: TEMPHOMEAC SummerTempAway N Missing Minimum Median Maximum 737 50 75 90 Variables used: TEMPGONEAC SummerTempNight N Missing Minimum Median Maximum 737 50 72 90 Variables used: TEMPNITEAC TOTCSQFT Total cooled square footage N Missing Minimum Median Maximum 0 0 1218 8066 TOTHSQFT Total heated square footage N Missing Minimum Median Maximum 0 0 1559 8066 TOTSQFT_EN Total square footage (used for publication) N Missing Minimum Median Maximum 0 221 1774 8501 TOTUCSQFT Total uncooled square footage N Missing Minimum Median Maximum 0 0 400 7986 TOTUSQFT Total unheated square footage N Missing Minimum Median Maximum 0 0 250 6660 CDD30YR Cooling degree days, 30-year average 1981-2010, base temperature 65F N Missing Minimum Median Maximum 0 0 1150 5792 CDD65 Cooling degree days in 2015, base temperature 65F N Missing Minimum Median Maximum 0 0 1378 6607 CDD80 Cooling degree days in 2015, base temperature 80F (used for garage cooling load estimation only) N Missing Minimum Median Maximum 0 0 60 2297 HDD30YR Heating degree days, 30-year average 1981-2010, base temperature 65F N Missing Minimum Median Maximum 0 0 4353 12184 HDD65 Heating degree days in 2015, base temperature 65F N Missing Minimum Median Maximum 0 0 3878 9843 HDD50 Heating degree days in 2015, base temperature 50F (used for garage heating load estimation only) N Missing Minimum Median Maximum 0 0 1260 4956 GNDHDD65 Heating degree days of ground temperature in 2015, base temperature 65F N Missing Minimum Median Maximum 0 0 3704 11851 BTUEL Total site electricity usage, in thousand Btu, 2015 N Missing Minimum Median Maximum 0 201.6 32582 215696 DOLLAREL Total electricity cost, in dollars, 2015 N Missing Minimum Median Maximum 0 18.72 1253 8122 BTUNG Total natural gas usage, in thousand Btu, 2015 N Missing Minimum Median Maximum 0 0 17961 306594 DOLLARNG Total natural gas cost, in dollars, 2015 N Missing Minimum Median Maximum 0 0 231.8 2790 BTULP Total propane usage, in thousand Btu, 2015 N Missing Minimum Median Maximum 0 0 0 220435 DOLLARLP Total cost of propane, in dollars, 2015 N Missing Minimum Median Maximum 0 0 0 5121 BTUFO Total fuel oil/kerosene usage, in thousand Btu, 2015 N Missing Minimum Median Maximum 0 0 0 273608 DOLLARFO Total cost of fuel oil/kerosene, in dollars, 2015 N Missing Minimum Median Maximum 0 0 0 4700 TOTALBTU Total usage, in thousand Btu, 2015 N Missing Minimum Median Maximum 0 201.6 68663 490187 TOTALDOL Total usage, in thousand Btu, 2015 N Missing Minimum Median Maximum 0 60.46 1725 10136 BTUWOOD Total cordwood usage, in thousand Btu, 2015 (Wood consumption is not included in TOTALBTU or TOTALDOL) N Missing Minimum Median Maximum 0 0 0 295476 BTUPELLET Total wood pellet usage, in thousand Btu, 2015 (Wood consumption is not included in TOTALBTU or TOTALDOL) N Missing Minimum Median Maximum 0 0 0 115500 "],["references.html", "References", " References "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
