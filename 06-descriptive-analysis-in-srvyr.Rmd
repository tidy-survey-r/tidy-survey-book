# Descriptive analyses in srvyr {#c06}

## Goals

## Introduction

Descriptive analysis allows you to investigate your dataset and gain insight into the information it contains. Common descriptive analyses include calculating mean, median of numeric data or proportions in categorical data. 

<!--TODO: Add more, particularly on how it's on the analyst to pick the right way of doing descriptive analysis based on the data-->
      
## Overview of descriptive analysis using `srvyr` package

1. Create a `tbl_svy` object using `srvyr::as_survey_design()` or `srvyr::as_survey_rep()`
2. Subset the data for subpopulations using `dplyr::filter()`, if needed
3. Specify domains of analysis using `dplyr::group_by()`, if needed
4. Within `srvyr::summarize()`, specify variables to calculate ,means, totals, proportions, quantiles, and more

### A brief refresher on the `dplyr::summarize()` function

The `dplyr::summarize()` function collapses many values down to a single summary:

<!-- TODO: Add example -->

These verbs can be used in conjunction with `group_by()`, applying the functions on a group-by-group basis to create grouped summaries.

## Setup

With the ANES data, we create a `tbl_svy` object using `srvyr::as_survey_design()` (as described in Chapter 05):

```{r anes_des}
#| error: FALSE
#| warning: FALSE
#| message: FALSE
library(survey) # for survey analysis
library(srvyr) # for tidy survey analysis
library(readr)
library(here)

anes <-
  read_rds(here::here(
    "/Users/ivelasq/R/tidy-survey-short-course/Data/anes_2020.rds"
  )) %>%
  mutate(Weight = Weight / sum(Weight) * 231592693) 
# adjust weight to sum to citizen pop, 18+ in Nov 2020 per ANES methodology documentation

anes_des <- anes %>%
  as_survey_design(
    weights = Weight,
    strata = Stratum,
    ids = VarUnit,
    nest = TRUE
  )
```
  
## Categorical data

_Categorical data_, or the [definition], 

Analyzing categorical data lets us...

Common analysis for categorical data include:

* Weighted proportions
* Weighted counts
* Unweighted proportions
* Unweighted counts

### Count observations using survey methods with `survey_count()`

With `srvyr::survey_count()`, you can produce weighted counts and variance of your choice. The syntax is very similar to the `dplyr::count()` syntax; however, it can only be called on `tbl_srvy()` objects. Let's explore the syntax:

```r
survey_count(
  x,
  ...,
  wt = NULL,
  sort = FALSE,
  name = "n",
  .drop = dplyr::group_by_drop_default(x),
  vartype = c("se", "ci", "var", "cv")
  )
```

The arguments are:

* `x`: a `tbl_svy` object created by `as_survey`
* `...`: variables to group by, passed to `group_by`
* `wt`: a variable to weight on in addition to the survey weights, defaults to `NULL`
* `sort`: how to sort the variables, defaults to `FALSE`
* `name`: the name of the count variable, defaults to `n`
* `.drop`: whether to drop empty groups
* `vartype`: type(s) of variation estimate to calculate, defaults to `se` (standard error)

The steps to use `survey_count()` are:

* Specify the sample design,
* Run `survey_count()`, specifying the required arguments within the function

Let's see the weighted count of responses in ANES:

```{r}
anes_des %>% #  Specify the sample design
  survey_count() # Run `survey_count()`
```

`srvyr::count()` can take one or many variables. To calculate a cross-tab of population in each age group and gender, we run the below:

```{r}
anes_des %>%
  # Specify the required arguments within the function
  survey_count(AgeGroup, Gender, name = "N") 
```

## Calculate totals using survey methods using `survey_total()`

With `srvyr::survey_total()`, you can calculate totals from complex survey data. Let's explore the syntax:

```r
survey_total(
  x,
  na.rm = FALSE,
  vartype = c("se", "ci", "var", "cv"),
  level = 0.95,
  deff = FALSE,
  df = NULL,
  ...
)
```

* `x`: a variable, expression, or empty
* `na.rm`: an indicator of whether missing values should be dropped, defaults to `FALSE`
* `vartype`: type(s) of variation estimate to calculate, defaults to `se` (standard error)
* `level`: a number or a vector indicating the confidence level, defaults to 0.95
* `deff`: a logical value stating whether the design effect should be returned, defaults to FALSE
* `df`: for `vartype = 'ci'), a numeric value indicating degrees of freedome for the t-distribution
  * For the {srvyr} package, this defaults to `NULL` whereas the {survey} package defaults to `Inf`

The steps to use `survey_total()` are:

* Specify the sample design,
* Specify the cross tab in `group_by()`,
* Within `summarize`, run `survey_total()`, specifying the required arguments within the function

To calculate a population count estimate with `survey_total()`, we can run the below:

```{r}
anes_des %>%
  summarize(survey_total(), .groups = "drop")
```

The `.groups =` argument controls the grouping structure of the output. When the output no longer have grouping variables because they are dropped, it becomes ungrouped. <!-- TODO: Check this after dplyr 1.1.0 is released -->

Notice that `anes_des %>% summarize(survey_total(), .groups = "drop")` is equivalent to the `survey_count()` call:

```{r}
anes_des %>%
  survey_count() 
```

The `survey_total()` function is called within `summarize`, where as `survey_count()`, like `dplyr::count()`, is not.

## Calculate mean/proportion using survey methods with `survey_mean()` and `survey_prop()`

The `srvyr::survey_mean()` and `survey_prop()` functions calculate the means and proportions from complex survey data. Like `survey_total()`, they are called within `summarize()`. Let's explore the syntax:

```r
survey_mean(
  x,
  na.rm = FALSE,
  vartype = c("se", "ci", "var", "cv"),
  level = 0.95,
  proportion = FALSE,
  prop_method = c("logit", "likelihood", "asin", "beta", "mean"),
  deff = FALSE,
  df = NULL,
  ...
)

survey_prop(
  vartype = c("se", "ci", "var", "cv"),
  level = 0.95,
  proportion = FALSE,
  prop_method = c("logit", "likelihood", "asin", "beta", "mean"),
  deff = FALSE,
  df = NULL,
  ...
)
```

The steps involved are:

* Specify the sample design,
* Specify the cross tab in `group_by()`,
* Run `survey_mean()` or `survey_prop()` within `summarize()`

Looking at population by age group, we can calculate the weighted proportion for each group in the data:

```{r survey_p_ex1}
anes_des %>%
  group_by(AgeGroup) %>%
  summarize(p1 = survey_mean(),
            .groups = "drop")
```

The `survey_prop()` function is equivalent to leaving out the `x` argument in `survey_mean()`.

```{r}
anes_des %>%
  group_by(AgeGroup) %>%
  summarize(p1 = survey_prop(),
            .groups = "drop")
```

## Other functions that use survey methods

The {srvyr} package includes other functions for summarizing datasets:

* Center: `survey_mean()`, `survey_prop()`, `survey_median()`
* Count: `survey_count()`, `survey_total()`
* Range: `survey_quantile()`
* Ratio: `survey_ratio()`
* Variance: `survey_var()`, `survey_sd()`

## Conditional proportions with more than one group

Specifying more than one group calculates conditional proportions. Say we wanted to know the proportion of people who voted in 2016 and 2020. After the `tbl_svy` object, we specify the two variables we want to calculate proportions for:

```{r survey_p_cond, tidy=FALSE}
anes_des %>%
  filter(!is.na(VotedPres2016),!is.na(VotedPres2020)) %>%
  group_by(VotedPres2016, VotedPres2020) %>%
  summarize(
    p = survey_mean(),
    N = survey_total(),
    n = unweighted(n()),
    .groups = "drop"
  )
```

Note that this is the proportion of **people voting in 2020 by whether people voted in 2016**. That is, it is the weighted number of people who voted in both 2016 and 2020 (144578247), divided by the weighted number of people who voted in 2016 (144578247 + 11917394). Running the above, we see that 92.4% of people who voted in 2016 voted in 2020.

## Joint proportions with more than one group

There are times when we are not interested in conditional proportions. Instead, we want to calculate multiple variables as if they were a single variable. The {srvyr} package includes `interact`, which we can use within `group_by()` to calculate the  joint proportions of two or more variables.

```{r survey_p_joint}
anes_des %>%
  filter(!is.na(VotedPres2020),!is.na(VotedPres2016)) %>%
  group_by(interact(VotedPres2016, VotedPres2020)) %>% #<<
  summarize(p = survey_mean(),
            N = survey_total(),
            .groups = "drop")
```

Since `interact` groups by multiple variables as if they were a single variable, the proportions sum to 100% across more than a single grouping variable.

```{r}
anes_des %>%
  filter(!is.na(VotedPres2020),!is.na(VotedPres2016)) %>%
  group_by(interact(VotedPres2016, VotedPres2020)) %>% #<<
  summarize(p = survey_mean(),
            N = survey_total(),
            .groups = "drop") %>% 
  summarize(p_sum = sum(p))
```

## Proportions with design effects

Note above that functions `survey_total()`, `survey_mean()`, and `survey_prop()` have the argument `deff`. `deff` stands for Design Effect, the ratio of two variances. Use `deff = TRUE` argument to specify whether the design effect should be returned.

```{r survey_p_deff}
anes_des %>%
   filter(!is.na(VotedPres2016), !is.na(VotedPres2020)) %>%
   group_by(interact(VotedPres2016, VotedPres2020)) %>% 
   summarize(
      p=survey_mean(deff=TRUE), #<<
      N=survey_total()
   )
```

